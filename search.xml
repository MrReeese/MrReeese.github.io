<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack 4 打包入门</title>
      <link href="/2020/09/03/webpack/"/>
      <url>/2020/09/03/webpack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm全局安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server -g</p></blockquote><p>进入项目根目录进行局部安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server </p></blockquote><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>我们在开发环境下的项目根目录中创建<code>webpack.dev.js</code>，对webpack进行出口配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry : <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用数组包含多个入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个依赖项随即被处理，最后输出到output设置的指定的 的文件中</p><h2 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h2><p>与webpack3 不同，在<code>webpack.dev.js</code>中新增了一个<code>mode</code>的选项，即选择打包的模式，development（开发环境）production（生产环境），两者的区别很简单，生产环境会对代码进行压缩，即去除所有代码缩进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p>出口是指示将零散的模块汇入到哪一个文件中，出口中设置的文件将包含所有需要的依赖，这里我们使用node的path模块来解析目录</p><p><code>filename</code>：指定最终打包生成的js文件名，可以使用[name]获取入口js的文件名</p><p><code>path</code>：指定输出的目录</p><p><code>publicPath</code>：指定静态资源的根路径，意味着有时候静态资源需要从外部加载，那么要将<code>publicPath</code>指定为一个外部域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发环境调试服务器"><a href="#开发环境调试服务器" class="headerlink" title="开发环境调试服务器"></a>开发环境调试服务器</h2><p>在开发环境中使用webpack并进行调试，并期望进行即时打包与错误提示，那么我们可以使用一下选项</p><p><code>contentBase</code>: 指定服务器读取文件的根目录<br><code>overlay</code>: 布尔值，开启错误提示<br><code>port</code>: 自定义端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        overlay: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        port: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h2><p>webpack需要使用几个额外的模块来对css，图片，html文件进行打包处理</p><p>需要执行一下命令，执行局部安装</p><blockquote><p>npm install style-loader css-loader file-loader extract-loader html-loader</p></blockquote><p>style-loader：负责将打包后生成的css模块以<code>&lt;style&gt;</code>标签的形式插入到html中</p><p>css-loader：负责打包所有css样式</p><p>file-loader：负责找到所需文件资源，并返回其public中的URL</p><p>extract-loader ：它的主要用例是解决来自各自装载器的 HTML 和 CSS 内的 URL</p><p>html-loader：将 HTML 导出为字符串。当编译器要求时，HTML 被最小化（去除缩进）</p><p>我们需要在<code>./config/webpack.dev.js</code>中继续添加一个module选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        overlay: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        port: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                <span class="comment">// css-loaders,找到所有的css文件</span></span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;style-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">&#x27;[name].html&#x27;</span> <span class="comment">// 指定打包后的html文件名称，这里设置[name]就是打包之前html的名称</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123; <span class="comment">// 将html和js文件分开打包</span></span><br><span class="line">                        loader: <span class="string">&#x27;extract-loader&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 配置图片资源加载器image-loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(jpg|git|png)/</span>,</span><br><span class="line">                </span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">&#x27;images/[name]-[hash:8].[ext]&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES语法兼容"><a href="#ES语法兼容" class="headerlink" title="ES语法兼容"></a>ES语法兼容</h2><p>我们知道ES6相对于ES5新增了一些语法方面的内容，这可能导致使用ES6编写的js文件在某些不支持ES6的浏览器上无法被正常执行，所以Babel就出现了，他是一个将ES6语法转换为ES5的js模块</p><p>Babel的使用方法具体可参考官方文档，在这里我们要在webpack中将打包的js文件转换为ES5的版本</p><p>首先是安装Babel核心模块，安装第七版本的babel-loader与webpack中打包使用</p><blockquote><p>npm install babel-core babel-loader@7</p></blockquote><p>安装 babel 的插件</p><blockquote><p>npm install babel-plugin-transform-es2015-arrow-functions</p></blockquote><p>安装完毕后，需要在项目根目录下新建一个文件 <code>.babelrc</code>，来配置Babel中使用的插件，内容为JSON格式</p><p>这里先配置了一个箭头函数的转换</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>./config/webpack.dev.js</code>的module中的rule内添加一个loader即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 选择所有js文件进行</span></span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装async函数语法转换插件，将async转换为<strong>使用promsie的普通函数</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span>,</span><br><span class="line">    <span class="string">&quot;async-to-promises&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Babel</code>默认只会转译语法，比如箭头函数，但是不会转换一些新增的对象方法，例如<code>Object.assign()</code>和<code>Array.prototype.includes()</code>此时，使用额外的三个Babel衍生模块就能更好的处理ECMAScript新增内容</p><p><code>babel-polyfill</code>：常规的babel打包是将打包后的js出口文件进行语法的转换，而<code>babel-polyfill</code>将语法转换提前到打包之前</p><p><code>babel-preset</code>：一个将常用的babel插件集合，也就是说，使用preset会自动配置一些常用的babel插件</p><p><code>babel-transform</code>：<code>babel-polyfill</code>会将Promise等添加成全局变量，污染全局空间，而<code>babel-transform</code>可以解决这个问题</p><p>安装<code>babel-polyfill</code> ：</p><blockquote><p>npm install babel-polyfill  </p></blockquote><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改./config/webpack.dev.js</span></span><br><span class="line">entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装<code>babel-preset</code>：</p><blockquote><p>npm install babel-preset</p></blockquote><p>使用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;debug&quot;</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 前端兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CSS+JS实现一个简单的立方体(可旋转)</title>
      <link href="/2020/09/02/cube/"/>
      <url>/2020/09/02/cube/</url>
      
        <content type="html"><![CDATA[<p>使用CSS3的景深与三维变换+JavaScript实现一个可旋转的立方体（x,y两轴旋转）</p><p>HTML部分：</p><p>首先先构建立方体的DOM结构：</p><ul><li>将6个面使用cube包裹，目的很简单，为了给子元素开启3d景深，</li><li>使用wrap再次包裹，wrap的目的是为了包装整个立方体，可控制缩放</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其对应样式如下：(使用less书写)</p><p>html与body的样式，使用 overflow: hidden; 隐藏垂直滚动条，防止移动端的滑动</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#dfe6e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.wrap:将其设置为100 x 100 px的初始大小，并水平垂直居中，默认将其放大两倍</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>) scale(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.cube : 将其设置为100 x 100 px 的初始大小，并使用另一种水平垂直居中的解决办法，且开启内部元素的3D变换</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cube</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center center; <span class="comment">/*设置旋转中心为立方体的重心*/</span> </span><br><span class="line">    <span class="attribute">transform</span>: rotateX(-<span class="number">30deg</span>) rotateY(<span class="number">30deg</span>); <span class="comment">/*默认将立方体选择一定角度*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写6个面之前，我们需要了解浏览器页面的3D坐标系</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/coordinate_axis.png" alt="css3d"></p><p>从+Z 到 -Z 方向，为用户看向浏览器屏幕的方向，意味着如果不开启3D变换，那么一切元素都是按照Z轴进行选择</p><p>从+Y 到 -Y 方向，为屏幕从下到上的方向，意味着元素会按照Y轴左右旋转</p><p>从+X 到 -X 方向，为屏幕从左到右的方向，意味着元素可以按照X轴上下翻转</p><p>了解了坐标系，那么可以编写css代码了</p><p>首先我们需要将6个面的公共样式提取出，然后分别为每个面定制选择的角度，以及选择的原点，在这里所有的<code>animation: first 1.5s .8s forwards;</code>可以暂时不编写，因为这是附加的入场动画效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.cube-face &#123;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    position: absolute;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: <span class="number">40</span>px;</span><br><span class="line">    line-height: <span class="number">100</span>px;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">    user-select: none;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">1</span>) &#123;</span><br><span class="line">        top: <span class="number">-100</span>%;</span><br><span class="line">        transform: rotateX(<span class="number">90</span>deg) translateY(<span class="number">50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        transform-origin: bottom;</span><br><span class="line">        animation: first <span class="number">1.5</span>s <span class="number">.8</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">2</span>) &#123;</span><br><span class="line">        bottom: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: top;</span><br><span class="line">        transform: rotateX(<span class="number">-90</span>deg) translateY(<span class="number">-50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: second <span class="number">1.5</span>s <span class="number">1</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">3</span>) &#123;</span><br><span class="line">        left: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: right;</span><br><span class="line">        transform: rotateY(<span class="number">-90</span>deg) translateX(<span class="number">50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: third <span class="number">1.5</span>s <span class="number">.4</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">4</span>) &#123;</span><br><span class="line">        right: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: left;</span><br><span class="line">        transform: rotateY(<span class="number">90</span>deg) translateX(<span class="number">-50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: fourth <span class="number">1.5</span>s <span class="number">.6</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">5</span>) &#123;</span><br><span class="line">        transform: rotateY(<span class="number">180</span>deg) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: fifth <span class="number">1.5</span>s <span class="number">.2</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">6</span>) &#123;</span><br><span class="line">        transform: translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: sixth <span class="number">1.5</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你按照我上方的代码编写，你就会发现结果是这样的一个页面：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200902163752855.png" alt="image-20200902163752855"></p><p>这是因为我们最终的目的是要使用@keyframe来进行进场动画，动画必须设置forward为播放一次，且在结束时不变，接下来编写6个css动画：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> first &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(<span class="number">90deg</span>) translateY(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> second &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(-<span class="number">90deg</span>) translateY(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> third &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(-<span class="number">90deg</span>) translateX(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fourth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">90deg</span>) translateX(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fifth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">180deg</span>) translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> sixth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个动画的最终位置就是每个面的正确位置，最后为每个面加上延迟动画即可，这时，你可以看到每一个面交错入场，搭建成一个立方体</p><p>此时需要另外使用一个透明的覆盖层，改变z-index，覆盖整个wrap，用于旋转时的防止立方体元素获得鼠标焦点</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200902155629492.png" alt="image-20200902155629492"></p><p>现在布局以及样式都以及准备完毕了，接下来就进入到JavaScript的编写</p><p>首先获取需要DOM元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrap = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.wrap&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cube = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.cube&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cover = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.cover&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> tip = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.tip &gt; span&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> cubeFace = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.cube-face&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建需要的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keydownPosX;  <span class="comment">//鼠标按下时在在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> keydownPosY;  <span class="comment">//鼠标按下时在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegX = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegY = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> stopDegX = <span class="number">30</span>;  <span class="comment">//上一次X轴旋转的角度</span></span><br><span class="line"><span class="keyword">let</span> stopDegY = <span class="number">-30</span>; <span class="comment">//上一次Y轴旋转的角度</span></span><br><span class="line"><span class="keyword">let</span> timer;<span class="comment">// 自动旋转定时器</span></span><br></pre></td></tr></table></figure><p>设置一个定时器，延时旋转立方体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        stopDegX += <span class="number">.2</span>;</span><br><span class="line">        cube.style.transform = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX&#125;</span>deg)`</span>;</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><p>监听鼠标在cover覆盖层上的事件：分别是按下时，移动时，抬起时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cover.addEventListener(<span class="string">&quot;mousedown&quot;</span>, mousedown)</span><br><span class="line">cover.addEventListener(<span class="string">&quot;mouseup&quot;</span>, mouseup)</span><br><span class="line">cover.addEventListener(<span class="string">&quot;mouseout&quot;</span>, mouseup)</span><br></pre></td></tr></table></figure><p>编写按下时的回调函数：立即清除定时器，记录坐标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousedown</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    keydownPosX = ev.offsetX;</span><br><span class="line">    keydownPosY = ev.offsetY;</span><br><span class="line">    cover.addEventListener(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写拖拽与鼠标抬起事件的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//计算鼠标坐标的变化量，并减小旋转速度，即将鼠标移动的坐标除以3，可调节</span></span><br><span class="line">    currentDegX = (ev.offsetX - keydownPosX) / <span class="number">3</span>; </span><br><span class="line">    currentDegY = -(ev.offsetY - keydownPosY) / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 将坐标变化量加上之前的旋转角度，设置到transform中</span></span><br><span class="line">    cube.style.transform = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY + currentDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX + currentDegX&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseup</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    stopDegX += currentDegX <span class="comment">// 更新增加的角度</span></span><br><span class="line">    stopDegY += currentDegY</span><br><span class="line">    currentDegX = <span class="number">0</span>; <span class="comment">// 将当前鼠标位置数据清空</span></span><br><span class="line">    currentDegY = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 松开后移除鼠标移动事件</span></span><br><span class="line">    cover.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，可旋转立方体基本功能已经完成，代码相对简单，只涉及到事件对象的信息获取以及对元素的样式操作</p><p>最后附上Demo地址： <a href="https://mrreeese.github.io/proxy/web/Cube3Dv2/">cube</a> (使用PC端浏览器打开)</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解MongoDB与mongoose</title>
      <link href="/2020/09/02/mongoDB/"/>
      <url>/2020/09/02/mongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>数据库：存放集合，可以有多个，不需要手动创建</li><li>集合：类似于数组，存放文档，不需要手动创建</li><li>文档：数据的最小单位</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200810170644701.png" alt="image-20200810170644701"></p><p>常用命令</p><ul><li><p>查看数据库占用空间</p><blockquote><p>show dbs</p></blockquote></li><li><p>进入到指定数据库</p><blockquote><p>use 数据库名</p></blockquote></li><li><p>显示当前所在的数据库</p><blockquote><p>db</p></blockquote></li><li><p>显示数据库中所有的集合</p><blockquote><p>show collections</p></blockquote></li><li><p>插入数据到某集合中</p><blockquote><p>db.集合名.insert(js对象类型的键值对)</p></blockquote></li><li><p>查找集合下的所有文档</p><blockquote><p>db.集合名.find() </p></blockquote></li></ul><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>mongoose 是一个对象-文档模型，他对NodeJS原生的MongoDB模块进行了进一步的封装，提供了更多的功能，大多数亲情况下，他被用来把结构化的模式应用到一个集合中</p><ul><li>并且提供数据验证和类型转换的功能</li><li>为文档创建一个约束使得数据结构合法</li><li>使用中间件</li><li>更容易驱动</li></ul><p>核心对象：</p><ul><li>Schema（模式对象），约束了集合中的文档结构</li><li>Model 将集合作为对象来表示，包含在内的所有文档</li><li>Document 表示集合中的一个具体文档对象，每个文档在创建时，都会自动生成一个<code>_id</code>的属性</li></ul><p>代码示例，来源于真实项目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost:27017/test&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>, <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获得数据库对象</span></span><br><span class="line"><span class="keyword">const</span> mongooseConnection = mongoose.connection</span><br><span class="line"><span class="comment">// 监听连接状态</span></span><br><span class="line">mongooseConnection.on(<span class="string">&#x27;connected&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Mongo数据库连接成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义数据约束，与SQL中的表类似</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.Schema(&#123;</span><br><span class="line">  username: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  password: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  userType: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  avatar: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  position: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;, <span class="comment">// 职位信息</span></span><br><span class="line">  personalInfo: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;, <span class="comment">// 个人信息、职位要求</span></span><br><span class="line">  companyInfo: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  salary: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatSchema = mongoose.Schema(&#123;</span><br><span class="line">  from_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的发起者的用户id</span></span><br><span class="line">  to_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的接受者的用户id</span></span><br><span class="line">  chat_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的聊天室id</span></span><br><span class="line">  content: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  hasRead: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  create_time: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userModel = <span class="keyword">new</span> UserModel(&#123;</span><br><span class="line">    username: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    password: md5(<span class="string">&#x27;654321&#x27;</span>),</span><br><span class="line">    type: <span class="string">&#x27;jobSeeker&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  userModel.save(<span class="function">(<span class="params">err, userDoc</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(userDoc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">saveTest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试查询数据，一个或多个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.find(<span class="function">(<span class="params">err, usersDocArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(usersDocArr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  UserModel.findOne(&#123; <span class="attr">_id</span>: <span class="string">&#x27;5f32912c5a24d012779cf1ea&#x27;</span> &#125;,</span><br><span class="line">    (err, userDoc) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(userDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findTest()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.findByIdAndUpdate(</span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">username</span>: <span class="string">&#x27;test-update&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">useFindAndModify</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">    (err,oldUserDoc) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(oldUserDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">updateTest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.deleteOne( <span class="comment">// 这里官方建议使用deleteOne() 和 deleteMany()</span></span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    (err,delInfo) =&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(delInfo)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteTest()</span><br><span class="line"><span class="comment">// 在删除之后返回的对象格式为&#123; n: 1, ok: 1, deletedCount: 0 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> mongoose </tag>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据结构与算法</title>
      <link href="/2020/09/02/javascript_algorithms/"/>
      <url>/2020/09/02/javascript_algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据结构与算法是每一个计算机编程学者的必备知识，在日常生活中，算法无处不在，本文将使用JavaScript实现一些常用的数据结构与算法，例如二叉树的创建以及删除等，以及一些算法的实际应用</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>使用队列实现约瑟夫环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.maxSize = size</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Queue,</span><br><span class="line">  enter (item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.maxSize) &#123;</span><br><span class="line">      item !== <span class="string">&#x27;&#x27;</span> ? <span class="built_in">this</span>.items[<span class="built_in">this</span>.index++] = item : <span class="built_in">console</span>.log(<span class="string">&#x27;数据不能为空&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  shift () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.index--</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列为空&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  peek () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;栈当前为空&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  size () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index</span><br><span class="line">  &#125;,</span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.items = []</span><br><span class="line">  &#125;,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`head-&gt;| <span class="subst">$&#123;<span class="built_in">this</span>.items.map(item =&gt; item)&#125;</span> |&lt;-tail`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">josephRing</span> (<span class="params">arr,num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue(arr.length)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    queue.enter(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;arr.length<span class="number">-1</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;num <span class="number">-1</span> ; j++) &#123;</span><br><span class="line">      queue.enter(queue.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    res = queue.shift()</span><br><span class="line">    <span class="comment">//console.log(res)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.peek()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(josephRing([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用插入排序实现优先级队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">priorityQueue</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span> (<span class="params">value, priority</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.priority = priority</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.maxSize = size</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.enter = <span class="function"><span class="keyword">function</span> (<span class="params">value, priority</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.maxSize) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = <span class="keyword">new</span> QueueElement(value, priority)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经典插入排序</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span><span class="comment">// 扫描标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.items[i].priority &gt; element.priority) &#123; <span class="comment">//检测到有元素的优先级比新元素优先级大</span></span><br><span class="line">            <span class="built_in">this</span>.items.splice(i, <span class="number">0</span>, element) <span class="comment">// 在当前位置插入</span></span><br><span class="line">            flag = <span class="literal">true</span> <span class="comment">// 标识已经插入</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 如果队列中所有的元素优先级都比新元素小</span></span><br><span class="line">          <span class="built_in">this</span>.items.push(element) <span class="comment">// 放置在队列最后</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.index++ <span class="comment">// 增加index</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">priorityQueue.prototype = Queue.prototype <span class="comment">// 继承普通队列的一些方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pQueue = <span class="keyword">new</span> priorityQueue(<span class="number">10</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;Apple&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;sbb&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;lenovo&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pQueue)</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合通常是一组无序，不能重复的元素构成，常见的实现方式为哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Set</span>.prototype = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.items[value] = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  remove: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.items[value]</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getValues: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;,</span><br><span class="line">  isSet:<span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set <span class="keyword">instanceof</span> <span class="built_in">Set</span></span><br><span class="line">  &#125;,</span><br><span class="line">  size: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length</span><br><span class="line">  &#125;,</span><br><span class="line">  clear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Set</span>.prototype.constructor = <span class="built_in">Set</span></span><br></pre></td></tr></table></figure><p>集合间操作：</p><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">union: <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!set <span class="keyword">instanceof</span> <span class="built_in">Set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  values = set.getValues()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unionSet</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intersection:<span class="function"><span class="keyword">function</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set.has(values[i]))&#123;</span><br><span class="line">        intersectionSet.add(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>差集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">difference:<span class="function"><span class="keyword">function</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      differenceSet.add(values[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values = set.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (differenceSet.has(values[i]))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(values[i])</span><br><span class="line">        <span class="keyword">delete</span> differenceSet.remove([values[i]])</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        differenceSet.add(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>子集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">isChild:<span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> values = set.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.has(values[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul><li><p>哈希表通常基于数组实现</p></li><li><p>优点：</p><ul><li>可以提供非常快的插入删除查找 操作</li><li>无论数据规模大小，插入和删除的时间复杂度接近常量O(1)，实际为通过计算得出</li><li>一般情况下性能比树结构快，且编码容易</li></ul></li><li><p>缺点：</p><ul><li>数据无序，且不能通过固定方式顺序遍历</li><li>key不允许重复</li></ul></li><li><p>空间利用率不高</p><ul><li>查找最大最小值不方便</li></ul></li><li><p>哈希化：将对应数据转换为数字</p></li><li><p>哈希函数：将大数字转换为小数字</p></li><li><p>解决冲突：综合来讲，链地址法的效率比较稳定</p><ul><li>链地址法：结合链表存储冲突元素（推荐）</li><li>开放地址法：寻找表中空白位置进行添加<ul><li>线性探测：<ul><li>以线性的方式向后寻找空白位置，</li><li>在查找时候遇到空白位置即停止</li><li>在删除某个冲突元素的时候，将删除后的位置的值作特殊处理</li><li>可能会产生聚集：多个元素在表中连续吗，导致哈希表性能下降</li></ul></li><li>二次探测<ul><li>在产生冲突后，使用<code>x+n^2</code>为跨度进行空白位置的探测，但探测的步长任然是固定的</li></ul></li><li>再哈希法<ul><li>当产生冲突时，将关键字用另外一个哈希函数再次哈希化</li></ul></li></ul></li></ul></li><li><p>哈希函数的选择：</p><ul><li>霍纳法则</li></ul></li><li><p>哈希表的长度：为了实现尽可能最大的均匀分布，在设置哈希表长度的时候尽量使用质数，以及N次幂的底数</p></li></ul><h3 id="实现一个Hash函数"><a href="#实现一个Hash函数" class="headerlink" title="实现一个Hash函数"></a>实现一个Hash函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设计一个哈希函数</span></span><br><span class="line"><span class="comment">* 将字符串转换为比较大的数字HashCode</span></span><br><span class="line"><span class="comment">* 然后将Hashcode压缩到数组的范围之内</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span> (<span class="params">str, size</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化hashCode</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 霍纳算法，使用一个质数和Unicode编码迭代计算出该字符串的hashCode</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    hashCode = <span class="number">43</span> * hashCode + str.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode % size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h3><ul><li><p>普通的判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更高效的判断:<br>如果一个数可以被除了1和本身以外其他数字因式分解，那么他的平方根一定大于等于其因式分解的第一个数，小于等于因式分解的第二个数，如果在平方根到2的范围内不能找到与其整除的数，那么此数就为质数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span> ; i&lt;= <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(num)) ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><ul><li><p>概念：</p><ul><li>二叉搜索树可以为空</li><li>非空左子树的所有节点键值小于其根节点的键值</li><li>非空右子树的所有节点键值大于其根节点的键值</li></ul></li><li><p>基本结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (key) &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>常见操作：</p><ul><li><p>insert(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">insert (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归寻找并插入</span></span><br><span class="line">  insertNode (treeNode, newNode) &#123;</span><br><span class="line">    <span class="comment">// 需判断类型，如果不是Node类的实例，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!newNode <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt;= treeNode.key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.left)&#123; <span class="comment">// 若孩子节点为空，则直接插入</span></span><br><span class="line">        treeNode.left = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则 递归 插入，知道找到空位置</span></span><br><span class="line">        <span class="built_in">this</span>.insertNode(treeNode.left, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.key &gt; treeNode.key)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.right)&#123;</span><br><span class="line">        treeNode.right = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(treeNode.right, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>search(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用递归搜索二叉树  </span></span><br><span class="line">search(key,node = <span class="built_in">this</span>.root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.search(key,node.left) <span class="comment">// 此处必须return，不然上级函数无法收到下级的返回值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.search(key,node.right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 非递归搜索二叉树</span></span><br><span class="line">searchWithoutRecursive(key)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (currentNode)&#123;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; currentNode.key)&#123;</span><br><span class="line">        currentNode = currentNode.left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key)&#123;</span><br><span class="line">        currentNode = currentNode.right</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preOrderTraverse() 前序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历节点:根左右</span></span><br><span class="line">  preOrderTraverse(node = <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(node.key)</span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverse(node.left)</span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverse(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>inOrderTraverse() 中序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树:左根右</span></span><br><span class="line">inOrderTraverse(node = <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverse(node.left)</span><br><span class="line">      <span class="built_in">console</span>.log(node.key)</span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverse(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>postOrderTraverse() 后序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树:左右根</span></span><br><span class="line"> postOrderTraverse(node = <span class="built_in">this</span>.root)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.postOrderTraverse(node.left)</span><br><span class="line">       <span class="built_in">this</span>.postOrderTraverse(node.right)</span><br><span class="line">       <span class="built_in">console</span>.log(node.key)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>min()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">min()&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.root)&#123; <span class="comment">// 空根，退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root <span class="comment">// 一直向左子树寻找，直到左子树为null</span></span><br><span class="line">      <span class="keyword">while</span>(currentNode.left)&#123;</span><br><span class="line">          currentNode = currentNode.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.key</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>max()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.root)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">while</span>(currentNode.right)&#123;</span><br><span class="line">      currentNode = currentNode.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>remove(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">removeNode(key)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.search(key))&#123;</span><br><span class="line">      <span class="keyword">while</span> (currentNode.key !== key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; currentNode.key)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">true</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">false</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(prevNode)</span><br><span class="line">          <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况1： 删除的节点是叶子节点，或者是没有孩子的根节点</span></span><br><span class="line">      <span class="keyword">if</span> (! (currentNode.left &amp;&amp; currentNode.right) )&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( isLeftChild )&#123;</span><br><span class="line">          prevNode.left = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 情况2： 删除的节点只有一个子节点</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有右子节点</span></span><br><span class="line">      <span class="keyword">if</span>(!currentNode.left)&#123;</span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有右子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = currentNode.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = currentNode.right</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有左子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!currentNode.right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有左子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.left</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = currentNode.left</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点，将上一个节点的右节点连接到当前节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = currentNode.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况3：如果删除的节点有2个子节点，情况就复杂起来了</span></span><br><span class="line">      <span class="comment">// 经过多个情况的综合探查，如果要删除有2个子节点的节点，需要找到一个节点将其替换</span></span><br><span class="line">      <span class="comment">// 这个节点必须是删除节点左子树的最大值，称为删除节前驱 或者 右子树的最小值，称为后继</span></span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此处的后继要么没有子节点，要么只有右节点，没有左节点</span></span><br><span class="line">        <span class="keyword">let</span> successor = <span class="built_in">this</span>.getNodeSuccessor(currentNode)</span><br><span class="line">        <span class="comment">// 如果当前删除的节点是根</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          successor.left = currentNode.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被删除的节点是双亲节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = successor</span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = successor</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将删除的节点的左节点接上后继节点</span></span><br><span class="line">        successor.left = currentNode.left</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  没有找到这个节点，返回false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 获取后继节点</span></span><br><span class="line">  getNodeSuccessor(node)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> successorParent = node.right</span><br><span class="line">    <span class="keyword">let</span> successor = node.right</span><br><span class="line">    <span class="comment">// 找到后继节点</span></span><br><span class="line">    <span class="keyword">while</span>(successor.left)&#123;</span><br><span class="line">      successorParent = successor</span><br><span class="line">      successor = successor.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点不是删除的节点的右子树的根</span></span><br><span class="line">    <span class="keyword">if</span> (successor !== node.right)&#123;</span><br><span class="line">      <span class="comment">// 让后继节点的右节点成为 后继节点的双亲节点的左节点（因为后继节点上所有节点都比后继节点的双亲节点小）</span></span><br><span class="line">      successorParent.left = successor.right</span><br><span class="line">      <span class="comment">// 让后继节点的双亲节点成为 后继节点的右节点（比后继大的节点）</span></span><br><span class="line">      successor.right = node.right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> successor</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际操作中，删除二叉树节点操作编码比较复杂，而且开销相对较大，所以一般情况下，尽量避免删除操作，而是给Node节点类添加一个<code>isDelete</code>的Boolean值，来标识当前节点是否删除，这样只需要寻找到删除的节点即可，而标识了被删除的节点在寻找时不会被返回，而是向下寻找或者跳出，但是这种处理方法会浪费大量的空间。</p><h3 id="寻找二叉树的最小深度"><a href="#寻找二叉树的最小深度" class="headerlink" title="寻找二叉树的最小深度"></a>寻找二叉树的最小深度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"> root </span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!root)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(!root.left &amp;&amp; !root.right)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> queue = []</span><br><span class="line">      queue.push(root);</span><br><span class="line">      <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">          <span class="keyword">let</span> len = queue.length <span class="comment">// 必须记录上次放入的节点数，否则depth不会增加</span></span><br><span class="line">          depth++;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">              <span class="keyword">let</span> cur = queue.shift()        </span><br><span class="line">              <span class="keyword">if</span>(!cur.left &amp;&amp; !cur.right)</span><br><span class="line">                  <span class="keyword">return</span> depth;</span><br><span class="line">              <span class="keyword">if</span>(cur.left)</span><br><span class="line">                  queue.push(cur.left);</span><br><span class="line">              <span class="keyword">if</span>(cur.right)</span><br><span class="line">                  queue.push(cur.right);</span><br><span class="line">          &#125;              </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>### 二叉搜索树的缺陷当按照有序，或者大部分有序的的方式插入数据，二叉搜索树的根节点会出现左子树过小，右子树过大，和与之相反的情况，二叉搜索树将失去平衡解决方法：* 使用AVL树，自平衡二叉查找树，每个节点多存储了一个额外的数据* 红黑树：目前广泛使用的平衡树，使用一些特性来保持平衡，在插入、删除操作时，性能优于AVL树  * 节点只有红色和黑色两种  * 根节点是黑色  * 每个叶子节点都是黑色的空节点(NIL)  * 每个红色节点的两个子节点都是黑色  * 从任意节点到其每个叶子姐弟啊你的所有路径都包含相同数目的黑色节点</code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通完全二叉树的问题：n个节点一共有2n个指针，除了根节点之外，n-1个节点都被2n个指针中的n-1个指针引用着，所以剩下2n-(n-1) = n + 1个指针域为null</p><p>如果我们将这n + 1 个指针域在某种遍历次序下存放下一个遍历的前驱或者后继，那么这样的二叉树成为线索二叉树</p><p>按照遍历次序不同可分为三种线索二叉树：前序、中序、后序</p><p>空节点指向规则：</p><ul><li>如果节点的左指针没有被使用，那么左指针指向遍历次序的前驱节点</li><li>如果节点的右指针没有被使用，那么右指针指向遍历次序的后继节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索化二叉树方法,在搜索二叉树的基础上实现</span></span><br><span class="line">inOrderThreadedNodes = <span class="function">(<span class="params">node = <span class="built_in">this</span>.root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">this</span>.inOrderThreadedNodes(node.left)</span><br><span class="line">    <span class="comment">// 处理前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left)&#123;</span><br><span class="line">        node.left = <span class="built_in">this</span>.pre</span><br><span class="line">        node.leftIstree = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理后继节点，使用一个全局变量指向中序遍历的上一个节点，为上一个节点线索后继指针</span></span><br><span class="line">    <span class="comment">// 当pre不为空，且pre的后继指针没有被使用的时候，pre的后继就是当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pre &amp;&amp; !<span class="built_in">this</span>.pre.right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pre.right = node</span><br><span class="line">        <span class="built_in">this</span>.pre.rightIstree = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理节点后，改变pre成为下一个前驱节点</span></span><br><span class="line">    <span class="built_in">this</span>.pre = node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">this</span>.inOrderThreadedNodes(node.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inOrderTraverseThreadedNodes = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="comment">// 当p不为空的时候循环</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="comment">// 当p的节点的左指针指向的是子树而不是前驱，则一直循环直到找到最左的元素</span></span><br><span class="line">        <span class="keyword">while</span> (p.leftIstree)&#123;</span><br><span class="line">            p = p.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出这个值</span></span><br><span class="line">        <span class="built_in">console</span>.log(p.key)</span><br><span class="line">        <span class="comment">// 如果p的右节点指向的不是子树，而是后继节点，则直接向后继节点访问</span></span><br><span class="line">        <span class="keyword">while</span> (!p.rightIstree)&#123;</span><br><span class="line">            p = p.right</span><br><span class="line">            <span class="built_in">console</span>.log(p.key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到了右指针指向子树的节点，则跳转到这个节点，继续循环以上步骤，直到p为null</span></span><br><span class="line">        p = p.right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树（概念）"><a href="#红黑树（概念）" class="headerlink" title="红黑树（概念）"></a>红黑树（概念）</h2><p>红黑树规则</p><ol><li>节点只能是红色和黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色且空节点（NIL节点）</li><li>黑节点可以连续，红节点不能连续出现</li><li>红节点的子节点都必须是黑色节点</li><li>从任意节点到其子树的叶子节点的路径上包含相同的黑色节点</li></ol><p>红黑树特性：</p><ul><li>从根到叶子的最长路径，不会超过最短路径的两倍</li></ul><p>红黑树变换</p><ul><li>插入：新节点一般默认为红色节点，如果新节点为黑色会难以调整</li><li>左旋转：逆时针旋转</li><li>右旋转：顺时针旋转</li></ul><p>红黑树插入</p><p>相关节点角色：红色新节点:N  新节点的兄弟节点:B    新节点的双亲节点:P    新节点的祖节点:G    新节点的双亲节点的兄弟节点:U</p><p>在搜索二叉树规则下进行插入新节点替换为某个黑色NIL节点之后，在红色新节点上添加2个叶子节点NIL，此时有5种可能的情况</p><ol><li><p>N是根节点，直接将N的红色变为黑色（规则2）</p></li><li><p>N的P是黑色，不做任何变换</p></li><li><p>P是红色，U也是红色，G一定为黑色，此时需将P和U变为黑色，G变为红色</p><ol><li>如果变化后G为根节点，则将G以及整个子树都插入到内容为空的红黑树中，即G变为黑色</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200822114725471.png" alt="image-20200822114725471"></p></li><li><p>N是P的左子节点，P为红色，且P的右子节点不为空，U为黑色，G为黑色，此时需要将P变为黑色，G变为红色，再进行右旋转</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200822115425240.png" alt="image-20200822115425240"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200822115551815.png" alt="image-20200822115551815"></p></li><li><p>N是P的右子节点，P为红色，且P的左子节点B不为空，U为黑色，G为黑色，此时</p><ol><li>以P为根进行左旋转</li><li>将G变为红色，N变为黑色，以G为根进行右旋转   </li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200822123122453.png" alt="image-20200822123122453"></p></li></ol><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><ul><li><p>插入排序</p><p>基本思路：以第一个元素作为参照，将之后的元素插入到前方有序数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arrCpy = arr.slice(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrCpy.length; i++) &#123; <span class="comment">// 一共循环n-1次，因为一第一个元素为参照进行插入</span></span><br><span class="line">        temp = arrCpy[i]<span class="comment">// 保存要插入值</span></span><br><span class="line">        <span class="comment">// 从前面的有序序列的最后一个位置开始向前与插入值比较，如果遇到比插入值大的元素，则将该元素往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arrCpy[j] &gt; temp; j--) &#123; </span><br><span class="line">            <span class="comment">// 如果遇到元素的值比插入值小，则直接跳出循环，此时j指向的是比插入值小的元素，j+1此时要么指向i 要么指向已经向后移位的元素</span></span><br><span class="line">            arrCpy[j+<span class="number">1</span>] = arrCpy[j]</span><br><span class="line">        &#125;</span><br><span class="line">        arrCpy[j+<span class="number">1</span>] = temp <span class="comment">// 将值插入进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">6</span>]) )</span><br></pre></td></tr></table></figure></li><li><p>选择排序</p><p>基本思路：每一次循环从数组中选择一个最小/大的数，并记录下标，在循环结束后交换位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j,minIndex</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;arrCpy.length - <span class="number">1</span> ;i++)&#123;</span><br><span class="line">    minIndex = i <span class="comment">// 保存初始下标</span></span><br><span class="line">        <span class="keyword">for</span>( j = i + <span class="number">1</span> ; j &lt; arrCpy.length ; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果找到比minIndex位置小的元素，则更新minIndex</span></span><br><span class="line">            <span class="keyword">if</span>(arrCpy[j] &lt; arrCpy[minIndex])&#123; </span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex !== i)&#123;</span><br><span class="line">            [arrCpy[i],arrCpy[minIndex]]=[arrCpy[minIndex],arrCpy[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交换排序</p><p>基本思路：每一次循环都对比两个数的大小，满足条件就进行交换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arrCpy.length <span class="number">-1</span> ; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span> ; j &lt; arrCpy.length ; j ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[i] &gt; arrCpy[j])&#123;</span><br><span class="line">        [arrCpy[i], arrCpy[j]] = [arrCpy[j], arrCpy[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arrCpy.length  ; i++)&#123;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span> ; j&lt; arrCpy.length -i ; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[j] &gt; arrCpy[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [arrCpy[j],arrCpy[j+<span class="number">1</span>]] = [arrCpy[j+<span class="number">1</span>],arrCpy[j]]</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 如果没有进行过冒泡过程，说明数组已经有序</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希尔排序</p><p>属于插入排序的改进版本，需要选择合适增量，通过从数组中间元素开始向前的位置进行插入排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice()</span><br><span class="line">  <span class="keyword">const</span> length = arrCpy.length</span><br><span class="line">  <span class="comment">// 初始化间隔</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="comment">// 当间隔大于1时循环</span></span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 插入排序的起始位置从数组中间开始，每次都向后方移动一位，与前面对应间隔位置处进行插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 保存插入值</span></span><br><span class="line">      <span class="keyword">const</span> temp = arrCpy[i]</span><br><span class="line">      <span class="comment">// 从插入值i元素的前一个间隔位置开始与 插入值i 比较，如果大于则使用j以间隔向后覆盖</span></span><br><span class="line">      <span class="comment">// 如果遇到小值或者已经到达边界，退出，插入值到j的上一个位置</span></span><br><span class="line">      <span class="keyword">for</span> (j = i - gap; temp &lt; arrCpy[j] &amp;&amp; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">        arrCpy[j + gap] = arrCpy[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arrCpy[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gap减半继续循环</span></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(shellSort([<span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">2352</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li><li><p>js快速排序</p><ul><li>目前最优的排序算法，O(n*log2 n)</li><li>改进版的冒泡排序，每经过一个循环，就确定一个元素在数组中所在的最终位置，不会再被位移</li><li>选择枢纽，使得枢纽左右相对平衡或者随机平衡</li><li>快速排序可以在一次大循环中（包含递归），找出某个元素的正确的位置，并且不需要再次移动</li><li>核心思想：分而治之，选择一个基数，将数组分为2部分，将小于基数的放在左边，大于基数的放在右边，由此可以得到基数最终的位置</li><li>选择一个枢纽，取头 中 尾元素中的一个中位数，例如头部第一个值为3 中部的值为8 尾部值为 1，则选择中部的8作为枢纽</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPivot</span> (<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取数组中部index</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 将前 中 后 三个元素进行排序并交换位置</span></span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">    [array[left], array[right]] = [array[right], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[center]) &#123;</span><br><span class="line">    [array[left], array[center]] = [array[center], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[center] &gt; array[right]) &#123;</span><br><span class="line">    [array[right], array[center]] = [array[center], array[right]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时得到有序的前 中 后 三个元素，中间的元素被选择为第一次递归的排序枢纽</span></span><br><span class="line">  <span class="comment">// 将中部元素与末尾元素的前一个元素进行交换，因为末尾元素在上面三元素排序的时候已经确定比枢纽元素的值大</span></span><br><span class="line">  [array[center], array[right - <span class="number">1</span>]] = [array[right - <span class="number">1</span>], array[center]]</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回处于倒数第二个位置的枢纽元素</span></span><br><span class="line">  <span class="keyword">return</span> array[right - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  quick(arrCpy, <span class="number">0</span>, arrCpy.length - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick1</span> (<span class="params">array, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = getPivot(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">2</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot ) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[j] &gt; pivot ) &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span> (<span class="params">array, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = getPivot(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="comment">// 在寻找完枢纽后，三个以下的元素不用再继续排序，否则两两排序会出现问题</span></span><br><span class="line">  <span class="keyword">if</span>(high - low &lt;= <span class="number">2</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">1</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，从最低位的后一位开始，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[++i] &lt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从枢纽位的前一位开始，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[--j] &gt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果i与high -1 指向的不是同一个位置，则交换</span></span><br><span class="line">  <span class="keyword">if</span>(i !== high <span class="number">-1</span>)</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="计算逆波兰式（后缀表达式）的值"><a href="#计算逆波兰式（后缀表达式）的值" class="headerlink" title="计算逆波兰式（后缀表达式）的值"></a>计算逆波兰式（后缀表达式）的值</h3><ul><li><p>使用递归方法 加 字符串拼接和eval(）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalRPN</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tokens.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^[+\-*\/]$/</span>.test(tokens[i])) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">`(<span class="subst">$&#123;tokens[i - <span class="number">2</span>]&#125;</span>)<span class="subst">$&#123;tokens[i]&#125;</span>(<span class="subst">$&#123;tokens[i - <span class="number">1</span>]&#125;</span>)`</span></span><br><span class="line">        tokens.splice(i - <span class="number">2</span>, <span class="number">3</span>, <span class="built_in">parseInt</span>(<span class="built_in">eval</span>(res)))</span><br><span class="line">        evalRPN(tokens)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tokens[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(evalRPN([<span class="string">&quot;4&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>]))</span><br></pre></td></tr></table></figure></li><li><p>栈方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalRPN2</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = tokens.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> temp = []</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^[+\-*\/]$/</span></span><br><span class="line">  <span class="keyword">const</span> _operators = &#123;</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) + (+b),</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) - (+b),</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) * (+b),</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) / (+b),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (arrCpy.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reg.test(arrCpy[<span class="number">0</span>])) &#123;</span><br><span class="line">      temp.push(arrCpy.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> num2 = temp.pop()</span><br><span class="line">      <span class="keyword">const</span> num1 = temp.pop()</span><br><span class="line">      <span class="keyword">const</span> operator = arrCpy.shift()</span><br><span class="line">      temp.push(_operators[operator](num1, num2))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="转换数字为分隔格式"><a href="#转换数字为分隔格式" class="headerlink" title="转换数字为分隔格式"></a>转换数字为分隔格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paddingNum</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = number.toString()</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>) <span class="comment">//得到整数部分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = left.length - <span class="number">3</span>; i &gt; <span class="number">0</span> ; i -= <span class="number">3</span>) &#123; <span class="comment">//从倒数第三位开始，向前扫描，并插入逗号</span></span><br><span class="line">    left.splice(i, <span class="number">0</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回处理后的整数部分+小数部分</span></span><br><span class="line">  <span class="keyword">return</span> left.join(<span class="string">&#x27;&#x27;</span>).concat(arr[<span class="number">1</span>] ? <span class="string">&#x27;.&#x27;</span>+arr[<span class="number">1</span>]:<span class="string">&#x27;&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现数组扁平化"><a href="#递归实现数组扁平化" class="headerlink" title="递归实现数组扁平化"></a>递归实现数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">steamrollArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 扁平化，扁平化……</span></span><br><span class="line">  <span class="keyword">let</span> res= []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">      res.push(...steamrollArray(item)) <span class="comment">// 调用自身为了深入类型还是Array的元素，使用...为了将返回的数组类型的res进行解开作为上一个push的多个参数，依次递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(steamrollArray([<span class="number">1</span>, &#123;&#125;, [<span class="number">3</span>, [[<span class="number">4</span>]]]])) ;</span><br></pre></td></tr></table></figure><h3 id="实现斐波拉契数列"><a href="#实现斐波拉契数列" class="headerlink" title="实现斐波拉契数列"></a>实现斐波拉契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，n不能超过75025</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FibonacciArray</span>(<span class="params">n,a1=<span class="number">1</span>,a2=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span> a2;</span><br><span class="line">    <span class="keyword">return</span> FibonacciArray(n<span class="number">-1</span>,a2,a1+a2 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span> (<span class="params">n,f1=<span class="number">1</span>,f2=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">    f = f1 + f2</span><br><span class="line">    f1 = f2</span><br><span class="line">    f2 = f</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript正则表达式学习笔记</title>
      <link href="/2020/09/02/regexp/"/>
      <url>/2020/09/02/regexp/</url>
      
        <content type="html"><![CDATA[<h2 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h2><p>字符集放置在<code>[]</code>内部，要创建<code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置<code>插入字符</code>（即<code>^</code>）。</p><p>例如，<code>/[^aeiou]/gi</code>匹配所有非元音字符。注意，字符<code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code>和空白字符等也会被匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;3 blind mice.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[^0-9|aeiou]/gi</span>; <span class="comment">// 匹配数字以及元音以外的所有字符</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(myRegex); </span><br></pre></td></tr></table></figure><h2 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h2><p>匹配出现一次或者连续多次的的字符（或字符组）。它可能出现一次或者多次</p><p>使用<code>+</code>符号来检查情况是否如此。记住，字符或匹配模式必须一个接一个地连续出现。</p><p>例如，<code>/a+/g</code>会在<code>&quot;abc&quot;</code>中匹配到一个匹配项，并且返回<code>[&quot;a&quot;]</code>。因为<code>+</code>的存在，它也会在<code>&quot;aabc&quot;</code>中匹配到一个匹配项，然后返回<code>[&quot;aa&quot;]</code>。</p><p>如果它是检查字符串<code>&quot;abab&quot;</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。最后，因为在字符串<code>&quot;bcd&quot;</code>中没有<code>&quot;a&quot;</code>，因此找不到匹配项。</p><h2 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h2><p>创建一个变量为<code>chewieRegex</code>的正则表达式，使用<code>*</code>符号在<code>chewieQuote</code>中匹配<code>&quot;A&quot;</code>及其之后出现的零个或多个<code>&quot;a&quot;</code>。你的正则表达式不需要使用修饰符，也不需要匹配引号。</p><ul><li><p>你的正则表达式<code>chewieRegex</code>应该使用<code>*</code>符号匹配<code>&quot;A&quot;</code>之后出现的零个或多个<code>&quot;a&quot;</code>字符。</p></li><li><p>你的正则表达式<code>chewieRegex</code>应该匹配 16 个字符。</p></li><li><p>你的正则表达式应该匹配<code>&quot;Aaaaaaaaaaaaaaaa&quot;</code>。</p></li><li><p>你的正则表达式在<code>&quot;He made a fair move. Screaming about it can&#39;t help you.&quot;</code>中不应该匹配任何字符。</p></li><li><p>你的正则表达式在<code>&quot;Let him have it. It&#39;s not wise to upset a Wookiee.&quot;</code>中不应该匹配任何字符</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chewieQuote = <span class="string">&quot;Aaaaaaaaaaaaaaaarrrgh!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> chewieRegex = <span class="regexp">/Aa*/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = chewieQuote.match(chewieRegex);</span><br></pre></td></tr></table></figure><h2 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h2><p>在正则表达式中，<code>贪婪</code>匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为<code>懒惰</code>匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p><p>你可以将正则表达式<code>/t[a-z]*i/</code>应用于字符串<code>&quot;titanic&quot;</code>。这个正则表达式是一个以<code>t</code>开始，以<code>i</code>结束，并且中间有一些字母的匹配模式。</p><p>正则表达式默认是<code>贪婪</code>匹配，因此匹配返回为<code>[&quot;titani&quot;]</code>。它会匹配到适合该匹配模式的最大子字符串。</p><p>但是，你可以使用<code>?</code>字符来将其变成<code>懒惰</code>匹配。调整后的正则表达式<code>/t[a-z]*?i/</code>匹配字符串<code>&quot;titanic&quot;</code>返回<code>[&quot;ti&quot;]</code>。</p><h2 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h2><p>使用字符类，你可以使用<code>[a-z]</code>搜寻字母表中的所有字母。这种字符类是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p><p>JavaScript 中与字母表匹配的最接近的字符类是<code>\w</code>，这个缩写等同于<code>[A-Za-z0-9_]</code>。它不仅可以匹配大小写字母和数字，注意，它还会匹配下划线字符（<code>_</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串内英文句子的单词数</span></span><br><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly .&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegexV2 = <span class="regexp">/\w+/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(alphabetRegexV2).length;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h2 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h2><p>你已经了解到可以使用缩写<code>\w</code>来匹配字母和数字<code>[A-Za-z0-9_]</code>。不过，有可能你想要搜寻的匹配模式与字母数字相反。</p><p>你可以使用<code>\W</code>搜寻和<code>\w</code>相反的匹配模式。注意，相反匹配模式使用大写字母。此缩写与<code>[^A-Za-z0-9_]</code>是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nonAlphabetRegex = <span class="regexp">/\W/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(nonAlphabetRegex).length; <span class="comment">// result = 6</span></span><br></pre></td></tr></table></figure><h2 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h2><p>查找非数字字符的缩写是<code>\D</code>。这等同于字符串<code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p><h2 id="案例：限制可能的用户名"><a href="#案例：限制可能的用户名" class="headerlink" title="案例：限制可能的用户名"></a>案例：限制可能的用户名</h2><p>你需要检查数据库中的所有用户名。以下是用户在创建用户名时必须遵守的一些简单规则。</p><ol><li><p>用户名中的数字必须在最后，且数字可以有零个或多个。</p></li><li><p>用户名字母可以是小写字母和大写字母。</p></li><li><p>用户名长度必须至少为两个字符。两位用户名只能使用字母。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;JackOfAllTrades&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> userCheck = <span class="regexp">/[a-z][a-z]\d*/i</span>;</span><br><span class="line"><span class="keyword">let</span> result = userCheck.test(username);</span><br></pre></td></tr></table></figure><h2 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h2><p>迄今为止的挑战包括匹配的字母和数字。你还可以匹配字母之间的空格。</p><p>你可以使用<code>\s</code>搜寻空格，其中<code>s</code>是小写。此匹配模式不仅匹配空格，还匹配回车符、制表符、换页符和换行符，你可以将其视为与<code>[\r\t\f\n\v]</code>类似。</p><h2 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h2><p>回想一下，你使用加号<code>+</code>查找一个或多个字符，使用星号<code>*</code>查找零个或多个字符。这些都很方便，但有时你需要匹配一定范围的匹配模式。</p><p>你可以使用<code>数量说明符</code>指定匹配模式的上下限。数量说明符与花括号（<code>&#123;</code>和<code>&#125;</code>）一起使用。你可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p><p>例如，要在字符串<code>&quot;ah&quot;</code>中匹配仅出现<code>3</code>到<code>5</code>次的字母<code>a</code>，你的正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p><ul><li>匹配在<code>&quot;Oh no&quot;</code>中仅出现<code>3</code>到<code>6</code>次的字母<code>h</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ohStr = <span class="string">&quot;Ohhh no&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> ohRegex = <span class="regexp">/Oh&#123;3,6&#125; no/</span>;</span><br><span class="line"><span class="keyword">let</span> result = ohRegex.test(ohStr);</span><br></pre></td></tr></table></figure><h2 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h2><p>你可以使用带有花括号的<code>数量说明符</code>来指定匹配模式的上下限。但有时你只需要特定数量的匹配。</p><p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p><p>例如，要只匹配字母<code>a</code>出现<code>3</code>次的单词<code>&quot;hah&quot;</code>，你的正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p><h2 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h2><p>有时，你想要搜寻的匹配模式可能有不确定是否存在的部分。尽管如此，你还是想检查它们。</p><p>为此，你可以使用问号<code>?</code>指定可能存在的元素。这将检查前面的零个或一个元素。你可以将此符号视为前面的元素是可选的</p><ul><li>匹配美式英语（favorite）和英式英语（favourite）的单词版本。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favWord = <span class="string">&quot;favorite&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> favRegex = <span class="regexp">/favou?rite/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = favRegex.test(favWord);</span><br></pre></td></tr></table></figure><h2 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h2><p><strong>先行断言</strong>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这非常有用。</p><p>有两种先行断言方式：<code>正向先行断言</code>和<code>负向先行断言</code></p><p><strong>正向先行断言</strong>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分，每个<code>(?=...)</code>都是一个对整个测试对象的测试规则，</p><p>另一方面，<strong>负向先行断言</strong>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p><ul><li><p><strong>先行断言</strong>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> checkPass = <span class="regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span>;</span><br><span class="line">checkPass.test(password); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>先行断言</strong>以匹配至少5个字符且有两个连续数字的密码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">&quot;astronaut&quot;</span>;</span><br><span class="line"><span class="comment">// \D* 匹配前面多个非数字字符，这2个(?=) 为串行匹配，意思为，先通过第一个(?=)，然后再通过第二个(?=)，每个</span></span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;5,&#125;)(?=\D*\d&#123;2,&#125;)/</span>; </span><br><span class="line"><span class="keyword">let</span> result = pwRegex.test(sampleWord);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组重用模式（重要）"><a href="#使用捕获组重用模式（重要）" class="headerlink" title="使用捕获组重用模式（重要）"></a>使用捕获组重用模式（重要）</h2><p>如果要搜寻的匹配模式会在字符串中出现多次，那么手动重复该正则表达式不是一个高效的方法。此时就需要用到<strong>捕获组</strong></p><p>你可以使用<strong>捕获组</strong>搜寻重复的子字符串。括号<code>(</code>和<code>)</code>可以用来匹配重复的子字符串。你只需要把重复匹配模式的正则表达式放在括号中即可。</p><p>要指定重复字符串将出现的位置，可以使用反斜杠（<code>\</code>）后接一个数字。这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。这里有一个示例，<code>\1</code>可以匹配第一个组。</p><p>下面的示例匹配任意两个被空格分割的单词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatStr = <span class="string">&quot;regex regex&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> repeatRegex = <span class="regexp">/(\w+)\s\1/</span>; <span class="comment">// </span></span><br><span class="line">repeatRegex.test(repeatStr); <span class="comment">// Returns true</span></span><br><span class="line">repeatStr.match(repeatRegex); <span class="comment">// Returns [&quot;regex regex&quot;, &quot;regex&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>此处的\1 为占位符，复用一号位<code>(\w+)</code>匹配到的值作为规则在当前位置进行检测</li><li><code>(\w+)</code> 捕获到第一个单词<code>regex</code> ，那么后面的\1就以这个<code>regex</code>作为当前\1所在位置的规则进行匹配</li></ul><p>在字符串上使用<code>.match()</code>方法将返回一个数组，其中包含它匹配的字符串及其捕获组。</p><ul><li><p>在正则表达式<code>reRegex</code>中使用<code>捕获组</code>，以匹配在字符串中仅重复三次的数字，每一个都由空格分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">&quot;42 42 42&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex =  <span class="regexp">/^(\d+)\s\1\s\1$/</span>; <span class="comment">//使用开头^和结尾$来包裹表达式模板进行严格匹配,\1处复用第一个匹配到的值作为规则</span></span><br><span class="line"><span class="keyword">let</span> result = reRegex.test(repeatNum);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h2><p>搜索功能是很有用的。但是，当你的搜索也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p><p>可以使用字符串上<code>.replace()</code>方法来搜索并替换字符串中的文本。<code>.replace()</code>的输入首先是你想要搜索的正则表达式匹配模式，第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrongText = <span class="string">&quot;The sky is silver.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> silverRegex = <span class="regexp">/silver/</span>;</span><br><span class="line">wrongText.replace(silverRegex, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;The sky is blue.&quot;</span></span><br></pre></td></tr></table></figure><p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Code Camp&quot;</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;Camp Code&quot;</span></span><br></pre></td></tr></table></figure><h2 id="案例：删除开头和结尾的空白"><a href="#案例：删除开头和结尾的空白" class="headerlink" title="案例：删除开头和结尾的空白"></a>案例：删除开头和结尾的空白</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;   Hello, World!  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wsRegex = <span class="regexp">/^\s+|\s+$/g</span>; <span class="comment">// 匹配多个空格开头和结尾的多个空格</span></span><br><span class="line"><span class="keyword">let</span> result = hello.replace(wsRegex,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="案例：验证或者匹配文本中的邮箱"><a href="#案例：验证或者匹配文本中的邮箱" class="headerlink" title="案例：验证或者匹配文本中的邮箱"></a>案例：验证或者匹配文本中的邮箱</h2><ul><li><p>匹配出邮箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;my email is  ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = email.match(emailRegex)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  index: <span class="number">13</span>,</span><br><span class="line">  input: <span class="string">&#x27;my email is  ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>验证邮箱格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/^\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = emailRegex.test(email)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li></ul><h2 id="案例：短线连接格式转换"><a href="#案例：短线连接格式转换" class="headerlink" title="案例：短线连接格式转换"></a>案例：短线连接格式转换</h2><p>在这道题目中，我们需要写一个函数，把一个字符串转换为“短线连接格式”。短线连接格式的意思是，所有字母都是小写，且用<code>-</code>连接。比如，对于<code>Hello World</code>，应该转换为<code>hello-world</code>；对于<code>I love_Javascript-VeryMuch</code>，应该转换为<code>i-love-javascript-very-much</code>。</p><ul><li><p><code>spinalCase(&quot;This Is Spinal Tap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;thisIsSpinalTap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;The_Andy_Griffith_Show&quot;)</code>应该返回<code>&quot;the-andy-griffith-show&quot;</code>。</p></li><li><p><code>spinalCase(&quot;Teletubbies say Eh-oh&quot;)</code>应该返回<code>&quot;teletubbies-say-eh-oh&quot;</code>。</p></li><li><p><code>spinalCase(&quot;AllThe-small Things&quot;)</code>应该返回<code>&quot;all-the-small-things&quot;</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spinalCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = str.replace(<span class="regexp">/^\s+|\s+$/</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  temp = (temp.charAt(<span class="number">0</span>).toUpperCase() + temp.substring(<span class="number">1</span>)) <span class="comment">//将字符串头部</span></span><br><span class="line">    .replace(<span class="regexp">/[\-]/g</span>,<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">    .match(<span class="regexp">/\w+/g</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item.charAt(<span class="number">0</span>).toUpperCase() + item.substring(<span class="number">1</span>))</span><br><span class="line">    .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    .match(<span class="regexp">/[A-Z][a-z]+/g</span>)</span><br><span class="line">    .join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    .toLowerCase()</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spinalCase(<span class="string">&#x27;This Is Spinal Tap&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="儿童黑话"><a href="#儿童黑话" class="headerlink" title="儿童黑话"></a>儿童黑话</h2><p>我们需要写一个函数，把传入的字符串翻译成“儿童黑话”。</p><p><a href="http://en.wikipedia.org/wiki/Pig_Latin">儿童黑话</a>的基本转换规则很简单，只需要把一个英文单词的第一个辅音字母或第一组辅音从移到单词的结尾，并在后面加上<code>ay</code>即可。在英语中，字母 a、e、i、o、u 为元音，其余的字母均为辅音。辅音从的意思是连续的多个辅音字母。</p><p>额外地，如果单词本身是以元音开头的，那只需要在结尾加上<code>way</code>。</p><p>在本题中，传入的单词一定会是英文单词，且所有字母均为小写。</p><ul><li><p><code>translatePigLatin(&quot;california&quot;)</code>应该返回 “aliforniacay”。</p></li><li><p><code>translatePigLatin(&quot;paragraphs&quot;)</code>应该返回 “aragraphspay”。</p></li><li><p><code>translatePigLatin(&quot;glove&quot;)</code>应该返回 “oveglay”。</p></li><li><p><code>translatePigLatin(&quot;algorithm&quot;)</code>应该返回 “algorithmway”。</p></li><li><p><code>translatePigLatin(&quot;eight&quot;)</code>应该返回 “eightway”。</p></li><li><p>你的代码应当能够处理第一个元音字母在单词结尾的情况。比如<code>translatePigLatin(&quot;she&quot;)</code>应该返回 “eshay”。</p></li><li><p>你的代码应当能够处理单词中不含元音字母的情况。比如<code>translatePigLatin(&quot;rhythm&quot;)</code>应该返回 “rhythmay”。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translatePigLatin</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = str.match(<span class="regexp">/[aeiou]\w*/</span>) <span class="comment">// 匹配元音开头且后续字母出现0次或多次的片段</span></span><br><span class="line">  <span class="keyword">let</span> b = str.match(<span class="regexp">/^[^aeiou]+/</span>) <span class="comment">// 匹配以元音字母开头且后续至少一次的片段</span></span><br><span class="line">  <span class="comment">// 如果是以字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^[aeiou]+/</span>.test(str) ? str + <span class="string">&#x27;way&#x27;</span> : (a ? a : <span class="string">&#x27;&#x27;</span>) + (b ? (b + <span class="string">&#x27;ay&#x27;</span>) : <span class="string">&#x27;way&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">translatePigLatin(<span class="string">&quot;consonant&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p>我们需要写一个字符串的搜索与替换函数，它的返回值为完成替换后的新字符串。</p><p>这个函数接收的第一个参数为待替换的句子。第二个参数为句中需要被替换的单词。第三个参数为替换后的单词。</p><p><strong>注意：</strong><br>需要保留被替换单词首字母的大小写格式。即如果传入的第二个参数为 “Book”，第三个参数为 “dog”，那么替换后的结果应为 “Dog”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReplace</span> (<span class="params">str, before, after</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;before&#125;</span>`</span>, <span class="string">&#x27;gi&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z]/</span>.test(str.match(regExp)[<span class="number">0</span>].charAt(<span class="number">0</span>)) ?</span><br><span class="line">    str.replace(regExp, after.charAt(<span class="number">0</span>).toUpperCase() + after.slice(<span class="number">1</span>))</span><br><span class="line">    :</span><br><span class="line">    str.replace(regExp, after)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myReplace(<span class="string">&#x27;He is Sleeping on the couch&#x27;</span>, <span class="string">&#x27;Sleeping&#x27;</span>, <span class="string">&#x27;sitting&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器的基本使用</title>
      <link href="/2020/09/02/docker/"/>
      <url>/2020/09/02/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器的基本使用"><a href="#Docker容器的基本使用" class="headerlink" title="Docker容器的基本使用"></a>Docker容器的基本使用</h1><h2 id="Docker的基本架构"><a href="#Docker的基本架构" class="headerlink" title="Docker的基本架构"></a>Docker的基本架构</h2><p>关键字：</p><ul><li><p>Dockerfiles：Docker本身的配置文件，配置如何构建容器以及镜像，和端口</p></li><li><p>Image：虚拟系统的镜像</p></li><li><p>DockerContainer(容器)：镜像运行的虚拟环境，类似虚拟机</p></li><li><p>镜像仓库：虚拟系统的基本镜像，或者已保存的镜像</p></li></ul><h2 id="Docker的基本指令"><a href="#Docker的基本指令" class="headerlink" title="Docker的基本指令"></a>Docker的基本指令</h2><ul><li><p>查看当前<code>运行的/所有的</code>镜像</p><blockquote><p>docker ps </p><p>docker ps -a</p></blockquote></li><li><p>从仓库拉取原始镜像，以Nginx为例</p><blockquote><p>docker pull nginx</p></blockquote></li><li><p>查看所有镜像：</p><blockquote><p>docker images</p></blockquote></li><li><p>在使用一个镜像，在后台创建并运行一个容器，并添加镜像别名以及进行端口映射：</p><blockquote><p>docker run –name testNginx -p 80:80 -d nginx</p></blockquote></li><li><p>在后台创建并运行一个容器，并将<code>宿主主机指定目录</code>映射到<code>容器的指定目录</code></p><ul><li>将宿主主机下的<code>/home/index</code> 文件夹映射到 容器的<code>/usr/share/nginx/html</code>文件夹中</li><li>当前文件夹使用<code>pwd</code></li></ul><blockquote><p>docker run –name mappedNginx -p 8080:80 -d  -v /home/index:/usr/share/nginx/html nginx(镜像名)</p></blockquote></li><li><p>进入一个正在运行的容器：</p><blockquote><p>docker exec -it 镜像id bash</p></blockquote></li><li><p>运行/停止/重启一个容器</p><blockquote><p>docker start/stop/restart 容器ID</p></blockquote></li><li><p>提交某个镜像为新镜像</p><blockquote><p>docker commit 镜像id 新镜像名</p></blockquote></li><li><p>从容器里面拷贝文件到宿主主机</p><blockquote><p>docker cp 容器名：要拷贝的文件在容器里面的路径  要拷贝到宿主机的相应路径</p></blockquote><ul><li><p>例：容器名为1d1d,从容器里/cert路径下，将nginx.zip从容器里面拷到宿主机的/var/backup路径下面<br>在宿主机上执行命令： </p><p><code>docker cp 1d1d:/cert/nginx.zip /var/backup</code></p></li></ul></li></ul><ul><li><p>从宿主主机拷贝文件到容器中</p><blockquote><p>docker cp 要拷贝的文件路径  容器名：要拷贝到容器里面对应的路径</p></blockquote><ul><li>例：假设容器名为68b99,现在要将宿主机<code>/var/backup/nginx.zip</code>文件拷贝到容器里面的/cert路径下面   在宿主机上执行命令：<code>docker cp /var/backup/nginx.zip 68b99:/cert</code></li></ul></li><li><p>将一个镜像保存到本地文件中</p><blockquote><p>docker save 镜像名称 &gt;自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>从文件恢复镜像</p><blockquote><p>docker load  &lt; 自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>删除docker镜像</p><blockquote><p>docker rmi 镜像名称</p></blockquote></li></ul><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>进入镜像后，默认网页文件在<code>/usr/share/nginx/html</code>下</p><ul><li><p>使用Dockerfile以指定文件创建一个Nginx镜像，并运行</p><ul><li><p>使用vim新建一个dockerfile文件，指定使用的镜像，将当前路径下的所有文件拷贝到目标nginx环境的html目录下</p><blockquote><p>vim dockerfile</p><p>进入编辑</p><p>FROM nginx</p><p>ADD ./  /usr/share/nginx/html  </p></blockquote></li><li><p>使用命令构建一个镜像</p><blockquote><p>docker build -t 自定义镜像名 </p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 模块化规范对比</title>
      <link href="/2020/09/02/javascript_modul/"/>
      <url>/2020/09/02/javascript_modul/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h1><ul><li>避免变量命名冲突</li><li>更好的分离</li><li>更高的维护性</li><li>高可维护性<h1 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h1>全局模式：直接在js模块文件中声明变量    外界能够随意修改其值，不安全<br>命名空间模式：在js模块文件中均为封装的对象  外界能够随意修改其值，不安全<br>IIFE匿名函数自调用模式(闭包)：js模块文件中使用一个立即执行函数进行包装，在内部暴露相应函数，立即执行的函数参数可以为window <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.model1 = &#123;foo&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>IIFE增强模式：在IIFE基础上 在立即函数的参数中加入代码依赖，例如使用jQuery<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,$</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;body&#x27;</span>).css(&#123;</span><br><span class="line">            background : <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.model1 = &#123;changeBg&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>,jQuery)</span><br></pre></td></tr></table></figure><h2 id="原生JS进行模块化"><a href="#原生JS进行模块化" class="headerlink" title="原生JS进行模块化"></a>原生JS进行模块化</h2>使用原生的JS，以匿名函数自调用模式(闭包)的形式进行模块化，实参括号内的参数均为window对象内部属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js ，没有任何依赖的模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用window将getMessage进行暴露</span></span><br><span class="line">    <span class="built_in">window</span>.message = &#123;getMessage&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">//module2.js，依赖于获取数据的module1.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,message</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message.getMessage())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.showMessage = &#123; logMessage &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, message)</span><br><span class="line"><span class="comment">//主模块msg.js，将使用module2.js和module1.js,不需要使用window来暴露模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">showMessage</span>)</span>&#123;</span><br><span class="line">    showMessage.logMessage();</span><br><span class="line">&#125;)(showMessage)</span><br></pre></td></tr></table></figure>原生JS的模块引用必须严格遵守模块的引用顺序<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>NodeJS使用此语法规范，不存在顶级对象window</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>每一个文件都可以当做一个模块<br>服务器(NodeJS)端的模块都是运行时同步加载的<br>浏览器端的模块需要提交打包处理  </p><h4 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>暴露模块本质是吧所有对象的引用保存在exports对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = value</span><br><span class="line"><span class="built_in">exports</span>.fun1 = fun1</span><br></pre></td></tr></table></figure><h4 id="引入并模块"><a href="#引入并模块" class="headerlink" title="引入并模块"></a>引入并模块</h4><p>第三方模块直接传入模块名，自定义则传入相对路径，注意，CommandJs中，需要等待require加载完模块后，才能往后执行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="built_in">require</span>(相对路径/模块名);</span><br><span class="line"><span class="built_in">module</span>.fun1();</span><br></pre></td></tr></table></figure><h2 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h2><p>全名为 异步模块定义 </p><h3 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a>规范</h3><p>专用于浏览器端，模块的加载是异步的</p><h4 id="定义暴露模块"><a href="#定义暴露模块" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h4><p>定义不存在依赖关系的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义有依赖的模块,传入依赖模块名数组、回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入依赖模块名，将依赖的模块注入到回调函数参数中</span></span><br><span class="line">defind([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过参数使用模块 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="AMD规范引入模块实例-需要在lib文件夹下引入Require-js"><a href="#AMD规范引入模块实例-需要在lib文件夹下引入Require-js" class="headerlink" title="AMD规范引入模块实例(需要在lib文件夹下引入Require.js)"></a>AMD规范引入模块实例(需要在lib文件夹下引入Require.js)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义无依赖的模块 module1.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露一个对象，内容为一个函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getMessage&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义依赖于module1.js 的 module2.js</span></span><br><span class="line">define(<span class="string">&#x27;module1&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(module1.getMessage())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;showMessage&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  定义主模块，引用2个子模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    requirejs([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2 </span>)</span>&#123;</span><br><span class="line">        module2.showMessage();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="ES6规范"><a href="#ES6规范" class="headerlink" title="ES6规范"></a>ES6规范</h2><h3 id="规范-2"><a href="#规范-2" class="headerlink" title="规范"></a>规范</h3><p>ES6的依赖模块需要编译打包处理，常使用webpack进行打包</p><h4 id="暴露模块-1"><a href="#暴露模块-1" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>均为暴露一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123;fun1,fun2, ...&#125;</span><br><span class="line"><span class="comment">//默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//默认暴露一个箭头函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="comment">//默认暴露普通函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引入模块-1"><a href="#引入模块-1" class="headerlink" title="引入模块"></a>引入模块</h4><p>引入一般暴露的模块均使用对象形式解构赋值<br>引入默认暴露的模块可自定义引用名 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fun1&#125; <span class="keyword">from</span> <span class="string">&#x27;模块js相对路径&#x27;</span></span><br><span class="line"><span class="keyword">import</span> arrowFunc <span class="keyword">from</span> <span class="string">&#x27;默认暴露模块js相对路径&#x27;</span></span><br><span class="line">fun1()</span><br><span class="line">arrowFunc()</span><br></pre></td></tr></table></figure><p>注意在HTML中引入的时候，需要将脚本标签类型设定为module</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><p>写入@ 注释以给编译器加上参数提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绿茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>一杯绿茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> prepareGreenTea = <span class="function">() =&gt;</span> <span class="string">&#x27;greenTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备红茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>一杯红茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> prepareBlackTea = <span class="function">() =&gt;</span> <span class="string">&#x27;blackTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一定数量的茶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function():string&#125;</span> </span>prepareTea 茶的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>numOfCups 需要茶的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&lt;string&gt;&#125;</span> </span>给定的茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> getTea = <span class="function">(<span class="params">prepareTea, numOfCups</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> teaCups = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> cups = <span class="number">1</span>; cups &lt;= numOfCups; cups += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> teaCup = prepareTea();</span><br><span class="line">    teaCups.push(teaCup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> teaCups;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript模块 </tag>
            
            <tag> 模块化规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6-8 常见新特性</title>
      <link href="/2020/09/02/ES6-8/"/>
      <url>/2020/09/02/ES6-8/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6-8-特性"><a href="#ES6-8-特性" class="headerlink" title="ES6-8 特性"></a>ES6-8 特性</h1><p>本文将总结一ECMAScript 6-8 的常用新特性</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>在ES6之前使用<code>var</code>关键字来声明变量，会出现重复声明导致变量被覆盖却不会报错的问题，且使用<code>var</code>声明的变量会被提升到最前进行解析，使用function声明的函数次之</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(camper);</span><br><span class="line"><span class="comment">// 打印出 &#x27;David&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br><span class="line"><span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><p>与<code>var</code>不同的是，当使用ES6新增的<code>let</code>来声明变量时，没有变量提升，且同一名字的变量只能被声明一次，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;camper&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>let 声明的变量在{} （花括号）中参数局部作用域，作业是不会污染其他作用域，不会影响作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> i  = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"><span class="comment">// 输出错误 Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p><code>const</code> 为 英文 <code>constant</code>的简写，其意为常量</p><p>使用<code>const</code>声明的常量拥有以下规则：</p><ul><li>常量一定要赋初值</li><li>与let一样产生块级作用域</li><li>常量名称一般为全大写字母</li><li>常量值不能修改，对象或者数组类型可修改内部数据，这意味着使用<code>const</code>声明的引用常量在堆内存中的地址不能发生变化</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li><p>数组解构</p><p>在 ES6 里面，解构数组可以如同解构对象一样简单。与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。所以，你不能选择哪个元素来给变量赋值，而对数组进行解构却可以让我们做到这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="comment">//变量a以及b分别被数组的第一、第二个元素赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1, 2, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不通过第三个变量交换二者的值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">8</span>, b = <span class="number">6</span>;</span><br><span class="line">[a,b] = [b,a]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 应该等于 6</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 应该等于 8</span></span><br></pre></td></tr></table></figure></li><li><p>对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,getName&#125; = obj</span><br></pre></td></tr></table></figure></li><li><p>用于函数传参，这里也使用了ES6的新特性，参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connent</span>(<span class="params">&#123;host=<span class="string">&quot;&quot;</span>,username=<span class="string">&quot;初始值&quot;</span>,password,port&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(host,username,password,port)</span><br><span class="line">&#125;</span><br><span class="line">connect(&#123;</span><br><span class="line">    host:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    username:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    port:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在某些情况下，你可以在函数的参数里直接解构对象，这样的操作去除了多余的代码，使代码更加整洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的操作解构了传给函数的对象。这样的操作也可以直接在参数里完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 对这些参数执行某些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样做还有个额外的好处：函数不需要再去操作整个对象，而仅仅是操作复制到函数作用域内部的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">     start: &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>&#125;,</span><br><span class="line">     end: &#123; <span class="attr">x</span>: <span class="number">6</span>, <span class="attr">y</span>: <span class="number">-9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">start</span> : &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125;&#125; = a;</span><br><span class="line"><span class="built_in">console</span>.log(startX, startY); <span class="comment">// 5, 6</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的例子里，<code>a.start</code>将值赋给了变量<code>start</code>，<code>start</code>同样也是个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用解构赋值来得到forecast.tomorrow的max，并将其赋值给maxOfTomorrow。</span></span><br><span class="line"><span class="keyword">const</span> LOCAL_FORECAST = &#123;</span><br><span class="line">  today: &#123; <span class="attr">min</span>: <span class="number">72</span>, <span class="attr">max</span>: <span class="number">83</span> &#125;,</span><br><span class="line">  tomorrow: &#123; <span class="attr">min</span>: <span class="number">73.3</span>, <span class="attr">max</span>: <span class="number">84.6</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxOfTmrw</span>(<span class="params">forecast</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 在这行以下修改代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">tomorrow</span>:&#123;<span class="attr">max</span>:maxOfTomorrow&#125;&#125; = forecast; <span class="comment">// 改变这一行</span></span><br><span class="line">  <span class="comment">// 在这行以上修改代码</span></span><br><span class="line">  <span class="keyword">return</span> maxOfTomorrow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getMaxOfTmrw(LOCAL_FORECAST)); <span class="comment">// 应该为 84.6</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>如果在对象内赋值中发现属性名和属性值变量名称相同，则直接使用属性名即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    apple,</span><br><span class="line">    banana,</span><br><span class="line">    getFruit()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrowFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arrowFunc2 = <span class="function">() =&gt;</span> (<span class="comment">/*返回的内容*/</span>)</span><br></pre></td></tr></table></figure><ul><li>箭头函数内部的this始终指向在声明时的作用域中的this，且<code>this</code>不可被<code>call()`` bind()`` apply()</code> 更改，通常应用于计时器(因为计时器中的this指向的是windows) 以及 定义类中的函数</li><li>内部没有arguments伪数组，意味着不能使用<code>arguments.callee()</code>方法进行自调用</li><li>当内部代码只有return语句时候，return可省略，使用()包裹返回的内容，但执行的代码使用{} 包裹</li></ul><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 在函数中引入 rest参数， 用于获取函数实参，代替arguments </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    args.forEach() <span class="comment">//arg作为一个数组，将传入的参数收入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>ES6 提供了一个新的创建对象的语法，使用关键字<code>class</code>。</p><p>值得注意的是，<code>class</code>只是一个语法糖，它并不像 Java、Python 这一类的语言一样，严格履行了面向对象的开发规范。</p><p>ES6 之前由原型链来进行对象的继承于重用，在构造函数的显式原型上添加公共方法，使用new 来实例化对象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SpaceShuttle = <span class="function"><span class="keyword">function</span>(<span class="params">targetPlanet</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>class</code>的语法只是简单地替换了构造函数的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(targetPlanet)&#123;</span><br><span class="line">  <span class="built_in">this</span>.targetPlanet = targetPlanet;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意<code>class</code>关键字声明了一个新的函数，并在其中添加了一个会在使用<code>new</code>关键字创建新对象时调用的构造函数。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在ES5 中，我们常常用到<strong>组合继承</strong>来实现父子间的继承，即使用原型链继承的方式继承父类的方法，使用借用构造函数的方式继承父级的属性，最后再将子类原型的构造器指向自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmartPhone</span>(<span class="params">brand,price,os,color</span>)</span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>,brand,price);</span><br><span class="line">    <span class="built_in">this</span>.os = os;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子类的构造函数原型</span></span><br><span class="line">SmartPhone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>)</span><br></pre></td></tr></table></figure><p>ES6中的使用类继承，<code>super()</code>方法<strong>只能</strong>在constructor函数中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand,price)&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price</span><br><span class="line">    &#125;</span><br><span class="line">    call()&#123;</span><br><span class="line">       <span class="comment">//打电话函数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand,price,os,color)&#123;</span><br><span class="line">        <span class="built_in">super</span>(brand,price)</span><br><span class="line">        <span class="built_in">this</span>.os = os;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    Photo()&#123;</span><br><span class="line">        <span class="comment">//子类拍照函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>ES6 子类对父类方法重写：直接在子类中添加与父类的同名函数即可</p></li><li><p>ES6 类实例的get和set</p><ul><li><p>get和set方法时默认缺省的，如果声明了<code>get/set 变量名()&#123;&#125;</code>函数，则在读取或修改某个变量时时，都会调用一次该变量的<code>get</code>或<code>set</code>,在<code>get</code>中可以操控返回值，在<code>set</code>中可以操控修改的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand)&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">brand</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;读取品牌信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">brand</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;设置品牌信息&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> Phone()</span><br><span class="line">iPhone.brand = <span class="string">&#x27;Apple&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES6 对象方法扩展</p><ul><li>判断两个数值是否相等：<code>Object.is(a,b)</code></li><li>合并对象：<code>Object.assign(dstObj,srcObj)</code>，源对象会将属性合并到目标对象中，且覆盖目标对象相同的属性值</li><li>设置对象的隐式原型：<code>Object.setPrototypeOf(dstObj,srcObj)</code>,将源对象设置为目标对象的隐式原型<code>__proto__</code></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在class声明的类中，使用<code>static</code>声明的方法将不能被class所创建的实例所调用，只能通过class本身进行调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> staticMethod()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Father.staticMethod()</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><ul><li><p>ES6之前，在构造函数上添加属性，其属性属于函数对象，并不属于构造函数本身，由此构造函数构造的对象不能得到构造函数对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Phone.name = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">Phone.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)=&gt;</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(iPhone.name) <span class="comment">//无法输出</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在ES6的类中，添加静态方法只需要将前缀改为<code>ststic</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="keyword">static</span> call()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Phone.name) <span class="comment">//只能通过此形式访问静态属性</span></span><br></pre></td></tr></table></figure><p>继承：</p></li></ul><h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><p>将伪数组转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> divsArray = [...divs];</span><br></pre></td></tr></table></figure><h2 id="ES6的模块引入方式"><a href="#ES6的模块引入方式" class="headerlink" title="ES6的模块引入方式"></a>ES6的模块引入方式</h2><p>在过去，我们会使用<code>require()</code>函数来从外部文件或模块中引入函数或者代码。这时候会遇到一个问题：有些文件或者模块会特别大，但你却往往只需要引入其中的一些核心代码。</p><p>ES6 给我们提供了<code>import</code>这个便利的工具。通过它，我们能够从外部的文件或者模块中选择我们需要的部分进行引入，从而节约载入的时间和内存空间。</p><p>ES6 同样提供的 <code>export</code> / <code>export default</code>  关键字 来暴露一个模块的方法或者变量，具体使用方式请查阅MDN文档</p><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><ul><li><p>在js文件中使用<code>export</code> / <code>export default</code>暴露函数</p></li><li><p>在html文件中使用： 使用模块的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> * <span class="keyword">as</span> module1 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//可使用as 进行重命名</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123;xxx&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//解构赋值</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> module3&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//将默认暴露的模块在使用时重命名</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> module4 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//直接使用，只能针对默认暴露的模块</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>暴露模块的三种方式：</p><ol><li><code>export xxx</code></li><li><code>export &#123;a,b,c,...&#125;</code></li><li><code>export default &#123;&#125;</code> ，访问时多一层default</li></ol></li><li><p>使用入口js文件</p><ul><li>创建一个<code>app.js</code> 文件，并在html中引入这个作为模块的js文件</li><li>在<code>app.js</code> 文件中引入其他的模块，并使用</li></ul></li><li><p>兼容性：使用<code>babel</code>将 ES6 转换为 ES5 语法</p><ul><li>需要使用npm安装<code>babel-cli</code> <code>babel-present-env</code> <code>browserify(webpack)</code> </li><li>运行<code>npx babel 源js文件/文件夹 目的js文件/文件夹</code></li><li>使用入口文件将一些列模块文件进行打包：<code>npx browserify 源入口js文件 -o 目标入口js文件 </code></li></ul></li></ul><h2 id="Symbol-基本数据类型"><a href="#Symbol-基本数据类型" class="headerlink" title="Symbol 基本数据类型"></a>Symbol 基本数据类型</h2><ul><li>ES6引入的第七个基本数据类型，标识独一无二的值，类似于字符串</li><li>symbol 的值是唯一的，用来解决命名冲突问题</li><li>symbol不能与其他数据进行任何运算，只能进行相等判断</li><li>symbol定义的对象属性不能使用<code>for ... in ...</code> 来遍历，但是可以使用<code>reflect.ownKeys()</code> 来获取key</li><li>使用场景：<ul><li>为对象添加独一无二的值/函数,避免冲突</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>Iterator</strong>是一种接口，为不同 数据结构提供同一的访问机制，任何数据结构只要部署<code>Iterator</code>接口皆可以完成遍历操作 </p><p>每个可迭代的数据类型的实例的隐式原型中都包含一个<code>Symbol(Symbol.iterator)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FRUIT = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = FRUIT[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value:&#x27;apple&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:&#x27;banana&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:&#x27;orange&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:undefined&#x27;,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>自定义遍历对象：</p><p>自定义一个对象中的迭代器，迭代指定部分的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    type:<span class="string">&#x27;fruit&#x27;</span>,</span><br><span class="line">    name:[<span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">         ],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="built_in">this</span>.name.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="built_in">this</span>.name[i++],<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> obj2 )&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>生成器函数是ES6提供的异步编程解决方案之一，语法行为与普通函数完全不同，生成器函数默认返回一个迭代对象，可使用使用迭代器的<code>next()</code>方法 来手动执行函数内部每一行代码 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> genIterator = gen();</span><br><span class="line">genIterator.next(); <span class="comment">//apple</span></span><br><span class="line">genIterator.next(); <span class="comment">//banana</span></span><br><span class="line">genIterator.next(gen()); <span class="comment">//orange</span></span><br></pre></td></tr></table></figure><p>迭代器对象的<code>netx()</code>方法的传参可缺省，默认值为调用的函数</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个<em>基于生成器的版本</em>的<strong>return</strong>关键字。</li><li>yield实际返回一个迭代器对象 例如 <code>&#123;value:&quot; &quot;,done: false &#125;</code>  </li><li>yield 只能配合生成器函数使用</li><li>yield并不能直接生产值，而是产生一个等待输出的函数</li><li>某个函数包含了yield，意味着这个函数已经是一个Generator</li><li>除IE外，其他所有浏览器均可兼容（包括win10 的Edge）</li><li>如果yield在其他表达式中，需要用()单独括起来</li><li>next()可无限调用，但既定循环完成之后总是返回<code>undeinded</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  * <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;  <span class="comment">//到此处直接返回一个迭代对象</span></span><br><span class="line">        <span class="keyword">if</span> (reset) &#123; i = <span class="number">-1</span>;&#125; <span class="comment">//这一行语句不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = count();</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br></pre></td></tr></table></figure><h3 id="yield参数"><a href="#yield参数" class="headerlink" title="yield参数"></a>yield参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  * <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x,y,z)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = test(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.next());   <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next(<span class="number">12</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next(<span class="number">13</span>)); <span class="comment">// 42 = 24 + 5 + 13</span></span><br></pre></td></tr></table></figure><p>当<code>next()</code>传入参数时，只有上一个yield整体等于传入参数，当前迭代的yield仍然返回之后的表达式的值</p><p>异步编程示例1：解决回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数的做法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    one ();</span><br><span class="line">    two ();</span><br><span class="line">    three ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line">iterator.next(); <span class="comment">//从one开始自动遍历</span></span><br></pre></td></tr></table></figure><p>异步编程示例2：模拟业务处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟购物传递信息流程：获取用户数据 → 获取订单数据 → 获取商品数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.next(userInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrderInfo</span>(<span class="params">userInfo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.next(orderInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoodsInfo</span>(<span class="params">orderInfo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="string">&quot;通过传入的orderInfo获取到商品信息&quot;</span></span><br><span class="line">        iterator.next(goodsInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="keyword">yield</span> getUserInfo(userId);</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="keyword">yield</span> getOrderInfo(userInfo);</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="keyword">yield</span> getGoodsInfo(orderInfo);</span><br><span class="line">    <span class="built_in">console</span>.log(goodsInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = gen(<span class="number">11</span>);</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>ES6 引入的异步编程结局方案，<code>Promise</code>是一个构造函数，用来封装异步操作，且可获取成功与失败的结果，</p><p><code>Promise</code>接收一个函数作为参数，其中函数的参数分为<code>resolve</code>和<code>reject</code> 两个函数来分别处理成功与失败两种状态，函数内部进行一系列异步操作，在最后调用<code>resolve(data)</code> 和 <code>reject(data)</code>分别赋予Promise实例成功与失败两种状态:</p><ul><li>调用<code>resolve(data)</code>，返回一个状态为成功(fulfilled)的<code>Promise</code>对象，可以使用<code>then()</code>进行进一步处理</li><li>调用<code>reject(data)</code>，返回一个失败(rejected)的<code>Promise</code>对象，如果没有使用<code>then()</code>进行进一步失败处理，浏览器就会抛出异常，值为data，</li></ul><p>在执行以上操作后可以调用:</p><ul><li><p>then()方法</p><ul><li><p>then()方法接收两个函数：<code>function(value)&#123;...&#125;</code> <code>function(reason)&#123;...&#125;</code> </p><ul><li>当p在初始化时的异步操作调用了<code>reslove()</code>之后，执行<code>then()</code>方法中的第一个回调函数<code>function(value)&#123;...&#125;</code> 代码，<code>value</code>为<code>reslove()</code>的参数</li><li>当p在初始化时的异步操作调用了<code>reject()</code>之后，执行<code>then()</code>方法中的第二个回调函数<code>function(reason)&#123;...&#125;</code>代码，<code>reason</code>为 <code>reject()</code>的参数</li></ul></li><li><p><code>promise.then()</code>方法在调用后，返回一个Promise对象。</p></li><li><p>当在<code>promise.then()</code>的成功/失败的回调中使用<code>return</code><strong>返回一个<code>非Promise对象的值</code>时，<code>promise.then()</code>仍然返回一个状态为成功(fulfilled)的Promise对象</strong>，其中带有promise状态以及返回的值，其中Object类型会被转换成 <code>Object</code>字符串</p></li><li><p>当在<code>promise.then()</code>中使用<code>return</code>返回了一个<code>Promise对象</code>时，此时<code>promise.then()</code>返回的<code>promise</code>对象的成功与否 由 返回的<code>promise</code>对象状态 决定</p></li><li><p>当在<code>promise.then()</code>中<strong>使用<code> throw new Error()</code> 或者<code>thow &quot;error&quot;</code>抛出错误，则<code>promise.then()</code>返回的<code>Promise</code>对象为失败状态</strong>，且promise失败值为 <code>thow</code>抛出值</p></li></ul></li><li><p>案例1：使用Promise处理文件异步读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用Promise 发送AJAX请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">                resolove(xhr.response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line">                reject(xhr.status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>state往往就是一个实体固有的状态。<br>status则偏向于运行时状态。</p></blockquote><p><code>Promise.then()</code>方法的链式调用：</p><ul><li><p>在链式调用的then()方法中，在回调函数中的返回值会作为下一个then()方法中回调的<code>value</code>或<code>reason</code>值，只要在<code>then()</code>的所有回调中使用 <code>return</code>返回了非<code>Promise</code>对象 则状态均为成功<code>reslove</code></p></li><li><p>在<code>then()</code>所有回调函数内使用<code>throw</code>抛出字符串、错误对象 new Error()，则返回的Promise对象状态均为 失败 <code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">   .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>Promise.then()</code>模拟场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> userId = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (userId) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了userId&quot;</span>);</span><br><span class="line">              reslove(userId)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;没有请求到userId&quot;</span>);</span><br><span class="line">              reject();</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> a = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了用户信息&quot;</span>);</span><br><span class="line">              reslove(value + <span class="string">&quot;用户信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到用户的用户信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了订单信息&quot;</span>);</span><br><span class="line">              reslove(<span class="string">&quot;订单信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到的订单信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></li></ul><ul><li>catch()方法：catch()的功能与then()第二个回调函数类似，在Promise对象的状态为失败时调用，一般用于获取</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>集合内部的值不会重复，</p></li><li><p>添加和删除的方法分别为<code>add()</code> <code>delete()</code></p></li><li><p>使用<code>has()</code>方法检测目标是否存在于集合中，返回t/f </p></li><li><p>使用<code>clear()</code>方法清除集合所有元素</p></li><li><p>集合元素个数量使用size()方法得到</p></li><li><p>应用案例：</p><ul><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure></li><li><p>求两数组交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arrSet.has(item))</span><br></pre></td></tr></table></figure></li><li><p>求两数组的并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">[...new <span class="built_in">Set</span>(arr2)].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arrSet.has(item)) &#123;</span><br><span class="line">        arrSet.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arrSet);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> union = [...new <span class="built_in">Set</span>([...arr, ...arr2])];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>ES6 引入的 新数据结构，类似于对象，结构为键值对集合，但是key的类型不一定是字符串，可以是任何类型的值，map同样实现了迭代器接口，可以使用<code>[...]</code>，和<code>for of</code> </p><ul><li>Map元素个数量使用<code>size()</code>方法得到</li><li>new Map()可以接收一个键值对形式的数组：一般以一个<code>key</code>和一个<code>value</code>组成的基本数组，返回一个Map对象</li><li>使用<code>set(key,value)</code> 增加一个元素，并返回更新后的map实例</li><li>使用<code>delete(key)</code> 删除一个键值对，并返回布尔值，找到key并删除value返回true，没有找到key返回false</li><li>使用<code>get(key)</code>返回key的value值</li><li>使用<code>has()</code>检测map是否包含某个元素 ，返回布尔值</li><li>使用<code>clear()</code> 清空map ,返回undefined</li></ul><h2 id="ES6-数值方法扩展"><a href="#ES6-数值方法扩展" class="headerlink" title="ES6 数值方法扩展"></a>ES6 数值方法扩展</h2><ul><li><p>使用<code>Number.EPSILON</code> 来解决js计算精度问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON ? <span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测数值是否为NaN：<code>Number.isNaN()</code>， 返回t/f</p></li><li><p>将小数部分抹去：<code>Number.trunc(floatNumber)</code>， 返回值</p></li><li><ul><li></li></ul></li></ul><h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><ul><li><code>Array.prototype.includes(value)</code>方法，判断value是否存在于数组中，返回布尔值</li><li>使用<code>**</code> 进行幂运算：<code>2 ** 2</code> 等同于 <code>Math.pow(2,2)</code></li></ul><h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><ul><li><p>async 函数</p><ul><li>async 函数为将await 之后的<strong>表达式</strong>以及<strong>await以下的所有语句</strong>都放入异步任务的同步函数</li><li>使用<code>async</code> 为前缀声明的函数的返回值为<code>Promise</code>对象</li><li>返回的<code>Primise</code>对象的状态由<code>async</code> 函数执行的返回值决定，与<code>promise.then()</code>回调函数的<code>return</code>原理相同：如果成功，返回成功promise，并将值放入value中；返回失败promise，则将失败值放入value中</li></ul></li><li><p>await 表达式</p><ul><li><code>await </code>必须写在async函数内部</li><li><code>await</code> <strong>等待右侧promise产生之后，返回值的过程</strong>属于异步微任务，<code>await</code>必须等待到右侧的promise的成功与失败的状态后，线程才会继续执行下面的代码</li><li><code>await</code> 右侧表达式一般为<code>Promise</code> 对象</li><li><code>await</code> 右侧的<code>Promise</code>对象如果状态为成功，则返回其成功的值<code>PromiseValue</code></li></ul></li><li><p><code>await</code> 右侧的<code>Promise</code>对象如果状态为失败，浏览器就会抛出异常，无返回值，需要使用<code>try catch捕获</code> ，<code>catch</code>的参数<code>e</code>为<code>Promise</code>对象失败的值<code>PromiseValue</code></p></li></ul><p>将 async 函数与 await函数相结合使用，将**<code>await </code>等待 <code>promise</code> 之后并返回值** 这过程，放入异步微任务，而在await 之后的代码语句，需要等待<code>await</code> 产生结果后，才能继续执行，且是在在微任务中执行，换句话说，遇到<code>await</code>时就把<code>await</code>之后的代码放入异步微任务，然后再继续向下执行，</p><ul><li><p>案例1：读取文件，使用async函数接收文件信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileReader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">&#x27;文件路径&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) =&gt; reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dataReceiver</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileData = <span class="keyword">await</span> fileReader();</span><br><span class="line">    <span class="keyword">return</span> fileData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用async 与 await 发送AJAX请求并处理消息，这也是<code>axios</code>的实现原理之一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AjaxRequest</span>(<span class="params">requestUrl</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;get&#x27;</span>,requestUrl);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                reslove(xhr.response)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params">requestUrl</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> requestData;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    requestData = <span class="keyword">await</span> AjaxRequest(requestUrl); </span><br><span class="line">        <span class="built_in">console</span>.log(requestData) <span class="comment">//此时await为同步代码，会产生阻塞，当await获得到promise值后才能执行到这一步</span></span><br><span class="line">        <span class="keyword">return</span> requestData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例3：在React组件生命周期中使用async函数 和await 处理请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> axios.get(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ES8-对象扩展"><a href="#ES8-对象扩展" class="headerlink" title="ES8 对象扩展"></a>ES8 对象扩展</h2><ul><li><p><code>Object.keys(object)</code> 获取对象所有的键，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象所有的键值，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象的所有键值，以对象的形式生成一个数组，可以通过数组创建<code>map</code>对象</p></li><li><p>获得对象属性的描述对象 <code>Object.getOwnPropertyDescriptions(object)</code>，返回一个对象，描述object内部所有属性的选项设置(可读、可写、可枚举等)</p></li><li><p>ES5 补充：<code>Object.defineProperty()</code>，对对象属性进行监听，注意不能在get/set中直接调用被修改的属性值，否则造成死循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj,propertyName,&#123;</span><br><span class="line">    <span class="comment">//为此当前对象属性设置函数，例如set、get</span></span><br><span class="line">    <span class="comment">//钩子分别在获取、设置属性值时调用</span></span><br><span class="line">    get()&#123;&#125;</span><br><span class="line">    set()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现ES6的新特性——Promise</title>
      <link href="/2020/08/23/Promise/"/>
      <url>/2020/08/23/Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ECMAscript 6 原生提供了 Promise 对象。Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p></blockquote><h2 id="Promise-是什么？"><a href="#Promise-是什么？" class="headerlink" title="Promise 是什么？"></a>Promise 是什么？</h2><p>抽象的说，Promise是JavaScript中进行异步编程的一个新的解决方案</p><p>具体的说，Promise就是一个构造函数，通过函数构造出的实例可以封装一系列异步操作，并可以从中得到异步操作产生的结果数据</p><h3 id="了解JavaScript事件循环"><a href="#了解JavaScript事件循环" class="headerlink" title="了解JavaScript事件循环"></a>了解JavaScript事件循环</h3><p>在解析promise的机制之前，我们需要掌握浏览器的事件循环，此处引用一张事件循环流程图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/event_loop.png" alt="image"></p><p>在上图中的最后2两行队列均为异步队列，可以观察到，每个宏任务队列后都跟随一个微任务队列，</p><blockquote><p>但请注意，需要把第一个同步任务，即栈内第一个函数执行时的场景视为一个宏任务</p></blockquote><p>在执行栈中的函数遇到异步任务时，会将异步任务交给 右侧相应模块进行处理</p><p>第一个队列为宏任务队列，也是主要的异步任务队列，其中的任务由计数器处理模块，ajax请求线程与文件处理模块(NodeJs)进行推入，</p><p>第二个队列为微任务队列，在promise对象的.then()方法，与process.nextTick()都会在执行时，将传入的回调函数推入<strong>当前宏任务后</strong>的微任务队列，</p><p>当宏任务与微任务相互嵌套时，此时就可能会产生一些异步任务队列与执行栈会相互添加内容，即在栈中异步队列的函数 与 栈中函数产生异步任务，因此形成循环，</p><p>而JS的异步任务常常使用事件驱动的方式被触发，也就是为什么这种循环叫做事件循环</p><h3 id="promise对象状态"><a href="#promise对象状态" class="headerlink" title="promise对象状态"></a>promise对象状态</h3><blockquote><p>一个promise对象只能改变一次状态，而且都会返回一个数据</p></blockquote><ul><li>pending<ul><li>默认状态</li></ul></li><li>fulfilled<ul><li>调用<code>resolve()</code>返回的状态</li><li>英文含义为 解决了 ，实际上表示成功的状态</li><li>返回value</li></ul></li><li>rejected<ul><li>调用<code>reject()</code>返回的状态</li><li>英文含义为 拒绝了  ， 实际上表示为失败的状态</li><li>返回reason</li></ul></li></ul><h3 id="Promise对象的执行流程"><a href="#Promise对象的执行流程" class="headerlink" title="Promise对象的执行流程"></a>Promise对象的执行流程</h3><ol><li>创建一个Promise对象，处于<code>pending</code>状态</li><li>执行异步操作，成功，调用<code>resolve()</code>；失败，调用<code>reject()</code> ，都会返回一个新的promise对象</li><li>执行实例promise.then()方法，按照当前状态，执行内部的回调，可重复步骤2</li></ol><h2 id="为什么要使用Promise？"><a href="#为什么要使用Promise？" class="headerlink" title="为什么要使用Promise？"></a>为什么要使用Promise？</h2><blockquote><p>使用链式调用的编写方式，解决异步回调地狱（代码缩进）的问题 </p></blockquote><p>所谓回调地狱，就是当我们要进行多个异步操作的时候，此时一个回调函数包含另一个异步操作，当异步操作数量达到一定程度时，代码会向右持续缩进，这样会使得程序可读性和可维护性下降</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在上面的计时器回调代码中，我们可以看到代码缩进一直在增加，在实际的开发环境中，如果有几十个回调，那么代码就变得非常的不美观，且不易维护</p><p>但在promise的链式调用中，只需要将上一个处理的对象使用方法继续进行处理，且捕获异常和错误也比较方便</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200826225041424.png" alt="image-20200826225041424"></p><p>解决异步任务的最佳办法，是将promise对象配合 ES8 中新增的 async函数与await来操作结果，其中await会等待promise的值，并将之后的语句放入异步任务中执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/image-20200826225805992.png" alt="image-20200826225805992"></p><h3 id="Promise执行机制"><a href="#Promise执行机制" class="headerlink" title="Promise执行机制"></a>Promise执行机制</h3><blockquote><p>Promise内部利用闭包的机制，通过调用函数来改变不同的状态，由此来执行对应的回调函数</p></blockquote><p>下列代码中，创建了一个promise对象同时立即改变状态，而跟随其后又连续调用2个<code>then()</code>，每个<code>then()</code>调用结束都会<strong>默认</strong>返回一个新的promise对象，而<code>then()</code>中成功/失败的回调内部返回的值则为新promise的<code>value</code>，在这一系列调用中如果没有<strong>抛出任何异常</strong>或者<strong>返回任何失败的promise</strong>，则都会视为<strong>成功</strong>的promise</p><p>注意：<strong>throw xxx 均为失败状态 ,xxx 为reason的值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">11</span>)</span><br><span class="line">  &#125;)).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  ).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>如果想在结果的回调中再执行一个异步任务（也可以说是触发一系列的异步任务），在结果回调函数内需要返回一个新的Promise对象，并成为.then()的返回结果可以在下一次.then()做出更多的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">11</span>)</span><br><span class="line">  &#125;)).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt;&#123;</span><br><span class="line">          <span class="comment">// 异步任务，请求之类的</span></span><br><span class="line">          setTimoeout(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          resolve(<span class="string">&#x27;22&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(reason)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="Promise异常传递"><a href="#Promise异常传递" class="headerlink" title="Promise异常传递"></a>Promise异常传递</h3><p>当promise对象进行一系列任务操作时，在promise链式调用的回调中，不编写处理失败的回调函数，只在链式调用的末尾使用<code>catch()</code>处理异常情况，只要遇到了失败状态的promise，就会将失败的promise逐级传递到最后的<code>catch()</code>失败处理回调中，如果不抛出异常或者返回失败的promise对象，<code>.catch()</code>和<code>.then()</code> 一样，返回成功的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">0</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-中断传递"><a href="#Promise-中断传递" class="headerlink" title="Promise 中断传递"></a>Promise 中断传递</h3><p>如果因为某个错误，想要在链式调用的过程中中断整个过程，则需要返回一个<code>pending</code>状态的promise，即返回<code>new Promise(()=&gt; &#123;&#125;)</code></p><p>原理：因为then()内部的回到函数最终是由调用执行器中的<code>resolve()</code>或者<code>reject()</code>从而触发执行的，返回一个pending的promise显然并没有改变任何状态，因为初始化promise的状态就是<code>pending</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">0</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).then(</span><br><span class="line">       value =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">       &#125;,</span><br><span class="line">       reason =&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span> &#123;&#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><h3 id="方法以及规则"><a href="#方法以及规则" class="headerlink" title="方法以及规则"></a>方法以及规则</h3><p>在了解了官方Promise的使用方法后，为了实现_Promise，我们需要更详细的内部原理与运行机制</p><blockquote><p>自定义Promise一律用<code> _Promise</code>代替，其实例对象标记为<code> _promise</code>  ，</p></blockquote><hr><ul><li>构造函数<code>_Promise</code>的方法<ul><li><code>_Promise(executor)</code></li><li><code>_Promise.resolve(value)</code></li><li><code>_Promise.reject(reason)</code></li><li><code>_Promise.all(promiseArray)</code></li><li><code>_Promise.race(promiseArray)</code></li></ul></li><li>实例对象<code>_promise</code>的方法<ul><li><code>_promise.then(onResolved , onRejected)</code></li><li><code>_promise.catch(onRejected)</code></li></ul></li><li>规则：<ol><li>调用<code>_Promise(executor)</code>进行初始化<code>_promise</code>时：<ol><li>改变状态与值的内部函数<code>resolve(value)</code>或者<code>reject(reason)</code>的调用类型为<strong>异步调用</strong>，意味着可能等待<code>then()</code>执行后才进行调用</li><li>如果存在多次调用<code>resolve(value)</code>或者<code>reject(reason)</code>，则以第一个调用为准，舍弃后续调用</li><li><code>resolve(value)</code>和<code>reject(reason)</code>都不执行，而是使用throw xx来抛出错误，需要将<code>_promise</code>状态设置成<code>rejected</code></li><li>返回一个<code>_Promise</code>实例</li></ol></li><li>调用<code>_promise.then()</code>时<ol><li><code>_promise.then()</code>应该返回一个新的<code>_promise</code>对象</li><li>如果<code>_promise</code>的状态为pending，那么将其推入实例的回调函数数组中</li><li>如果<code>_promise</code>的状态为fulfilled或者rejected，那么将传入的回调立即作为异步函数执行</li><li>如果在规则2.3满足的情况下，回调函数返回了一个_promise对象，那么，<code> _promise.then()</code>返回的新<code> _promise</code> 对象为回调函数返回的对象</li><li><code>promise.then()</code>能够实现传透的功能，即在不传入失败的回调函数<code>onRejected</code>或者成功的回调函数<code>onResloved</code>时，使用<code>then()</code>的链式调用能够将失败的promise往后传递</li></ol></li><li>调用<code>_Promise.resolve(value)</code>时，<code>value</code>可以为_promise类型，也可以为非promise类型，调用后返回一个成功/失败的promise</li><li>调用<code>_Promise.reject(reason)</code>时，<code>reason</code> 只能是非_promise类型的值</li><li>调用<code>_Promise.all(promiseArray)</code> 应该在所有promise均为成功的情况下，返回一个值为所有_promise的值的数组的新的成功的_promise，否则，返回第一个失败的_promise</li><li>调用<code>_Promise.race(promiseArray)</code> 应该返回数组中第一个改变状态的promise</li></ol></li></ul><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="_Promise构造函数"></a>_Promise构造函数</h3><p>_Promise`主构造函数，接收一个函数作为执行器，只收<strong>立即</strong>产生一个promise对象</p><ul><li>构造函数内部拥有三个属性<ul><li>state：保存状态</li><li>data：保存数据</li><li>callbacks：保存一个.then()添加的回到函数的对象</li></ul></li><li>在<code>resolve()</code>和<code>reject()</code>对state和data的改变后，需要符合规则1.1和1.2：即将对应回调函数推入异步任务队列中</li><li>在<code>resolve()</code>和<code>reject()</code>都没有被调用的情况下，需要符合规则1.3 ： 即使用捕获来处理异常情况</li><li>在executor中调用<code>resolve()</code>或者<code>reject()</code> ，其本质是同步/异步地改变状态和值（多数情况下为同步），然后将<code>_promise</code>对象内部的callbacks 中对应的成功或者回调放置在异步队列中进行调用，可能此时callbacks没有回调函数，但是<code>_promise.then()</code>是同步的将回调放入自身callbacks中，即<strong>放入回调函数</strong>这一操作永远比在<strong>异步队列中执行回调函数</strong>先执行，这就是为什么Promise的链式调用能够处理异步请求的原因</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实例的自身状态属性</span></span><br><span class="line">    <span class="built_in">this</span>.state = PENDING <span class="comment">// 对象状态默认为pending</span></span><br><span class="line">    <span class="built_in">this</span>.data = <span class="literal">undefined</span> <span class="comment">// 对象的值默认为undefined</span></span><br><span class="line">    <span class="comment">// 存储自身的回调函数，这个回调函数数组由.then()方法进行传入</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks = [] <span class="comment">// 元素结构为对象，存储2个函数：&#123;onResolved()&#123;&#125;, onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 此时有的执行器内部调用.resolve()的前后2种状态，</span></span><br><span class="line"><span class="comment">    * 1. 调用resolve()之前自身的状态回调函数才被添加，也就意味着执行器内部立即执行.resolve()</span></span><br><span class="line"><span class="comment">    * 2. 调用resolve()之后自身的状态回调函数才被添加，也就意味着执行器内部延迟执行.resolve()</span></span><br><span class="line"><span class="comment">    * 所以无论何时调用resolve()，它必须在被添加回调callbacks之后才能被调用*/</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 去除后续的resolve调用，保证状态的唯一性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将状态改成fulfilled，并保存value到实例data中</span></span><br><span class="line">        <span class="built_in">this</span>.state = FULFILLED</span><br><span class="line">        <span class="built_in">this</span>.data = value</span><br><span class="line">        <span class="comment">// 如果回调数组中有函数，那么将其推入宏任务队列中，异步调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.onResolved(value)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败状态 同理</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.state = REJECTED</span><br><span class="line">        <span class="built_in">this</span>.data = reason</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.onRejected(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即执行外来的executor，并且将2个函数作为参数交给executor,如果有调用resolve或者reject，那也将一并执行,并使用try catch 捕获throw抛出的值或者错误</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果使用function声明的resolve和reject函数，那么内部的this就是指向的window，因为这两个函数被外部传入的箭头函数executor调用，而外部的executor的this指向的是window，那么内部的两个函数就是被windows调用，将resolve和reject改为箭头函数声明，即在声明时就执行父级作用域的this，即new语句产生的_promise对象</p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="_Promise.prototype.then ()"></a>_Promise.prototype.then ()</h3><p>给<code>_Promise</code>主构造函数原型上添加then方法 ，主要用于实例<code>_promise</code></p><ul><li><p>.then() 方法主要是用于同步的将传入的回调函数放入_proimise的callbacks属性中、或者根据promise的状态调用响应的回调函数，最后返回一个新的promise对象</p></li><li><p>_proimise的状态为pending ，那么直接将回调推入callbacks属性中，那么此时构造 _proimise的执行器中的resolve() 或者 rejecte() 还没有被执行，也就是说，在状态还没出现之前，就调用了.then()，那么如何在后面异步任务中产生了状态之后就可以马上执行前面.then()中的回调以及返回新的promise对象呢？</p><ul><li><p>在resolve() 或者 rejecte()被调用的时候也会将回调函数数组中的函数加入异步队列中等待调用，而等待到这些函数被调用的时候，就是返回的promise对象获得状态的时候，而传入的回调onResolved和onRejected也有三种情况：返回promise，返回非promise，抛出异常，使用try catch 以及递归进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="comment">// 当在resolve调用的时候，这里的onResolved会被加入异步队列并被调用，同时也使得返回的promise拥有了状态和值</span></span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onResolved(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onRejected(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>_proimise的状态为resolve或者reject，此时异步队列中已经没有执行的回调，需要在接收到回调的时候将其放入异步队列中，即使用计时器，在计时器异步任务中执行对应状态的回调函数</p><ul><li><p>如果状态回调函数返回的是非_Promise类的值，也就是说手动调用onResolved / onRejected 后返回的值不是 _Promise 类型，那么返回的新对象就在执行器中直接调用<code>resolve(result)</code>来将返回的promise对象设置为 成功的状态（只要不抛出错误且不返回promise的回调均为成功）</p></li><li><p>状态回调函数内部使用<code>throw</code>抛出了异常或者普通值，那么在<code>catch(error)&#123;&#125;</code>中直接将要返回的promise的状态设置为rejected，且值为error</p></li><li><p>状态回调函数内部返回了一个<code>_promise</code>对象，此时需要将这个对象特殊处理</p><ol><li><p>首先整个.then函数的参数接收2个函数，return一个新_promise对象，其中构造函数执行器为同步执行，所以将判断代码放入执行器中</p></li><li><p>判断调用.then方法的本体_promise的状态，其中最简单的如果是pending状态则就仅仅将回调函数放入返回的新<code> _promise</code>对象的回调数组中，然后将在异步任务中被调用，这次情况就符合第一次创建promise对象时，执行器中的resolve()或者rejected()在<strong>异步任务</strong>中的情况</p></li><li><p>如果调用.then方法的本体_promise的状态为fulfilled或者rejected ， 此时需要对应状态使用计时器创建一个新的异步任务，并在这个异步任务中调用.then()传入的回调函数，并拿到回调函数返回的结果，通过结果来进一步生成新的promise作为.then()的返回结果</p></li></ol></li><li><p>那么此时就会遇到一个问题：如何去继承回调中返回的 promise的状态和值呢？如何判断这个promise的状态是成功还是失败呢？</p></li></ul></li><li><p>看到.then()的代码，就可以想到，.then() 就是用来判断一个promise的成功与失败的方法，那么我们可以将这个在回调中返回的promise也调用一次then() ，而且成功与失败的回调设置为.then()这个方法要返回的新promise的状态设置函数<code>resolve(value)</code>和<code>reject(reason)</code>，这样就可以吧状态复制了过去</p></li><li><p>在此可以举一个例子：</p><ul><li><p>假如说现在创建了一个 _Promise实例对象 p,其状态为fulfilled ，值为11</p></li><li><p>然后调用了p.then()方法，其中成功的回调返回了一个新的_Promise实例对象，且状态为成功，值为22</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;resolve(<span class="number">22</span>)&#125;))</span><br></pre></td></tr></table></figure></li><li><p>接着p.then() 这个方法调用后，会返回一个新的 _Promise实例对象，我们来看这个新的 _Promise实例对象是如何产生的</p><ol><li>按照.then()的代码进入return右侧 new _Promise(）的执行器中，在这里，我们将这个 new _Promise(）最后所构造出来的对象称为 p1</li><li>此时的this为最前面的实例对象p，对p的状态进行判断，执行转到 <code>else if (this.state === RESOLVED) &#123;...&#125;</code>中，其内部为一整个异步任务，被主线程放到异步队列中等待执行，此时p.then()的同步任务就执行完毕了</li><li>假设同步任务已经执行完毕，现在跳转到异步任务中执行，也就是开始执行setTimeout中回调的内容，异步任务开始</li><li>在 try catch 中直接将p.then() 内部的函数将p自身的data作为参数放入传入的 <code>value=&gt; ...</code> 箭头函数中执行，此时的<code>onResolved(this.data)</code>就等于带着参数执行了<code>value =&gt; new _Promise((resolve,reject) =&gt; &#123;resolve(22)&#125;</code></li><li>此时判断result，发现返回了一个_Promise的实例对象，这里简称result，其状态为<code>fulfilled</code>，值为22，那么调用这个实例对象<code>result.then()</code>，且成功、失败的的回调函数分别为p1的<code>resolve(value)</code>和<code>reject(reason)</code></li><li>进入到<code>result.then()</code>中，同样又进入一个新promise的创建流程，进入执行器，判断result的状态，上方我们设置的为成功的状态，那么在同步队列执行完的异步队列中同样执行了<code>let result = onResolved(this.data)</code>这一句，且此时的<code>onResolved(this.data)</code>就是p1构造器中的<code>resolve(value)</code>，调用之后，此时p1的对返回的promise对象的状态继承已经完成了，因为没有返回任何值，内部的<code>result</code> 值则为undefined，虽然result.then会返回一个promise，但其实没有用处，可以忽略，此时外部<code>result.then()</code>返回</li><li>这个时候构造p1的异步任务已经完成了，此时通过return返回，成为p.then()</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved , onRejected</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onResolved(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onRejected(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = onResolved(<span class="built_in">this</span>.data)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            <span class="comment">// result.then(</span></span><br><span class="line">              <span class="comment">// 如果手动返回的_promise的执行器中调用的是resolve()，那么则会执行</span></span><br><span class="line">              <span class="comment">// 当成功/失败时，将原来的.then()对象也为成功/失败，并且继承回调内部返回的_promise的值</span></span><br><span class="line">              <span class="comment">//value =&gt; resolve(value),</span></span><br><span class="line">              <span class="comment">//reason =&gt; reject(reason)</span></span><br><span class="line">            <span class="comment">//)</span></span><br><span class="line">            result.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = onRejected(<span class="built_in">this</span>.data)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            result.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时会发现，上面的代码try catch部分重复了4次，所以将重复代码提取为一个新函数，并增加异常传透的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实现传透</span></span><br><span class="line">  <span class="comment">// 如果没有传入成功的回调函数，当promise成功时，会默认将onResolved赋值为一个函数，通过返回值来传递成功的promise</span></span><br><span class="line">  <span class="comment">// 如果没有传入失败的回调函数，当遇到失败的promise时，将onRejected默认赋值为一个函数，通过抛出值来传递失败的的promise</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">  <span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleCall = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = callback(<span class="built_in">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">          result.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            handleCall(onResolved)</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            handleCall(onRejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有一个问题：为什么调用.then()的有状态的promise时候，内部的<code>handleCall(onResolved)</code>要使用异步调用呢？</p><p>这是因为，状态主要是依靠构造promise时执行器中的<code>resolve()</code>和<code>reject()</code>两个函数进行的，而先有回调函数再有状态的原因是在构造器内部使用了计时器调用了<code>resolve()</code>和<code>reject()</code>，导致同步的.then()先执行，将内部传入的回调放进了promise的callbacks中</p><p>但先有状态，后有回调的情况就是：先执行了构造器的所有内容，立即改变了状态以及值，将执行自身的回调函数这一任务放进了计时器，从而变为了在同步任务结束之后的异步任务；接着在结束promise的构造后，立即调用了.then()</p><p>但进入了.then()后，有状态的promise则不会像无状态的一样，直接放入promise的callbacks，来等待<code>resolve()</code>和<code>reject()</code>，因为已经在执行器里面同步执行过了，这个时候.then()要根据调用回调函数的结果，返回一个新的promise，而这一过程往往是应用于发送异步请求，如果在此处直接调用<code>handleCall(onResolved)</code>，那么主线程就会等待这个.then()中回调函数产生的结果从而去创建新promise（包括改变它的状态与值）这一过程，这就违背了Promise思想的初衷</p><p>还有一点就是，异步的<code>handleCall(onResolved)</code>与同步创建promsie的执行器形成了闭包，这样，<code>handleCall(onResolved)</code>在异步任务中执行时，还可以去改变同步任务时创建的状态为pending的promise对象，然后通过队列的形式，先调用.then的先执行，先改变.then返回的promise的状态，这样就形成了前后关系</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="_Promise.prototype.catch()"></a>_Promise.prototype.catch()</h3><p>.catch()其实就是.then()处理失败的情况，传入回调到onRejected 调用并返回.then()的结果即可，其中onResolved的位置设置为<code>undefined</code>或者<code>null</code>都可以 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="_Promise.resolve(value)"></a>_Promise.resolve(value)</h3><p><code>_Promise.resolve(value)</code> 返回一个成功的<code>promise</code>，值为value，value的值可以是普通值，也可以是promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reslove()返回一个新的promise对象，并且需要判断value的类型</span></span><br><span class="line">_Promise.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            <span class="comment">// 此处使用传入的promise.then方法来解决新返回的promise的状态</span></span><br><span class="line">            value.then(resolve, reject)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="_Promise.reject(reason)"></a>_Promise.reject(reason)</h3><p><code>_Promise.reject(reason)</code>返回一个失败的promise，值为reason，reason的值只能为非promise类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reject()方法也是返回一个promise对象，并且只接受一个reason</span></span><br><span class="line">_Promise.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all-promiseArray"><a href="#Promise-all-promiseArray" class="headerlink" title="_Promise.all(promiseArray)"></a>_Promise.all(promiseArray)</h3><p><code>_Promise.all(promiseArray)</code> 返回一个promise，接收一个参数promiseArray(promise数组)，但其中的元素可以是promise对象，也可以是非promise对象</p><ul><li><p>当内部所有promise的状态都为成功的时候，返回成功的promise，且promise的value为一个数组，其值promiseArray所有promise的value</p></li><li><p>否则返回失败的promise 且promise的value为失败promise的value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_Promise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> valueArray = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseArray.length)</span><br><span class="line">            <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 遍历promise数组使用then判断状态，并在回调中执行值的积累和以及改变状态</span></span><br><span class="line">            promiseArray.forEach(<span class="function">(<span class="params">_promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 无论数组中的值是否为promise类型，使用.resolve()将其强制转换为promise对象，再进行.then()的判断</span></span><br><span class="line">                _Promise.resolve(_promise).then(</span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        counter++</span><br><span class="line">                        valueArray[idx] = value</span><br><span class="line">                        <span class="keyword">if</span> (counter === promiseArray.length) &#123;</span><br><span class="line">                            resolve(valueArray)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    reason =&gt; &#123;</span><br><span class="line">                        reject(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>valueArray[idx] = value 这行为什么不能被 valueArray.push(value )代替呢？</p><p>此处不使用push进行增加元素的原因是因为传入的promise在构造时，可能resolve()或者reject()延迟调用的情况，如果使用了索引，那么在同步遍历时，就以闭包的形式锁定了value在数组中的位置</p></blockquote></li></ul><h3 id="Promise-race-promiseArray"><a href="#Promise-race-promiseArray" class="headerlink" title="_Promise.race(promiseArray)"></a>_Promise.race(promiseArray)</h3><p><code>_Promise.race(promiseArray)</code> 返回一个promise，接收一个参数promiseArray(promise数组)</p><ul><li>返回数组中，最快产生成功或者失败状态的promise</li><li>例如：[p1,p2,3]  ,p1延迟2秒更新状态, p2 为同步获得状态，3为非promise，那么将数组看做为一个队列，p2和3为最先获得状态，但p2排在3的前面，所以最终结果输出p2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_Promise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function"><span class="params">__promise</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (_promise <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">                    _promise.then(resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _Promise.resolve(__promise).then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用微任务"><a href="#使用微任务" class="headerlink" title="使用微任务"></a>使用微任务</h3><p>到此你会发现，当promise调用回调函数的时候，总是使用的setTimeout()来将其模拟为异步任务来调用，这个时候就出现了一个问题:</p><p>如果在所有创建promise对象之前就启动一个0秒的定时器来调用输出，那么这个定时器内的内容一定是最先输出的（宏任务队列）这明显不符合promise的一个特点：始终在异步微任务中调用回调函数；</p><p>通过文档了解到所有定时器函数、ajax请求、DOM事件回调均为宏任务，而因为使用了定时器，以上实现的promise并没有启动任何微任务，那么如何将一个回调函数变成在微任务中执行呢？</p><p>这个问题可以在使用CommandJs模块规范的NodeJs中使用<code>process.nextTick(callback)</code>解决，<code>process.nextTick(callback)</code>在NodeJs中用于将回调函数加入微任务队列，由此就可以真正模拟Promise的功能</p><p>以下是_Promise构造函数 以及then()方法的的最终代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.state = PENDING </span><br><span class="line">  <span class="built_in">this</span>.data = <span class="literal">undefined</span> </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = FULFILLED</span><br><span class="line">    <span class="built_in">this</span>.data = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onResolved(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = REJECTED</span><br><span class="line">    <span class="built_in">this</span>.data = reason</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onRejected(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleCall = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = callback(<span class="built_in">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">          result.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">          handleCall(onResolved)</span><br><span class="line">        &#125;, onRejected (reason) &#123;</span><br><span class="line">          handleCall(onRejected)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === FULFILLED) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise面试题"><a href="#Promise面试题" class="headerlink" title="Promise面试题"></a>Promise面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们从头开始解析：</p><ol><li>首先第一句执行<code>console.log(0)</code>的计时器进入宏队列</li><li>主线程同步任务到达第一个new，创建第一个promise ，执行内部的<code>console.log(1)</code>，然后执行<code>then()</code>，将 <code>console.log(2)</code> 以下直到 <code>console.log(6)</code>以上的放入微任务队列</li><li>主线程同步任务到达<code>console.log(6)</code>下方的new，创建第二个promise，执行<code>console.log(7)</code>，然后执行<code>then()</code> 将<code>console.log(8)</code>放入微任务队列</li><li>主线程同步任务执行完毕，开始执行异步任务</li><li>首先执行异步微任务队列</li><li>微任务队列中的<strong>第一个</strong>微任务，包含<code>console.log(2)</code> 的<code>.then()</code>代码块被执行，接着进入<code>console.log(2)</code> 下方的new中执行<code>console.log(3)</code>，以及<code>resolve()</code>，再执行<code>.then()</code>，此时将调用<code>console.log(4)</code>的回调放入微任务队列末尾</li><li>此时第一个<code>promise.then()</code>中的代码已经执行完毕了，即产生了结果，所以他的下一个<code>then()</code>被执行，<code>console.log(6)</code>被加入微任务队列</li><li>接下来执行<strong>微任务队列</strong>中的<strong>第二个</strong>异步微任务，即第二个<code>promise.then()</code>中的<code>console.log(8)</code></li><li>接着处理微任务队列中的<strong>第三个</strong>异步微任务，即第<strong>6</strong>步放入的任务，执行完毕后，执行下一个<code>then()</code>，<code>console.log(5)</code>的回调被放入微任务队列</li><li>接着处理微任务队列中的<strong>第四个</strong>异步微任务，即第<strong>7</strong>步被放入的调用<code>console.log(6)</code>的回调</li><li>最后执行微任务队列中最后一个任务，即第<strong>9</strong>步中放入的调用<code>console.log(5)</code>的回调</li><li>此时<strong>微任务队列</strong>中的任务已经全部执行完毕，开始转到<strong>宏任务队列</strong>中，执行下一个宏任务</li><li>第<strong>1</strong>步中的计时器 <code>console.log(0)</code>被执行，整个过程执行完毕</li><li>整体输出 1 7 2 3 8 4 6 5 0</li></ol><h1 id="Promise总结"><a href="#Promise总结" class="headerlink" title="Promise总结"></a>Promise总结</h1><p>最后，简单的总结一下promise主要的的工作过程</p><ul><li>每个promise对象都拥有一个回调容器，包含成功与失败的回调函数，他们在promise本身被创建的时候并不存在</li><li>promise处理异步任务实质是在于在创建promise实例时，内部的状态改变函数一般为同步执行，改变立即其状态以及值，但同时将执行自身的回调函数放入异步微队列中</li><li>then方法的过程分为两种情况<ul><li>第一种情况是当promise无状态时，将收到的函数<strong>立即</strong>推入promise的回调容器中()，等待主线程处理微任务队列</li><li>第二种情况是当promise有状态时，直接将回调函数调用推入异步微队列，并立即返回一个新的promise对象（此时状态暂时为pending），利用JS的闭包，将改变这个返回的promise对象<strong>状态</strong>的函数放入微任务中的回调内，这样做就可以在异步微任务中更新立即返回的promise对象的状态</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 教程 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 实现div的拖拽与变形</title>
      <link href="/2020/08/20/drag-resize/"/>
      <url>/2020/08/20/drag-resize/</url>
      
        <content type="html"><![CDATA[<h1 id="封装一个简单的拖拽-变形的div的模块"><a href="#封装一个简单的拖拽-变形的div的模块" class="headerlink" title="封装一个简单的拖拽+变形的div的模块"></a>封装一个简单的拖拽+变形的div的模块</h1><p>在编写拖拽与变形之前，我们需要知道DOM与元素大小相关的属性</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/MrReeese/proxy/master/img/EED5E2105E90D3063C11A0116A427264.png" alt="elem-size"></p><p>需要的参数：被拖动的元素css选择器elemSelector，容器元素选择器wrapSelector</p><h2 id="拖拽-边界指针提示部分"><a href="#拖拽-边界指针提示部分" class="headerlink" title="拖拽+边界指针提示部分"></a>拖拽+边界指针提示部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragElement</span> (<span class="params">elemSelector, wrapSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="built_in">document</span>.querySelector(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> wrapDom = <span class="built_in">document</span>.querySelector(wrapSelector)</span><br><span class="line">  <span class="comment">/* 分别需要 </span></span><br><span class="line"><span class="comment">   鼠标左键按下时相对于被拖动元素内部的坐标mouseDownOffsetX, mouseDownOffsetY</span></span><br><span class="line"><span class="comment">   鼠标指针相对于body可视区域的坐标mouseMoveClientX, mouseMoveClientY</span></span><br><span class="line"><span class="comment">   被拖动元素当前的left 与 top 偏移量 elemLeft, elemTop</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> &#123; offsetHeight, offsetWidth &#125; = elemDom</span><br><span class="line">  <span class="keyword">let</span> mouseDownOffsetX, mouseDownOffsetY, mouseMoveClientX, mouseMoveClientY, elemLeft, elemTop</span><br><span class="line">  <span class="comment">// 将被拖动元素设置为绝对定位，并且将容器元素设置为相对定位，</span></span><br><span class="line">  wrapDom.style.position = <span class="string">&#x27;relative&#x27;</span></span><br><span class="line">  elemDom.style.position = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">  <span class="comment">// 监听鼠标在元素内部的移动事件，为不同区域变换不同的指针类型</span></span><br><span class="line">  elemDom.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, elemMouseMove)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标按下时的事件，记录按下的坐标，并同时添加在容器内部移动鼠标，松开鼠标，离开区域的监听事件，其中后两个的目的是移除鼠标松开和离开容器时的鼠标移动监听</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onElemMousedown</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    mouseMoveClientX = e.clientX</span><br><span class="line">    mouseMoveClientY = e.clientY</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, removeListener)</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, removeListener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标在容器上移动的监听事件，实时获取鼠标相对于窗口的坐标，实时改变拖动元素的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mouseMoveOnWrap</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    clientX = e.clientX</span><br><span class="line">    clientY = e.clientY</span><br><span class="line">    elemLeft = mouseMoveClientX - mouseDownOffsetX</span><br><span class="line">    elemTop = mouseMoveClientY - mouseDownOffsetY</span><br><span class="line">    elemDom.style.left = elemLeft + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    elemDom.style.top = elemTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">elemMouseMove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处内部的offsetX, offsetY记录在移动过程中在被拖动元素内部的位置</span></span><br><span class="line">    <span class="keyword">const</span> &#123; offsetX, offsetY &#125; = e</span><br><span class="line">    <span class="comment">// 在元素被变形的时候更新检测宽度和高度，放置在拖动过程中鼠标形状发生错误</span></span><br><span class="line">    offsetHeight = e.target.offsetHeight</span><br><span class="line">    offsetWidth = e.target.offsetWidth</span><br><span class="line">    <span class="comment">//如果 鼠标偏移量在一个内部范围内，即内圈范围，则出现move指针形状，并添加鼠标按下监听事件</span></span><br><span class="line">    <span class="keyword">if</span> (offsetX &gt; <span class="number">6</span> &amp;&amp; offsetX &lt; offsetWidth - <span class="number">6</span> &amp;&amp; offsetY &gt; <span class="number">6</span> &amp;&amp; offsetY &lt; offsetHeight - <span class="number">6</span>) &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;move&#x27;</span></span><br><span class="line">      elemDom.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 此时返回，不做执行移除按下事件</span></span><br><span class="line">    <span class="comment">// 一下是对不同区域变换不同的鼠标指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; <span class="number">-5</span> &amp;&amp; offsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;nw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;ne-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; offsetHeight - <span class="number">5</span> &amp;&amp; offsetY &lt; offsetHeight + <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;sw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;se-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span> || offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;e-resize&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于这些区域都不是拖动的有效区域，在此最好移除鼠标按下事件</span></span><br><span class="line">    elemDom.removeEventListener(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeListener</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.target.style.cursor = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="built_in">arguments</span>.callee) </span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="built_in">arguments</span>.callee)</span><br><span class="line">    <span class="comment">// 此处调用arguments.callee可将mouseup，mouseleave的监听移除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="边缘拖拽变形部分"><a href="#边缘拖拽变形部分" class="headerlink" title="边缘拖拽变形部分"></a>边缘拖拽变形部分</h2><p>所需参数，被拖动的元素选择器elemSelector，拖动元素的最小宽度和高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeRect</span> (<span class="params">elemSelector, minWidth, minHeight</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要的变量鼠标在按下时的浏览器窗口坐标clientClickDownX, clientClickDownY</span></span><br><span class="line"><span class="comment">  鼠标在拖动过程中的浏览器窗口坐标currentClientX, currentClientY</span></span><br><span class="line"><span class="comment">  鼠标在拖动元素内部的相对坐标rectMouseOffsetX, rectMouseOffsetY</span></span><br><span class="line"><span class="comment">  首先初始化记录拖动元素在点击之前的宽度elemWidth和高度elemHeight以及top值和left值</span></span><br><span class="line"><span class="comment">  并设置元素的最小宽度和高度 minWidth，minHeight</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> clientClickDownX, clientClickDownY, currentClientX, currentClientY, rectMouseOffsetX, rectMouseOffsetY</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="built_in">document</span>.querySelector(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> elemHeight = elemDom.offsetHeight</span><br><span class="line">  <span class="keyword">let</span> elemWidth = elemDom.offsetWidth</span><br><span class="line">  <span class="keyword">let</span> elemTop = elemDom.offsetTop</span><br><span class="line">  <span class="keyword">let</span> elemLeft = elemDom.offsetLeft</span><br><span class="line">  elemDom.style.minHeight = minHeight + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  elemDom.style.minWidth = minWidth + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  <span class="comment">// 在按下鼠标的时候，向全局变量记录下按下的浏览器窗口坐标clientClickDown以及元素内部坐标rectMouseOffset</span></span><br><span class="line">  elemDom.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    clientClickDownX = e.clientX</span><br><span class="line">    clientClickDownY = e.clientY</span><br><span class="line">    rectMouseOffsetX = e.offsetX</span><br><span class="line">    rectMouseOffsetY = e.offsetY</span><br><span class="line">  <span class="comment">// 对按下的位置进行判断，分别为上下左右4条边，同时也将4个交也进行了处理，</span></span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &gt; <span class="number">0</span> &amp;&amp; rectMouseOffsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &lt; elemHeight + <span class="number">5</span> &amp;&amp; rectMouseOffsetY &gt; elemHeight - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &gt; <span class="number">-5</span> &amp;&amp; rectMouseOffsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &lt; elemWidth + <span class="number">5</span> &amp;&amp; rectMouseOffsetX &gt; elemWidth - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 在鼠标抬起时，存储当前元素的宽高以及定位，为下一次判断与变形做准备，同时移除4个可能的事件监听</span></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    elemTop = elemDom.offsetTop</span><br><span class="line">    elemLeft = elemDom.offsetLeft</span><br><span class="line">    elemHeight = elemDom.offsetHeight</span><br><span class="line">    elemWidth = elemDom.offsetWidth</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 顶部变形，顶部的型变量等于 鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY，最终的高度等于 上一次的高度elemHeight + 变化量 ，同时如果要将元素保持在原位（对边或者对角线不动）,则需要改变对应的定位值，top定位值则等于 当前的定位值elemTop - （鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY），左侧变化同理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectTopResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientY = e.clientY</span><br><span class="line">    elemDom.style.height = elemHeight + (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.offsetHeight === minHeight) &#123;</span><br><span class="line">      elemDom.style.top = elemDom.offsetTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.style.top = elemTop - (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 底部变形则不需要改变top值，因为div的高度增长默认是向下生长，右侧同理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectBottomResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientY = e.clientY</span><br><span class="line">    elemDom.style.height = elemHeight + (currentClientY - clientClickDownY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectLeftResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientX = e.clientX</span><br><span class="line">    elemDom.style.width = elemWidth + (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.offsetWidth === minWidth) &#123;</span><br><span class="line">      elemDom.style.left = elemDom.offsetLeft + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.style.left = elemLeft - (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectRightResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientX = e.clientX</span><br><span class="line">    elemDom.style.width = elemWidth + (currentClientX - clientClickDownX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h2><p>使用匿名函数自调用(IIFE)，将函数挂载到windows中，成为全局方法,参数minWidth和minHeight默认为5px</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.dragResize = <span class="function"><span class="keyword">function</span> (<span class="params">elemSelector, wrapSelector, minWidth = <span class="number">5</span>, minHeight = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    dragElement(elemSelector, wrapSelector)</span><br><span class="line">    resizeRect(elemSelector, minWidth, minHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>最终的效果，请访问<a href="https://mrreeese.github.io/webpage-demos/drag-resize/">drag-resize</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 拖拽 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
