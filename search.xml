<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React基础</title>
      <link href="/2020/09/12/react-basis/"/>
      <url>/2020/09/12/react-basis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p><p>本文部分内容来源于React官方文档</p></blockquote><h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>JSX是JavaScript的扩展语法，即 JavaScript XML。在React中使用JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式，且具有 JavaScript 的全部功能，JSX 可以生成 React “元素”。</p><h2 id="为什么要使用JSX？"><a href="#为什么要使用JSX？" class="headerlink" title="为什么要使用JSX？"></a>为什么要使用JSX？</h2><ul><li>React认为 元素的逻辑和以及UI存在一定的耦合，一些HTML元素与JS的事件操作相连，但是React并没有采用将视图和逻辑处理分离在不同的文件中，而是将视图和逻辑处理一同存放在称之为“组件”的松散耦合的单元内，实现 关注点分离 ，JSX本身也是一种表达式，在最终打包编译时会转换为普通的JS文件</li><li>JSX 能有效防止跨站脚本攻击( XSS )，因为在React DOM 渲染所有内容之前都被转换成了字符串</li></ul><h2 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h2><p>使用大括号<code>&#123;&#125;</code>可插入JavaScript表达式，或者使用引号<code>&quot; &quot;</code>直接插入字符串值</p><h2 id="JSX-变量命名"><a href="#JSX-变量命名" class="headerlink" title="JSX 变量命名"></a>JSX 变量命名</h2><p>JSX的元素属性跟随React DOM使用小驼峰命名 className，不使用HTML的属性 命名约定，即<code>-</code>间隔的命名，JSX对于元素的声明，类似xml，当标签内部无内容时，可直接使用 /&gt; 来进行闭合</p><h2 id="JSX-的表示对象"><a href="#JSX-的表示对象" class="headerlink" title="JSX 的表示对象"></a>JSX 的表示对象</h2><p><code>Bable</code>规范会将JSX转译成一个名为 <code>React.createElement()</code> 函数调用，<code>React.createElement()</code> 会预先执行一些检查，并在内部创建一个React元素对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;welcome&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//相当于创建了这个对象</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    type:<span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">    props:&#123;</span><br><span class="line">        className:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">        children:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h1><ul><li>React 元素元素描述了你在屏幕上想看到的内容，此处的React元素非 React组件</li><li>React 元素 是构成 React 应用的最小砖块，且React DOM 会负责更新 浏览器原生DOM 来与 React 元素保持一致。</li></ul><h2 id="渲染React-元素为-浏览器-DOM"><a href="#渲染React-元素为-浏览器-DOM" class="headerlink" title="渲染React 元素为 浏览器 DOM"></a>渲染React 元素为 浏览器 DOM</h2><p>id为root的根节点的所有内容均由React DOM管理，仅使用 React 构建的应用通常只有单一的根 DOM 节点。<br>将 React 集成进一个已有应用，那么可以在应用中包含任意多的独立根 DOM 节点。</p><ul><li>想要将React 元素 渲染到DOM中，只需要将它们传入到 <code>ReactDOM.render()</code> 中</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello there<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">ReactDOM.render(element,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="更新已渲染的React-元素"><a href="#更新已渲染的React-元素" class="headerlink" title="更新已渲染的React 元素"></a>更新已渲染的React 元素</h2><p>React元素使用const 进行声明，所以为<strong>不可再赋值对象</strong>，一旦被创建，就无法更改它的子元素或者属性，此时这个React元素表了某个特定时刻的 UI<br>更新UI的唯一方式就是创建一个全新的元素，使用<code>ReactDOM.render()</code>重新进行渲染。<br>想要定时更新UI ，使用<code>window.setInterval()</code>重新声明React元素，调用<code>render()</code>即可 而且 React 只更新它需要更新的部分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态渲染当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currentTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;你好世界!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;当前时间： &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(currentTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="React组件和Prop"><a href="#React组件和Prop" class="headerlink" title="React组件和Prop"></a>React组件和Prop</h2><p>组件: 将UI拆分为独立可复用的代码片段，每个片段拥有独立的构思，组件名称必须以大写字母开头</p><p>一种常见的应用模式是尽可能减少状态组件并创建无状态的函数组件。这有助于将状态管理包含到应用程序的特定区域。反过来，通过更容易地跟踪状态变化如何影响其行为，可以改进应用程序的开发和维护。</p><ul><li><p>组件的定义方式</p><ul><li><p>函数组件：使用JavaScript函数进行返回一个 React元素 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World,I&#x27;m &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>组件名字首字母一定是大写的</p></li><li><p>返回一个jsx、或者一个字符串，jsx依赖React，所以组件内部需要<strong>引入React</strong>。</p></li><li><p>使用</p><ul><li>以标签的方式使用<code>&lt;Component/&gt;</code> ，<ul><li>组件标内的内容不会展示出来</li><li>组件的attributes内className不起作用</li></ul></li><li>直接在双括号内调用<code>&#123; Component() &#125;</code></li></ul></li><li><p>组件传参</p><ul><li>传递： <code>&lt;Component list=&#123; arrData &#125;&gt;&lt;Component&gt;</code></li><li>接收： function Component( props ){…}</li><li>使用： <code>const &#123; list &#125; = props</code>，<code>list</code>就是参数数据 </li></ul></li><li><p>缺点：</p><ul><li>无状态组件：只能实现很简单的视图展示功能，没有自己的内容数据、没有状态，没有逻辑处理</li><li>没有<code>this</code></li><li>没有生命周期，但16.7以后版本的react提供了React Hook</li><li>内部不用render函数，会自动把return返回结果当做render返回结果</li></ul></li></ul></li></ul></li></ul><ul><li><p>类组件：使用ES6的类(class)继承<code>React.Component</code>来定义的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;h1&gt;Hello World,I<span class="string">&#x27;m &#123;this.props.name&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><p>react元素可以是普通HTML标签，也可以是自定义组件标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h3><p>可以将多个组件组合起来组成另一个React元素，但是每个React应用的最顶层组件都是App组件</p><h3 id="拆分组件"><a href="#拆分组件" class="headerlink" title="拆分组件"></a>拆分组件</h3><p>将组件拆分为更小的组件，在通过行内<code>attribute</code>方式传递值</p><h3 id="props的只读性质"><a href="#props的只读性质" class="headerlink" title="props的只读性质"></a>props的只读性质</h3><p>在JS中 ，不改变传入参数的函数称之为 纯函数，相反，在函数执行过程中改变了参数的函数称之为 非纯函数，<br>所有React的组件必须像纯函数一样保护props，props无法被组件自身修改， 但是state可以</p><h3 id="state-以及-生命周期"><a href="#state-以及-生命周期" class="headerlink" title="state 以及 生命周期"></a>state 以及 生命周期</h3><p><code>state</code> 与 <code>props</code> 类似，但是 <code>state</code> 是私有的，并且完全受控于当前组件，<code>state</code>声明在以class创建的React组件内部的<code>constructor()</code>中，通过传入<code>props</code>，使得<code>state</code>可以接收<code>props</code>传递的数据<br>当组件第一次被渲染到页面时，在React生命周期中称为 挂载(mount)， 当组件被删除时，称之为卸载(unmount)  </p><p><code>componentDidMount()</code> 方法会在组件已经被渲染到 DOM 中后运行<br><code>componentWillUnmount() </code>方法会在组件在DOM删除之前 运行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      data:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">      <span class="built_in">this</span>.clockInterval = <span class="built_in">setInterval</span>(</span><br><span class="line">        ()=&gt;<span class="built_in">this</span>.clock(),</span><br><span class="line">        <span class="number">1000</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.clockInterval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clock()&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        data:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="built_in">this</span>.state.data.toLocaleTimeString()&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ClockComponent</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="State-注意事项"><a href="#State-注意事项" class="headerlink" title="State 注意事项"></a>State 注意事项</h3><p>不要直接修改<code>state</code>： this.state.xxx = ‘xxx’; 为错误方法<br>除了使用<code>this.setState()</code>传入新对象进行更新，构造函数是唯一可以给 <code>this.state</code> 赋值的地方</p><p><code>this.setState()</code>，该方法接收两个参数：对象或函数:</p><ul><li>对象：要修改的state的对象形式；</li><li>函数：接收2个函数：<br>第一个函数：参数为state和props，返回类型为一个对象，为state对象的形式<br>第二个函数：在state改变后触发的回调函数</li></ul><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><ul><li>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</li></ul><p>每当调用this.setState()时，不一定同步更新内部<code>state</code>，换句话说，<code>this.state()</code>可能不会立即执行 ,因此不会造成阻塞</p><blockquote><p>setState何时同步何时异步？</p><p>由React控制的事件处理函数:React封装的事件，比如onChange、onClick、onTouchMove等，以及生命周期函数调用setState()不会同步(立刻)更新state 。</p></blockquote><p>例如在点击按钮直接调用this.setState()的时候，React不会立即更新state中的内容，而是先渲染到页面上，延迟更新state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        data:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.click = <span class="built_in">this</span>.click.bind(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">click()&#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>:<span class="string">&#x27;b&#x27;</span>&#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.data); <span class="comment">// log -&gt; a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决显示改变的结果，则将函数传入setState()的第二个参数即可在改变<code>state</code>后执行函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click()&#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;</span><br><span class="line">    data:<span class="string">&#x27;b&#x27;</span></span><br><span class="line">    &#125;),<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.data); <span class="comment">// log -&gt; b </span></span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state，React的state的更新为浅合并，可以单独的更新(替换)指定的一个或者多个变量，而不需要提供整个state。</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><ul><li><p>React中不管是任何等级的组件，都无法知道其他组件的<code>state</code>，依靠<code>state</code>的局部封装特征  </p></li><li><p>父组件可以使用它的<code>state</code>作为一个子组件的行内<code>attribute</code> 向下 传递到子组件的<code>props</code>中，但是子组件无法得知传入的props数据是来自子组件的默认props值，还是来自于子组件的<code>state</code>、或者手动设置的<code>props</code>（从实验来看，<code>props</code>是只读对象）  </p></li><li><p>任何的 <code>state</code> 总是所属于特定的组件，而且从该 <code>state</code> 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React的时间均采用小驼峰式命名 camelCase 在JSX语法中 需要传入一个{}包裹的函数，而不是””包裹的字符串,且{}中可以为真值表达式、或者三目运算表达式  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>同样在回调函数中，使用参数e或者ev、event来访问事件对象    </p><p>在 JavaScript 中，class 的方法默认不会绑定 this。所有在class内部自定义的函数，都需要在构造器内部使用bind将this进行绑定<br>或者不使用这种绑定，在声明自定义函数的时候可将函数变为一个箭头函数，或者在绑定事件处，将未绑定的函数作为函数体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">onClickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//函数处理</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick = &#123;<span class="built_in">this</span>.onClickHandler&#125;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onClickHandler (e) &#123;</span><br><span class="line">  <span class="comment">//函数处理</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick = &#123; <span class="function">()=&gt;</span><span class="built_in">this</span>.onClickHandler() &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="向事件处理函数中传递参数"><a href="#向事件处理函数中传递参数" class="headerlink" title="向事件处理函数中传递参数"></a>向事件处理函数中传递参数</h3><p>通常在一些列表中需要为每一项的删除、修改等按钮  </p><p>在绑定事件时使用箭头函数，事件对象event必须显式传递  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick = &#123; <span class="function">(<span class="params">e</span>)=&gt;</span><span class="built_in">this</span>.onClickHandler(e, id) &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>在事件回调为箭头处理函数的时候，需要通过bind方式，事件对象会被隐式传递  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick = &#123;<span class="built_in">this</span>.onClickHandler.bind(<span class="built_in">this</span>, id) &#125;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>使用另一个函数组件通过使用if判断prop来进行渲染</p><ul><li>使用 与运算符 &amp;&amp;<br>在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。</li><li>使用 三目运算符</li></ul><h3 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h3><p>直接在函数组件内条件返回 null 或者class组件内的render()返回null则可阻止渲染，但是不影响组件的生命周期，只是渲染内容为空而已</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>列表渲染需要使用到Array.map()方法，可操作数组内部的每一个迭代的元素，并在最后返回一个新数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>); <span class="comment">//-&gt; 1 4 9 16 25</span></span><br></pre></td></tr></table></figure><p>React的渲染列表的规则则是在map中返回一个带有数据的模板数组，并且每个迭代的项目必须分配一个唯一的key属性<br>而且key属性是只写属性，不可读，只会传递给React，不会传递给组件，不能通过项目上的props进行访问，如果要标识每个迭代项，则需要另外使用属性进行代替，<br>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。 </p><blockquote><p>最将key设置为给的迭代的数据中的id，而不是map迭代的index，因为这样可能因为列表的顺序变化而使性能变差  </p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function">(<span class="params">number, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">index</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;number*2&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>); <span class="comment">//-&gt; 1 4 9 16 25</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;doubled&#125;&lt;/ul&gt;, </span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样，但是最好进行组件的提取</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    numbers.map(<span class="function">(<span class="params">number, index</span>) =&gt;</span> </span><br><span class="line">      &lt;li key=&#123;index&#125; index=&#123;index&#125;&gt;</span><br><span class="line">        &#123;number*<span class="number">2</span>&#125;</span><br><span class="line">      &lt;/li&gt;)</span><br><span class="line">   &#125;</span><br><span class="line">  &lt;/ul&gt;, </span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>元素的 key 只有放在就近的数组上下文中才有意义，换句话说，必须在数据的map方法中对迭代项目进行key属性的添加。</p><h3 id="key-只是在兄弟节点之间必须唯一"><a href="#key-只是在兄弟节点之间必须唯一" class="headerlink" title="key 只是在兄弟节点之间必须唯一"></a>key 只是在兄弟节点之间必须唯一</h3><p>不同的map方法中的key可以相同，不需要要全局唯一</p><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>React中的表单一般意味着表单的组件时有状态(state)组件，表单默认拥有默认行为——跳转页面，大多数情况下，使用监听组件标签的值，将其值使用函数设置在state中，这种表单组件称之为 受控组件 —— 表单的值被JS事件函数所控制，而不是被元素本身所控制，state为表单唯一数据源</p><h2 id="input-和-textarea"><a href="#input-和-textarea" class="headerlink" title="input 和 textarea"></a>input 和 textarea</h2><p>把setState作为唯一的数据源</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputHandler = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        inputVal:event.target.value,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;input value=&#123;<span class="built_in">this</span>.state.inputVal&#125; onInput=&#123;<span class="built_in">this</span>.InputHandler&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="select-以及-option"><a href="#select-以及-option" class="headerlink" title="select 以及 option"></a>select 以及 option</h2><p>React不会在option标签上使用selected来选择项，而是在跟select标签上使用value来设置默认值，在使用onChange事件监听选中的option的value来设置state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SelectHandler = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      selectFruit:event.target.value,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;select value=&#123;<span class="built_in">this</span>.state.selectFruit&#125; onChange=&#123;<span class="built_in">this</span>.SelectHandler&#125;&gt;</span><br><span class="line">    &lt;option disabled value=<span class="string">&quot;&quot;</span>&gt;--请选择--&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;apple&quot;</span>&gt;苹果&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;banana&quot;</span>&gt;香蕉&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;pear&quot;</span>&gt;梨&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;orange&quot;</span>&gt;橘子&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="文件input标签"><a href="#文件input标签" class="headerlink" title="文件input标签"></a>文件input标签</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="处理多个输入"><a href="#处理多个输入" class="headerlink" title="处理多个输入"></a>处理多个输入</h2><p>给每个input标签添加name属性来对获取的vale进行处理</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = target.value;</span><br><span class="line"><span class="keyword">const</span> name = target.name;</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="comment">//这里使用ES6动态属性名称进行更新</span></span><br><span class="line">  [name]: value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//等同 ES5:</span></span><br><span class="line"><span class="keyword">var</span> updateObj = &#123;&#125;;</span><br><span class="line">updateObj[name] = value;</span><br><span class="line"><span class="built_in">this</span>.setState(updateObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将input标签的value设置为null 或者undefined ，组件输入则不受控制</p><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><p>如果以个父组件内部的一个子组件的状态需要共享给另一个子组件，则可以将它们共同需要的状态提升到父组件的状态中，然后再从父组件中传递到子组件内，父组件作为数据的唯一源，掌握状态控制权，且子组件没有直接控制权，或者说子组件只能通过父组件向子组件传递的props中得到父组件的接口函数，进而调用父组件的某个状态（最好在子组件的自定义函数中调用props中传入的父组件回调）</p><h1 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h1><p>每个子组件中的props.children接收来自父组件插入到子组件标签的内容，在子组件内部使用{props.children}进行放置插入的内容，类似于Vue的插槽slot功能，或者可以在标签的prop中传递一个组件标签，然后再通过props访问</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件中</span></span><br><span class="line">&lt;ComponentA </span><br><span class="line">    &lt;h1&gt;内容&lt;/h1&gt;</span><br><span class="line">&lt;/ComponentA&gt;</span><br><span class="line"><span class="comment">//子组件ComponentA中</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&#123;props.children&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在React构建的应用中，几乎没有用到继承这一属性的组件，每个组件都可能被高度自定义；</p><p>如果要复用非UI的功能而使用继承，建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p><p>Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><h1 id="React-构建艺术"><a href="#React-构建艺术" class="headerlink" title="React 构建艺术"></a>React 构建艺术</h1><p>React最大的优点就是让我们思考如何科学的、规范的构建一个应用</p><ol><li>我们先要得到设计师的数据稿件，或者服务器后台工作者提供的JSON数据，依此作为组件和状态的规划</li><li>将设计好的UI划分为组件层级，PS图层中的图层名可以被参考为组件名，从而保持美工与程序的一致性<ul><li>使用单一功能的原则来判断组件包括的范围，一个组件只负责一个功能，而不对其他组件产生依赖</li><li>对展示组件内不同类型的数据样式做出决定  </li></ul></li><li>使用React创建一个规划好的静态页面，不需要使用state和prop</li><li>确定UI 组件 的state最小的表示(初始化组件需要的最小状态)，以及state放置的位置<ul><li>遵循<strong>一次且仅一次</strong>的原则</li><li>检查JSON判断数据是否属于当前组件的state<ul><li>该数据是否是从父级通过props传递过来？如果是，则不属于state</li><li>该数据是否随着时间的推移产生变化？如果是，则属于state</li><li>该数据是否可以通过props和state中的值计算得出？如果不是，则属于state</li></ul></li></ul></li><li>添加反向数据流，向下层传递函数，向上层传递state数据以调用setState</li></ol><h1 id="React高级"><a href="#React高级" class="headerlink" title="React高级"></a>React高级</h1><h2 id="React-lazy函数"><a href="#React-lazy函数" class="headerlink" title="React.lazy函数"></a>React.lazy函数</h2><p>使用React.lazy()函数动态引入一个外部组件</p><p>React.lazy()接收一个函数，这个函数要动态调用import()，而非这个函数返回的是Promise对象，该 Promise 需要 resolve 一个 <code>defalut</code> export 的 React 组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="Context-与-跨层传递数据"><a href="#Context-与-跨层传递数据" class="headerlink" title="Context 与 跨层传递数据"></a>Context 与 跨层传递数据</h2><p>context的目的是共享作用整个组件树的全局数据，能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。</p><p>在一般情况下，从父组件传递到孙组件需要通过中间组件来逐层传递，使用context我们可以避免传递经过中间组件多次prop</p><ul><li><p>Context 对象</p><p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从在组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure><blockquote><p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效</p></blockquote><ul><li><p>MyContext.Provider</p><p>使用根级别的Context广播提供者，对下层提供值为value的广播，下层组件需要使用contextType来指定Contex广播对象</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt; 放置被广播的组件 &lt;MyContext.Provider/&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p><p> Provider 接收一个 <code>value</code> 属性，传递给消费组件。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据</p><p> 当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p></blockquote><ul><li><p>Class.contextType</p><p>在类组件中，订阅一个Context 对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>将挂载在 class 上的 <code>contextType</code> 属性重新赋值一个Context对象，然后就可以使用this.context来访问最近的Context上的value值，而且可以在所有生命周期钩子和render()中访问它</p></blockquote><ul><li><p>Context.Consumer</p><p>在Context.Provider之下，返回使用value进行处理的react元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* 返回基于 context 值进行渲染的React元素*/</span>&#125;</span><br><span class="line">&lt;/MyContext.Consumer&gt;</span><br><span class="line"><span class="comment">// context默认值为一个对象，携带函数</span></span><br><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;<span class="function">(<span class="params">&#123;theme, toggleTheme&#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;button </span><br><span class="line">            onClick=&#123;toggleTheme&#125;</span><br><span class="line">            style=&#123;&#123;<span class="attr">backgroundColor</span>: theme.background&#125;&#125;&gt;</span><br><span class="line">            Toggle Theme</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 <code>value</code> 值等同于往上组件树离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p></blockquote><p>使用方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个React的context对象，参数为默认值</span></span><br><span class="line"><span class="keyword">const</span> Context = React.createContext(defaultData);</span><br><span class="line"><span class="comment">//在App根组件内使用&lt;ThemeContext.Provider /&gt; 标签包裹顶级作用组件，意思就是这个全局数据使用范围的上限</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Context.Provider 将当前的要传递的值 value 给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="comment">// 若将undefined 传入 value中，则不会使用defaultData作为默认值</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Context.Provider value=<span class="string">&quot;dark&quot;</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/Context.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下级组件中，访问Context来使用这个全局数据</span></span><br><span class="line"><span class="keyword">static</span> contextType = Context;</span><br><span class="line"><span class="keyword">let</span> value = <span class="built_in">this</span>.context</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意在使用Context之前需要思考使用是否合理，否则会造成数据域的混乱</p><h3 id="不使用Context进行跨层传递数据"><a href="#不使用Context进行跨层传递数据" class="headerlink" title="不使用Context进行跨层传递数据"></a>不使用Context进行跨层传递数据</h3><p>在根组件处，将最终需要的下级组件本身通过放入一个变量的形式通过prop传递下去，</p><p>这种变化下，只有最顶部的 Page 组件需要知道 <code>Link</code> 和 <code>Avatar</code> 组件是如何使用 <code>user</code> 和 <code>avatarSize</code> 的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Page根组件中，声明一个变量装入下级组件</span></span><br><span class="line"><span class="keyword">const</span> userLink = (</span><br><span class="line">    &lt;Link&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  );</span><br><span class="line"><span class="comment">//通过prop传递定义好的组件</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;userLink&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="通过向prop传递组件来渲染"><a href="#通过向prop传递组件来渲染" class="headerlink" title="通过向prop传递组件来渲染"></a>通过向prop传递组件来渲染</h3><p>这种方式可以有效的解除下级组件与上级组件的耦合</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="comment">//将子组件进行封装成react元素，这些元素可以使用当前组件的props和state</span></span><br><span class="line">  <span class="keyword">const</span> content = <span class="xml"><span class="tag">&lt;<span class="name">Feed</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">const</span> topBar = (</span><br><span class="line">    &lt;NavigationBar&gt;</span><br><span class="line">      &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">      &lt;/Link&gt;</span><br><span class="line">    &lt;/NavigationBar&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 通过props传递组件</span></span><br><span class="line">    &lt;PageLayout</span><br><span class="line">      topBar=&#123;topBar&#125;</span><br><span class="line">      content=&#123;content&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PageLayout</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &#123;props.topBar&#125;</span><br><span class="line">        &#123;props.content&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refs-和-DOM"><a href="#refs-和-DOM" class="headerlink" title="refs 和 DOM"></a>refs 和 DOM</h2><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p><p>由于不能直接得到原生DOM的对象 ，给标签加上 ref prop 并声明一个值可以使用””和{}，前者声明值，后者使用函数，在组件域中使用this.refs进行访问该DOM对象</p><h3 id="旧版本使用ref："><a href="#旧版本使用ref：" class="headerlink" title="旧版本使用ref："></a>旧版本使用ref：</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">this</span>.refs.input</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;input ref=<span class="string">&quot;input&quot;</span> /&gt;</span><br><span class="line">    &lt;input ref=&#123;js表达式/函数&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h3><ul><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库</li></ul><p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p><h3 id="新版本使用refs："><a href="#新版本使用refs：" class="headerlink" title="新版本使用refs："></a>新版本使用refs：</h3><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。</p><p>创建refs</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(prop)&#123;</span><br><span class="line"><span class="built_in">super</span>(prop)</span><br><span class="line">    <span class="built_in">this</span>.inputRef = React.createRef();</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;input ref=&#123;<span class="built_in">this</span>.inputRef&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问refs</p><ul><li><p>当 <code>ref</code> 属性用于 HTML 元素时，React.createRef()返回的对象中的current接收底层对应DOM元素的对象</p></li><li><p>当 <code>ref</code> 属性用于自定义 class 组件时，ref.current作为React组件实例对象</p></li><li><p>不能在函数组件的props中上使用ref，但是可以在函数组件内部使用ref</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(prop)&#123;</span><br><span class="line"><span class="built_in">super</span>(prop);</span><br><span class="line">    <span class="built_in">this</span>.inputRef = React.createRef();</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.inputRef.current); <span class="comment">//&lt;input /&gt;</span></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;input ref=&#123;<span class="built_in">this</span>.inputRef&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p><p>回调Refs</p><p>不使用<code>React.createRefs()</code>创建，将元素上的<code>ref</code>设置成一个回调函数，回调函数的内容是 <code>以React实例或者DOM元素</code>作为参数赋值给<code>constructor</code>中的变量，访问时，直接访问这个变量即可访问到对应DOM</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(prop)&#123;</span><br><span class="line"><span class="built_in">super</span>(prop)</span><br><span class="line">    <span class="built_in">this</span>.inputRef = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.setInputRef = <span class="function"><span class="params">elem</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.inputRef = elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.inputRef);  <span class="comment">// &lt;input  /&gt;</span></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;input ref=&#123;<span class="built_in">this</span>.setInputRef&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">elem</span> =&gt;</span><span class="built_in">this</span>.inputRef = elem&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="render-prop"><a href="#render-prop" class="headerlink" title="render prop"></a>render prop</h2><p>术语 <code>render prop</code>是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p><p>具有 render prop 的组件接受一个回调函数，该函数返回一个 React 元素并调用它而不是实现自己的渲染逻辑，换句话说，具有render prop的React组件只渲染render内部回调函数的内容</p><p>使用场景</p><ul><li>当某一封装的组件的功能要被其他几个组件复用且不改变封装的时候</li></ul><p>使用方法</p><ul><li><p>在作为复用的组件封装中，将render内部使用<code>&#123;this.props.render(this.state)&#125;</code>将封装组件中的数据传递给组件本身render prop中回调函数的参数中，使用回调函数内容渲染另一个组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="built_in">this</span>.props.mouse;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img src=<span class="string">&quot;/cat.jpg&quot;</span> style=&#123;&#123; <span class="attr">position</span>: <span class="string">&#x27;absolute&#x27;</span>, <span class="attr">left</span>: mouse.x, <span class="attr">top</span>: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleMouseMove = <span class="built_in">this</span>.handleMouseMove.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">height</span>: <span class="string">&#x27;100vh&#x27;</span> &#125;&#125; onMouseMove=&#123;<span class="built_in">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">        &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          使用render方法进行动态传递数据，传递给回调函数的参数</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.render(<span class="built_in">this</span>.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouseTracker</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;  </span><br><span class="line">        &lt;Mouse render=&#123;<span class="function"><span class="params">mouse</span> =&gt;</span> ( <span class="comment">// mouse就是封装组件传递过来的state，而这个mouse组件不会渲染自己的render，而是渲染Cat</span></span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="不一定要使用render这个prop-名字"><a href="#不一定要使用render这个prop-名字" class="headerlink" title="不一定要使用render这个prop 名字"></a>不一定要使用render这个prop 名字</h3><p>render prop 是因为模式才被称为 <em>render</em> prop ，你不一定要用名为 <code>render</code> 的 prop 来使用这种模式。</p><p><em>任何</em>被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”，即返回内容为react元素的函数，这种函数不一定要反正元素的attributes 中 ，还可以直接放在复用元素的内部</p><h2 id="高阶组件设计模式"><a href="#高阶组件设计模式" class="headerlink" title="高阶组件设计模式"></a>高阶组件设计模式</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p><strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p><p>当几个组件的更新数据模式都具有同样的行为时，使用 高阶组件 解决横切关注点问题</p><p>高阶函数组件接收2个参数，被包装的组件WrappedComponent，被包装的组件所需要的数据/处理方式selectData</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数接收一个组件... ，参数数量不限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent, selectData,...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个新组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">          <span class="comment">//切面组件拿到数据</span></span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//操作切面的事件，也是就是生成的组件的公共代码部分</span></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="comment">// ...负责订阅相关的操作...</span></span><br><span class="line">      DataSource.addChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//回调函数，监听数据变化，不同组件的数据源相同，但是可能传入的selectData进行更新data的操作不同</span></span><br><span class="line">    handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, <span class="built_in">this</span>.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// ... 并使用新数据渲染被包装的组件!</span></span><br><span class="line">      <span class="comment">// 请注意，我们可能还会传递其他属性</span></span><br><span class="line">      <span class="comment">//将公共方法处理的数据交给这个组件的data prop中，并传递其他prop</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高阶组件的最大用处在于，在几个组件需要请求公共数据的时候，把出现相同部分的操作以及对数据处理的不同的行为进行包装，只需要告知，不同操作的函数，类似工厂一样，生成一个新的组件</p><p>HOC 通过将组件<em>包装</em>在容器组件中来<em>组成</em>新组件。HOC 是纯函数，没有副作用。</p><p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 <code>data</code> prop。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。</p><h3 id="不要试图在-高阶组件模式-中修改组件原型（或以其他方式改变它）"><a href="#不要试图在-高阶组件模式-中修改组件原型（或以其他方式改变它）" class="headerlink" title="不要试图在 高阶组件模式 中修改组件原型（或以其他方式改变它）"></a>不要试图在 高阶组件模式 中修改组件原型（或以其他方式改变它）</h3><p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p><h2 id="深入JSX"><a href="#深入JSX" class="headerlink" title="深入JSX"></a>深入JSX</h2><p>prop的展开：</p><p>使用<code>...</code>形式展开的prop，可以由父级自定义通过props传入到组件内部标签的attributes中，且不受控制，不安全</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, ...other &#125; = props;  <span class="keyword">const</span> className = kind === <span class="string">&quot;primary&quot;</span> ? <span class="string">&quot;PrimaryButton&quot;</span> : <span class="string">&quot;SecondaryButton&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> &#123;<span class="attr">...other</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button kind=<span class="string">&quot;primary&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;clicked!&quot;</span>)&#125;&gt;</span><br><span class="line">        Hello World!</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React生命周期-同步"><a href="#React生命周期-同步" class="headerlink" title="React生命周期(同步)"></a>React生命周期(同步)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://upload-images.jianshu.io/upload_images/16775500-8d325f8093591c76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/740/format/webp" alt="img"></p><h3 id="从挂载到卸载"><a href="#从挂载到卸载" class="headerlink" title="从挂载到卸载"></a>从挂载到卸载</h3><ul><li><p>constructor()</p><p>constructor(props)中完成了对<code>props</code>和<code>state</code>的初始化，props的初始化是使用<code>prop-type</code>进行的，而<code>state</code>是在构造器内部初始化</p><p>必须在<code>constructor</code>中调用<code>super(props)</code>，否则会导致内部this指向错误</p></li><li><p>componentWillMount()</p><p>在组件进行挂载之前调用的钩子，一般在服务器中使用，<code>componentWillMount()</code>方法在<code>render()</code>方法之前被调用</p></li><li><p>componentDidMount()</p><p>React 的最佳实践是在生命周期方法<code>componentDidMount()</code>中对服务器进行 API 调用或任何其他调用。</p><p>在组件第一次渲染之后调用，此时DOM节点以及生成，通常在此处发送ajax请求，然后使用setState()进行更新数据</p></li><li><p>componentWillUnmount</p><p>在组件销毁之前调用，用于清除定时器，以及事件监听</p></li></ul><h3 id="更新循环"><a href="#更新循环" class="headerlink" title="更新循环"></a>更新循环</h3><ul><li><p>props被修改</p><ul><li><p>componentWillReceiveProps(nextProps)</p><p>在<code>props</code>发生修改时后调用，此时新的<code>props</code>为参数<code>nextProps</code>，而旧的<code>props</code>为<code>this.props</code>，一般<code>props</code>改变会触发<code>state</code>的改变。</p></li></ul></li><li><p>state被修改</p><ul><li><p>shouldComponentUpdate(nextProps,nextState)</p><p>得到最新的props和最新的state后，调用此钩子，此函数返回一个布尔值，<code>true</code>则进行重绘流程，<code>false</code>则不触发重绘，回到<code>running</code>状态</p></li></ul></li><li><p>componentWillUpdate(nextProps,nextState)</p><p>进入更新流程，此时<code>props</code>，<code>state</code>已经迭代，在重新渲染之前调用，任然可以获得新的<code>nextProps</code>与<code>nextState</code>进行操作</p></li><li><p>render()  使用新状态与Diff算法对组件部分进行重绘</p></li><li><p>componentDidUpdate(prevProps,prevState)</p><p>重绘之后调用的钩子，可访问到 旧的<code>prevProps</code>和<code>prevstate</code> </p></li></ul><h2 id="使用-amp-amp-获得更简洁的条件"><a href="#使用-amp-amp-获得更简洁的条件" class="headerlink" title="使用 &amp;&amp; 获得更简洁的条件"></a>使用 &amp;&amp; 获得更简洁的条件</h2><p>if/else 语句在上一次挑战中是有效的，但是有一种更简洁的方法可以达到同样的结果。假设你正在跟踪组件中的几个条件，并且希望根据这些条件中的每一个来渲染不同的元素。如果你写了很多<code>else if</code>语句来返回稍微不同的 UI，你可能会写很多重复代码，这就留下了出错的空间。相反，你可以使用<code>&amp;&amp;</code>逻辑运算符以更简洁的方式执行条件逻辑。这是完全可行的，因为你希望检查条件是否为真，如果为真，则返回一些标记。这里有一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;condition &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>markup<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">&#123;display &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Displayed!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; </span><br></pre></td></tr></table></figure><p>如果<code>condition</code>为 true，则返回标记。如果 condition 为 false，操作将在判断<code>condition</code>后立即返回<code>false</code>，并且不返回任何内容。你可以将这些语句直接包含在 JSX 中，并通过在每个条件后面写<code>&amp;&amp;</code>来将多个条件串在一起。这允许你在<code>render()</code>方法中处理更复杂的条件逻辑，而无需重复大量代码。</p><h2 id="用-renderToString-在服务器上渲染-React"><a href="#用-renderToString-在服务器上渲染-React" class="headerlink" title="用 renderToString 在服务器上渲染 React"></a>用 renderToString 在服务器上渲染 React</h2><p>到目前为止，你已经能够在客户端上渲染 React 组件，一般来说我们都是这么做的。然而，在一些用例中，在服务器上渲染一个 React 组件是有意义的。由于 React 是一个 JavaScript 视图库，所以使用 Node 让 JavaScript 运行在服务器上是可行的。事实上，React 提供了一个可用于此目的的<code>renderToString()</code>方法。</p><p>有两个关键原因可以解释为什么服务器上的渲染可能会在真实世界的应用程序中使用。</p><ul><li><p>首先，如果不这样做，你的 React 应用程序将包含一个代码量很少的 HTML 文件和一大堆 JavaScript，当它最初加载到浏览器时。这对于搜索引擎来说可能不太理想，因为它们试图为你的网页内容生成索引，以便人们可以找到你。</p></li><li><p>如果在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记。</p></li><li><p>其次，这创造了更快的初始页面加载体验，因为渲染的 HTML 代码量要比整个应用程序的 JavaScript 代码小。React 仍然能够识别你的应用并在初始加载后进行管理。</p></li><li><pre><code class="jsx">class App extends React.Component &#123;  constructor(props) &#123;    super(props);  &#125;  render() &#123;    return &lt;div/&gt;  &#125;&#125;;// change code below this lineReactDOMServer.renderToString(&lt;App /&gt;)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## React Hook</span><br><span class="line"></span><br><span class="line">在没有&#96;Hook&#96;之前，函数组件与class(类)组件的区别：</span><br><span class="line"></span><br><span class="line">* 类组件有&#96;this&#96; ，而函数组件没有&#96;this&#96;</span><br><span class="line">* 类组件拥有&#96;state&#96; ，而函数组件没有 state</span><br><span class="line">* 类组件有完整的生命周期，在创建时需要将其实例化，而函数组件没有声明周期，在执行完毕后返回结果，不用创建实例一个，所以函数组件的性能比类组件的性能好一些，应尽量使用函数组件</span><br><span class="line">* 在类组件每一次重新渲染时，会执行一遍 &#96;render()&#96; 内的代码，在函数式组件每一次重新渲染时，会重新执行一遍函数组件内的所有代码</span><br><span class="line"></span><br><span class="line">Hook 可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</span><br><span class="line"></span><br><span class="line">Hook在最新的 React中完全为可选，而且向后兼容</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;jsx</span><br><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个新的叫做 “count” 的 state 变量,setCount类似于setState</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="什么是Hook-？"><a href="#什么是Hook-？" class="headerlink" title="什么是Hook ？"></a>什么是Hook ？</h3><p>Hook是一些可以让你在函数组件中 钩入 React state和生命周期等类组件特性的函数，且Hook不能在类组件中使用,Hook 使用了 JavaScript 的闭包机制</p><h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h3><p>引入<code>&#123;useState&#125;</code>后，可以在函数组件中使用<code>const</code>声明一组<code>state</code>变量 <code>count</code> 和 <code>setCount </code> </p><p><code>useState()</code>会返回一个数组，使用这个2个变量进行数组解构赋值，<code>useState()</code>内部的参数为这个<code>state</code>变量的<em>初始值</em></p><p>React 会在重复渲染时保留这个 <code>state</code> ,但是它不会把新的 <code>state</code> 和旧的 <code>state</code> 进行合并。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>); <span class="comment">//useState的内部参数为count的初始值</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，在一个组件中多次使用<code>State Hook</code>可以声明多个<code>state</code>变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">&#x27;React&#x27;</span>); </span><br><span class="line">    <span class="keyword">const</span> [age,setAge] = userState(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h3><p>在React组件一般在生命周期钩子中执行：</p><ul><li>数据获取(发送ajax请求)</li><li>订阅消息(使用第三方库进行状态更新)</li><li>手动修改DOM对象(使用refs修改获得的DOM)</li></ul><p>这些操作被统一成为副作用操作</p><p>useEffect 就是一个 Effect Hook ，为函数组件增加了 <strong>进行副作用操作</strong> 的能力，它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 3个生命周期钩子具有相同的用途，但是被合成到了一个useEffect()中，参数为一个函数，React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。</p><p><code>useEffect(()=&gt;&#123;..&#125;)</code>的回调函数可访问组件的 props state，在函数组件挂载之后，props state更新之后，函数组件卸载之前，都会调用useEffect()，执行传入的函数</p><h4 id="无需清除的Effect"><a href="#无需清除的Effect" class="headerlink" title="无需清除的Effect"></a>无需清除的Effect</h4><p>我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。在class组件中，我们需要在挂载后和更新后的钩子中写相同的代码，而Hook只书写一次</p><p><code>useEffect</code> 调度的 effect 不会阻塞浏览器更新屏幕</p><h4 id="需要清除的-Effect"><a href="#需要清除的-Effect" class="headerlink" title="需要清除的 Effect"></a>需要清除的 Effect</h4><p>在<code>Effect</code>中订阅数据只需要一次，这可以防止内存泄露，在class组件中，我们能使用3个生命周期钩子很好的进行订阅、更新和取消订阅</p><p>在<code>Effect</code>中，在回调函数中进行返回一个<strong>清除函数</strong>，对应class组件中的<code>componentWillUnmount()</code> </p><p><strong>React 会等待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code></strong></p><p><strong>React 会在组件卸载的时候执行清除函数</strong></p><p>函数组件每次更新时，都会先卸载，然后再挂载，意味着每次更新都会调用一次setEffect中的内容然后进行state变量更新，从而循环监听，如果不将上次的订阅取消，那么每次的监听都会被保留在内存中，造成内存泄露，所以必须在每次卸载之前，将上一次的订阅取消</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//这个函数一直在被调用，如果没有变动则没次set的值都相同</span></span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个订阅会在每次更新时都进行一次订阅，相当于监听</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="comment">// 清除上一次的订阅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;<span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？"><a href="#那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？" class="headerlink" title="那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？"></a>那么为什么要使用函数组件在每次更新后运行useEffect的回调呢？</h4><p>如果在class组件中，在组件被挂载之后的<code>componentDidMount()</code>中进行<strong>数据订阅</strong>操作，这个时候组件本身的一个prop作为一个订阅的参数，进行订阅。</p><ul><li>在不使用 <code>componentDidUpdate()</code>的情况下，当这个作为参数的prop被更新时，此时数据订阅的参数没有被更新，导致还是以原来的参数在进行订阅，</li><li>在使用<code>componentDidUpdate()</code>情况下，还要在最开始取消上一次的更新，后再次进行一次相同代码的订阅，导致代码重复2次</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">    <span class="built_in">this</span>.props.friend.id,   <span class="comment">//当组件props更新时，这个参数没有被更新</span></span><br><span class="line">    <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="comment">// 取消订阅之前的 friend.id</span></span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      prevProps.friend.id,</span><br><span class="line">      <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//当组件props更新时，只能通过componentDidUpdate()来重复调用订阅，这样造成了代码重复</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">    <span class="built_in">this</span>.props.friend.id,   </span><br><span class="line">    <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">    <span class="built_in">this</span>.props.friend.id,</span><br><span class="line">    <span class="built_in">this</span>.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用Effect Hook，不同，在挂载的时候，就会调用一次订阅，并且随着数据的更新，他会不断的通过卸载时清除effect和挂载时重新调用订阅，保证数据以规定的节奏处于最新状态，但是这会造成一个性能问题：<strong>即使数据没有改变，也会不断的进行监听以及进行挂载和卸载</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对Effect-进行性能优化，解决Effect性能问题"><a href="#对Effect-进行性能优化，解决Effect性能问题" class="headerlink" title="对Effect 进行性能优化，解决Effect性能问题"></a>对Effect 进行性能优化，解决Effect性能问题</h3><p>在class组件中，<code>componentDidUpdate()</code>可以使用<code>prevProps</code>和<code>prevState</code>与新的状态进行比较，来决定是否要进行<strong>取消之前的订阅</strong>和<strong>调用新的订阅</strong></p><p>在使用Effect Hook中，只要在<code>useState()</code>中传递一个数组作为第二个参数（数组中的元素则为进行差异对比的state变量），则可以在两次渲染都没有差别的时候，跳过对effect的回调函数的调用，目前第二个参数<strong>必须</strong>要手动添加</p><ul><li><p>以传入[count]为例：</p><p>如果<code>count</code>当前的值是<code>5</code>，当<code>count</code>接收到一个新值的时候，这个函数组件会启动重新渲染(卸载后挂载)，此时的渲染的<code>count</code>会与上一次渲染的<code>count</code>进行对比，如果这个2个数组 (前面提到的传入的数组) 中的所有元素都相同，即<code>[5 === 5]</code>，则React会跳过执行useEffect()的回调函数，实现了性能优化</p></li><li><p>值得注意的是：</p><ul><li>使用Effect的优化，必须确保数组中包含了所有外部作用域中的变量，这些变量必须是在<code>useEffect()</code>回调中直接、间接影响内部的state变量的变量，否则你的代码会引用到先前渲染中的旧state变量</li></ul></li><li><p>如果指向执行一次effect，可以向第二个参数传递一个空数组<code>[]</code>，告诉React不依赖于任何props和state，永远不需要重复执行</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;,[count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;<span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个订阅会在每次更新时都进行一次订阅，相当于监听</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 清除上一次的订阅</span></span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,[props.friend.id]);<span class="comment">//对比新旧props.friend.id，在props.friend.id没有发生改变的时候，跳过执行回调函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h4><h4 id="Effect-Hook总结"><a href="#Effect-Hook总结" class="headerlink" title="Effect Hook总结"></a>Effect Hook总结</h4><p>effect hook 引入 函数组件 ，使得函数组件拥有了类似于class的生命周期钩子，只不过是将挂载后，更新后，卸载前的钩子进行了一个集中处理，简单的来说，effect hook 处理了这么一个流程：</p><ul><li><code>useEffect()</code>的回调函数在被渲染好后，挂载时，触发了一次回调函数</li><li>当遇到状态更新时，在使用新、旧两个数据渲染后进行差异对比，决定是否跳过<code>useEffect()</code>的回调函数，从而决定是否重新渲染</li><li>在进行重新渲染时，在当前组件卸载之前，对回调内的监听、订阅等影响后续数据的操作进行清除</li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="Redux：创建一个-Redux-Store"><a href="#Redux：创建一个-Redux-Store" class="headerlink" title="Redux：创建一个 Redux Store"></a>Redux：创建一个 Redux Store</h2><p>Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。</p><p>在 Redux 中，有一个状态对象负责应用程序的整个状态，这意味着如果你有一个包含十个组件且每个组件都有自己的本地状态的 React 项目，那么这个项目的整个状态将通过 Redux<code>store</code>被定义为单个状态对象，这是学习 Redux 时要理解的第一个重要原则：Redux store 是应用程序状态的唯一真实来源。</p><p>这也意味着，如果你的应用程序想要更新状态，只能通过 Redux store 执行，单向数据流可以更轻松地对应用程序中的状态进行监测管理。</p><p>Redux <code>store</code>是一个保存和管理应用程序状态的<code>state</code>，你可以使用 Redux 对象中的<code>createStore()</code>来创建一个 redux<code>store</code>，此方法将<code>reducer</code>函数作为必需参数，<code>reducer</code>函数将在后面的挑战中介绍。该函数已在代码编辑器中为你定义，它只需将<code>state</code>作为参数并返回一个<code>state</code>即可。</p><h2 id="Redux：从-Redux-Store-获取状态"><a href="#Redux：从-Redux-Store-获取状态" class="headerlink" title="Redux：从 Redux Store 获取状态"></a>Redux：从 Redux Store 获取状态</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = Redux.createStore(</span><br><span class="line">  (state = <span class="number">5</span>) =&gt; state</span><br><span class="line">);</span><br><span class="line"><span class="keyword">let</span> currentState = store.getState()</span><br></pre></td></tr></table></figure><h2 id="定义一个-Redux-Action"><a href="#定义一个-Redux-Action" class="headerlink" title="定义一个 Redux Action"></a>定义一个 Redux Action</h2><p>由于 Redux 是一个状态管理框架，因此更新状态是其核心任务之一。在 Redux 中，所有状态更新都由 dispatch action 触发，action 只是一个 JavaScript 对象，其中包含有关已发生的 action 事件的信息。Redux store 接收这些 action 对象，然后更新相应的状态。有时，Redux action 也会携带一些数据。例如，在用户登录后携带用户名，虽然数据是可选的，但 action 必须带有<code>type</code>属性，该属性表示此 action 的类型。</p><p>我们可以将 Redux action 视为信使，将有关应用程序中发生的事件信息提供给 Redux store，然后 store 根据发生的 action 进行状态的更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type:<span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个-Action-Creator"><a href="#定义一个-Action-Creator" class="headerlink" title="定义一个 Action Creator"></a>定义一个 Action Creator</h2><p>创建 action 后要将 action 发送到 Redux store，以便它可以更新其状态。在 Redux 中，你可以定义动作创建器来完成此任务，action creator 只是一个返回动作的 JavaScript 函数，换句话说，action creator 创建表示动作事件的对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">actionCreator</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分发-Action-Event"><a href="#分发-Action-Event" class="headerlink" title="分发 Action Event"></a>分发 Action Event</h2><p><code>dispatch</code>方法用于将 action 分派给 Redux store，调用<code>store.dispatch()</code>将从 action creator 返回的值发送回 store。</p><p>action creator 返回一个具有 type 属性的对象，该属性指定已发生的 action，然后，该方法将 action 对象 dispatch 到 Redux store</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = Redux.createStore(</span><br><span class="line">  (state = &#123;<span class="attr">login</span>: <span class="literal">false</span>&#125;) =&gt; state</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loginAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">store.dispatch(loginAction())</span><br></pre></td></tr></table></figure><h2 id="Redux：在-Store-里处理-Action"><a href="#Redux：在-Store-里处理-Action" class="headerlink" title="Redux：在 Store 里处理 Action"></a>Redux：在 Store 里处理 Action</h2><p>在一个 action 被创建并 dispatch 之后，Redux store 需要知道如何响应该操作。这就是<code>reducer</code>函数存在的意义。</p><ul><li>Redux 中的 Reducers 负责响应 action 然后进行状态的修改。<code>reducer</code>将<code>state</code>和<code>action</code>作为参数，并且它总是返回一个新的<code>state</code>。</li><li>我们要知道这是 reducer 的<strong>唯一</strong>的作用。它不应有任何其他的作用：比如它不应调用 API 接口，也不应存在任何潜在的副作用。</li><li>reducer 只是一个接受状态和动作，然后返回新状态的纯函数。</li><li>Redux 的另一个关键原则是<code>state</code>是只读的。换句话说，<code>reducer</code>函数必须<strong>始终</strong>返回一个新的<code>state</code>，并且永远不会直接修改状态。Redux 不强制改变状态，但是你需要在你的 reducer 函数的代码中强制执行它，</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  login: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">&quot;LOGIN&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      login:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(reducer);</span><br><span class="line"><span class="keyword">const</span> loginAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Redux：使用-Switch-语句处理多个-Actions"><a href="#Redux：使用-Switch-语句处理多个-Actions" class="headerlink" title="Redux：使用 Switch 语句处理多个 Actions"></a>Redux：使用 Switch 语句处理多个 Actions</h2><p>你可以定义 Redux store 如何处理多种 action 类型。比如你正在 Redux store 中进行用户身份验证，如果你希望用户在登录和注销时具有状态的响应，你可以使用具有<code>authenticated</code>属性的单个的 state 对象。你还需要使用 action creators 创建与用户登录和用户注销相对应的 action，以及 action 对象本身。</p><p>代码编辑器为你创建了 store、actions、action creators。通过编写<code>reducer</code>函数来处理多个身份验证操作。可以在<code>reducer</code>通过使用 JavaScript 的<code>switch</code>来响应不同的 action 事件。这是编写 Redux reducer 时的标准模式，switch 语句选择<code>action.type</code>中的一个值并返回相应的身份验证状态。</p><p><strong>注意：</strong> 此时，不要担心 state 的不变性，因为在这个示例中它很小而且很简单。所以对于每个操作你都可以返回一个新对象，比如<code>&#123;authenticated:true&#125;</code>。另外，不要忘记在 switch 语句中写一个<code>default</code>case，返回当前的<code>state</code>。这是很重要的，因为一旦你的程序有多个 reducer，当一个 action 被 dispatch 时它们都会运行，即使 action 与该 reducer 无关。在这种情况下，你要确保返回当前的<code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  authenticated: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> authReducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;LOGIN&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;LOGOUT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: state.authenticated</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(authReducer);</span><br><span class="line"><span class="keyword">const</span> loginUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logoutUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;LOGOUT&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-const-声明-Action-Types"><a href="#使用-const-声明-Action-Types" class="headerlink" title="使用 const 声明 Action Types"></a>使用 const 声明 Action Types</h2><p>在使用 Redux 时的一个常见做法是将操作类型指定为只读，然后在任何使用它们的地方引用这些常量。你可以通过将 action types 使用<code>const</code>声明重构你正在使用的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LOGIN = <span class="string">&#x27;LOGIN&#x27;</span></span><br><span class="line"><span class="keyword">const</span> LOGOUT = <span class="string">&#x27;LOGOUT&#x27;</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  authenticated: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> authReducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOGIN:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> LOGOUT:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(authReducer);</span><br><span class="line"><span class="keyword">const</span> loginUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: LOGIN</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> logoutUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: LOGOUT</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redux：注册-Store-监听器"><a href="#Redux：注册-Store-监听器" class="headerlink" title="Redux：注册 Store 监听器"></a>Redux：注册 Store 监听器</h2><p>在 Redux <code>store</code>对象上访问数据的另一种方法是<code>store.subscribe()</code>。这允许你将监听器函数订阅到 store，只要一个 action 被 dispatch 就会调用它们。这个方法的一个简单用途是为你的 store 订阅一个函数，它只是在每次收到一个 action 并且更新 store 时记录一条消息。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(&#123;reducer&#125;);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">store.subscribe(<span class="function">()=&gt;</span>&#123;   <span class="comment">// dispatch被调用，就会触发一次subscribe内的回调函数</span></span><br><span class="line">  count ++</span><br><span class="line">&#125;)</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>: ADD&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>: ADD&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>: ADD&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(count);</span><br></pre></td></tr></table></figure><h2 id="Redux：组合多个-Reduces"><a href="#Redux：组合多个-Reduces" class="headerlink" title="Redux：组合多个 Reduces"></a>Redux：组合多个 Reduces</h2><p>应用程序的状态开始变得越来越复杂时，将状态划分为多个部分可能是个更好的选择。Redux 的第一个原则：所有应用程序状态都保存在 store 中的一个简单的 state 对象中。因此，Redux 提供 reducer 组合作为复杂状态模型的解决方案。定义多个 reducer 来处理应用程序状态的不同部分，然后将这些 reducer 组合成一个 root reducer。然后将 root reducer 传递给 Redux <code>createStore()</code>方法。</p><p>Redux 提供了<code>combineReducers()</code>方法。该方法接受一个对象作为参数，在该参数中定义一个将键与特定 reducer 函数关联的属性。Redux 将使用你给的键值作为关联状态的名称。</p><p>通常情况下，当它们在某种程度上是独一无二的，最好为每个 state 创建一个<code>reducer</code>例如，在一个带有用户身份验证的reactApp，一个 reducer 可以处理身份验证而另一个处理用户提交的文本和注释。对于这样的应用程序，我们可能会编写<code>combineReducers()</code>方法，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = Redux.combineReducers(&#123;</span><br><span class="line"> auth: authenticationReducer,</span><br><span class="line"> notes: notesReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> LOGIN = <span class="string">&#x27;LOGIN&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> LOGOUT = <span class="string">&#x27;LOGOUT&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> authReducer = <span class="function">(<span class="params">state = &#123;authenticated: <span class="literal">false</span>&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LOGIN:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> LOGOUT:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        authenticated: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rootReducer = Redux.combineReducers(&#123;</span><br><span class="line">  count: counterReducer,</span><br><span class="line">  auth: authReducer</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(rootReducer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发送-Action-Data-给-Store"><a href="#发送-Action-Data-给-Store" class="headerlink" title="发送 Action Data 给 Store"></a>发送 Action Data 给 Store</h2><p>到目前为止，你已经学会了如何将 action dispatch 给 Redux store，但到目前为止，这些 action 并未包含除 <code>type</code>之外的任何信息。你还可以发送特定数据和 action 一起。事实上，这是非常常见的，因为 action 通常源于一些用户交互，并且往往会携带一些数据，Redux store 经常需要知道这些数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_NOTE = <span class="string">&#x27;ADD_NOTE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> notesReducer = <span class="function">(<span class="params">state = <span class="string">&#x27;Initial State&#x27;</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_NOTE:</span><br><span class="line">      <span class="keyword">return</span> action.text</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> addNoteText = <span class="function">(<span class="params">note</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_NOTE,</span><br><span class="line">    text: note</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(notesReducer);</span><br><span class="line"><span class="built_in">console</span>.log(store.getState());</span><br><span class="line">store.dispatch(addNoteText(<span class="string">&#x27;Hello!&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(store.getState());</span><br></pre></td></tr></table></figure><h2 id="Redux：使用中间件处理异步操作"><a href="#Redux：使用中间件处理异步操作" class="headerlink" title="Redux：使用中间件处理异步操作"></a>Redux：使用中间件处理异步操作</h2><p>Redux Thunk 中间件，专门处理异步操作，例如发送ajax请求，这将会编写一个异步action，其返回一个参数为dispatch的函数，在异步action中调用同步action，进行状态更新，目前推荐使用ES8新增的 async函数配合await等待Promise 来作为异步action返回的函数</p><p>如果要使用 Redux Thunk 中间件，请将其作为参数传递给<code>Redux.applyMiddleware()</code>。然后将此函数作为第二个可选参数提供给<code>createStore()</code>函数，看一下编辑器底部的代码，然后，要创建一个异步的 action，你需要在 action creator 中返回一个以<code>dispatch</code>为参数的函数。在这个函数中，你可以 dispatch action 并执行异步请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REQUESTING_DATA = <span class="string">&#x27;REQUESTING_DATA&#x27;</span></span><br><span class="line"><span class="keyword">const</span> RECEIVED_DATA = <span class="string">&#x27;RECEIVED_DATA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestingData = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> &#123;<span class="attr">type</span>: REQUESTING_DATA&#125; &#125;</span><br><span class="line"><span class="keyword">const</span> receivedData = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="keyword">return</span> &#123;<span class="attr">type</span>: RECEIVED_DATA, <span class="attr">users</span>: data.users&#125; &#125;</span><br><span class="line"><span class="keyword">const</span> handleAsync = <span class="function">() =&gt;</span> &#123;<span class="comment">// 异步操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里 dispatch 请求的 action</span></span><br><span class="line">    dispatch(requestingData())</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> data = &#123;</span><br><span class="line">        users: [<span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在这里 dispatch 接收到的数据 action</span></span><br><span class="line">    dispatch(receivedData(data))  </span><br><span class="line">    &#125;, <span class="number">2500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  fetching: <span class="literal">false</span>,</span><br><span class="line">  users: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> asyncDataReducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> REQUESTING_DATA:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        fetching: <span class="literal">true</span>,</span><br><span class="line">        users: []</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> RECEIVED_DATA:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        fetching: <span class="literal">false</span>,</span><br><span class="line">        users: action.users</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(</span><br><span class="line">  asyncDataReducer,</span><br><span class="line">  Redux.applyMiddleware(ReduxThunk.default)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Redux：用-Redux-写一个计数器"><a href="#Redux：用-Redux-写一个计数器" class="headerlink" title="Redux：用 Redux 写一个计数器"></a>Redux：用 Redux 写一个计数器</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">&#x27;INCREMENT&#x27;</span>; <span class="comment">// 为增量 action 类型定义一个常量</span></span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">&#x27;DECREMENT&#x27;</span>; <span class="comment">// 为减量 action 类型定义一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125; </span><br><span class="line">&#125;; <span class="comment">// 定义计数器，它将根据收到的action增加或减少状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> incAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type:INCREMENT</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// 定义一个用于递增的 action creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type:DECREMENT</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 定义一个用于递减的 action creator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(counterReducer); <span class="comment">// 在这里定义一个 Redux store，传递你的 reducer</span></span><br></pre></td></tr></table></figure><h2 id="Redux：永不改变状态"><a href="#Redux：永不改变状态" class="headerlink" title="Redux：永不改变状态"></a>Redux：永不改变状态</h2><p>Redux不可变状态意味着你永远不会直接修改状态，而是返回一个新的状态的副本，其底层原理是React会使用Diff算法比较新旧状态之间的差异，因此更新不能丢失旧的状态</p><p>利用数组或者对象的特征，直接返回基于上一次的state的一个副本，而不是重新将state赋予一个新的地址</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TO_DO = <span class="string">&#x27;ADD_TO_DO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">  <span class="string">&#x27;Go to the store&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Clean the house&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Cook dinner&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Learn to code&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> immutableReducer = <span class="function">(<span class="params">state = todos, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TO_DO:</span><br><span class="line">      <span class="keyword">return</span> state.concat(action.todo) <span class="comment">// 返回一个测试副本</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addToDo = <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TO_DO,</span><br><span class="line">    todo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(immutableReducer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redux：从数组中删除项目"><a href="#Redux：从数组中删除项目" class="headerlink" title="Redux：从数组中删除项目"></a>Redux：从数组中删除项目</h2><p>是时候练习从数组中删除项目了。扩展运算符也可以在这里使用。其他有用的JavaScript方法包括<code>slice()</code>和<code>concat()</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> immutableReducer = <span class="function">(<span class="params">state = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;REMOVE_ITEM&#x27;</span>:</span><br><span class="line">      <span class="comment">// 此处不能使用splice，因为会改变原数组</span></span><br><span class="line">      <span class="keyword">return</span> [...state].slice(<span class="number">0</span>,action.index).concat([...state].slice(action.index +<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> removeItem = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;REMOVE_ITEM&#x27;</span>,</span><br><span class="line">    index</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(immutableReducer);</span><br></pre></td></tr></table></figure><h2 id="Redux：使用-Object-assign-合并对象"><a href="#Redux：使用-Object-assign-合并对象" class="headerlink" title="Redux：使用 Object.assign 合并对象"></a>Redux：使用 Object.assign 合并对象</h2><p>最后几个挑战适用于数组，但是当状态是<code>object</code>时，有一些方法可以帮助强制执行状态不变性。处理对象的一个方法是<code>Object.assign()</code>。<code>Object.assign()</code>获取目标对象和源对象，并将源对象中的属性映射到目标对象。任何匹配的属性都会被源对象中的属性覆盖。通常用于通过传递一个空对象作为第一个参数，然后是要用复制的对象来制作对象的浅表副本。这是一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObject = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure><p>这会创建<code>newObject</code>作为新的<code>object</code>，其中包含<code>obj1</code>和<code>obj2</code>中当前存在的属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  user: <span class="string">&#x27;CamperBot&#x27;</span>,</span><br><span class="line">  status: <span class="string">&#x27;offline&#x27;</span>,</span><br><span class="line">  friends: <span class="string">&#x27;732,982&#x27;</span>,</span><br><span class="line">  community: <span class="string">&#x27;freeCodeCamp&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> immutableReducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ONLINE&#x27;</span>:</span><br><span class="line">      <span class="comment">// 使用Object.assign 从最后一个参数到第二个参数来合并一个对象，并生成一个新的浅拷贝对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;<span class="attr">status</span>: <span class="string">&#x27;online&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> wakeUp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;ONLINE&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(immutableReducer);</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：首先在本地管理状态"><a href="#React-和-Redux：首先在本地管理状态" class="headerlink" title="React 和 Redux：首先在本地管理状态"></a>React 和 Redux：首先在本地管理状态</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayMessages</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      input: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      messages: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.submitMessage = <span class="built_in">this</span>.submitMessage.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event)&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        input:event.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  submitMessage()&#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        input:<span class="string">&#x27;&#x27;</span>, </span><br><span class="line">        messages: <span class="built_in">this</span>.state.messages.concat(<span class="built_in">this</span>.state.input)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;input, messages&#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> msg = messages.map(<span class="function">(<span class="params">item,idx</span>) =&gt;</span> ( <span class="comment">// 注意添加key</span></span><br><span class="line">      &lt;li key=&#123;idx&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;键入新 Message&lt;/h2&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="built_in">this</span>.handleChange&#125; value=&#123;input&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.submitMessage&#125;&gt;Add message&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;msg&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：提取状态逻辑给-Redux"><a href="#React-和-Redux：提取状态逻辑给-Redux" class="headerlink" title="React 和 Redux：提取状态逻辑给 Redux"></a>React 和 Redux：提取状态逻辑给 Redux</h2><p>完成 React 组件后，我们需要把在本地<code>状态</code>执行的逻辑移到 Redux 中，这是为小规模 React 应用添加 Redux 的第一步。该应用的唯一功能是把用户的新消息添加到无序列表中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line"><span class="keyword">const</span> messages = []</span><br><span class="line"><span class="keyword">const</span> messageReducer = <span class="function">(<span class="params">state = messages,action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> ADD :</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.message</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    type:ADD,</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(messageReducer)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：使用-Provider-连接-Redux-和-React"><a href="#React-和-Redux：使用-Provider-连接-Redux-和-React" class="headerlink" title="React 和 Redux：使用 Provider 连接 Redux 和 React"></a>React 和 Redux：使用 Provider 连接 Redux 和 React</h2><p>在上一挑战中，你创建了 Redux store 和 action，分别用于处理消息数组和添加新消息。下一步要为 React 提供访问 Redux store 及发起更新所需的 actions。<code>react-redux</code>包可帮助我们完成这些任务。</p><p>React Redux 提供的 API 有两个关键的功能：<code>Provider</code>和<code>connect</code>，<code>Provider</code>是 React Redux 包装 React 应用的 wrapper 组件，它允许你访问整个组件树中的 Redux<code>store</code>及<code>dispatch（分发）</code>方法。<code>Provider</code>需要两个 props：Redux store 和 APP 应用的子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line"> &lt;App/&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux 代码：</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.message</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(messageReducer);</span><br><span class="line"><span class="comment">// React 代码：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayMessages</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      input: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      messages: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.submitMessage = <span class="built_in">this</span>.submitMessage.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      input: event.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  submitMessage() &#123;</span><br><span class="line">    <span class="keyword">const</span> currentMessage = <span class="built_in">this</span>.state.input;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      input: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      messages: <span class="built_in">this</span>.state.messages.concat(currentMessage)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;Type <span class="keyword">in</span> a <span class="keyword">new</span> Message:&lt;/h2&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.input&#125;</span><br><span class="line">          onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.submitMessage&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.state.messages.map( <span class="function">(<span class="params">message, idx</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                 &lt;li key=&#123;idx&#125;&gt;&#123;message&#125;&lt;/li&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Provider = ReactRedux.Provider;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在此渲染 Provider</span></span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;DisplayMessages /&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 请在本行以上添加你的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：映射-State-到-Props"><a href="#React-和-Redux：映射-State-到-Props" class="headerlink" title="React 和 Redux：映射 State 到 Props"></a>React 和 Redux：映射 State 到 Props</h2><p><code>Provider</code>可向 React 组件提供<code>state</code>和<code>dispatch</code>，但你必须确切地指定所需要的 state 和 actions，以确保每个组件只能访问所需的 state。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写getter函数，将state以对象的值的形式返回给Provider组件</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> ()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    messages:state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：映射-Dispatch-到-Props"><a href="#React-和-Redux：映射-Dispatch-到-Props" class="headerlink" title="React 和 Redux：映射 Dispatch 到 Props"></a>React 和 Redux：映射 Dispatch 到 Props</h2><p><code>mapDispatchToProps()</code>函数可为 React 组件提供特定的创建 action 的函数，以便组件可 dispatch actions，从而更改 Redux store 中的数据。它返回一个对象，把 dispatch actions 映射到属性名上，该属性名成为<code>props</code>。然而，每个属性都返回一个用 action creator 及与 action 相关的所有数据调用<code>dispatch</code>的函数，而不是返回<code>state</code>的一部分。你可以访问<code>dispatch</code>，因为在定义函数时，我们以参数形式把它传入<code>mapDispatchToProps()</code>了，这跟<code>state</code>传入<code>mapDispatchToProps()</code>是一样的。在幕后，React Redux 用 Redux 的<code>store.dispatch()</code>来管理这些含<code>mapDispatchToProps()</code>的dispatches，这跟它使用<code>store.subscribe()</code>来订阅映射到<code>state</code>的组件的方式类似。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">&#x27;ADD&#x27;</span>,</span><br><span class="line">    message: message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将return中的函数映射到组件的props中，在组件的props中就可以访问这些函数，来调用相应的dispatch</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        submitNewMessage: <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            dispatch(addMessage(message))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：连接-Redux-和-React"><a href="#React-和-Redux：连接-Redux-和-React" class="headerlink" title="React 和 Redux：连接 Redux 和 React"></a>React 和 Redux：连接 Redux 和 React</h2><p>既然写了<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个函数，现在你可以用它们来把<code>state</code>和<code>dispatch</code>映射到 React 组件的<code>props</code>了。React Redux 的<code>connect</code>方法可以完成这个任务。此方法有<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个可选参数，它们是可选的，原因是你的组件可能仅需要访问<code>状态</code>但不需要分发任何 actions，反之亦然。</p><p>为了使用此方法，需要传入函数参数并在调用时传入组件。这种语法有些不寻常，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect返回一个新常量，这个常量就是已经连接Redux的Component组件副本</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Component)</span><br><span class="line"><span class="comment">// 或者在组件中直接暴露一个连接后的组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  state =&gt; (&#123;</span><br><span class="line">    user: state.user,</span><br><span class="line">    chat: state.chat</span><br><span class="line">  &#125;),</span><br><span class="line">  &#123; sendMessage, hasReadMessage &#125;</span><br><span class="line">)(Chat)</span><br></pre></td></tr></table></figure><h2 id="React-和-Redux：将局部状态提取到-Redux-中"><a href="#React-和-Redux：将局部状态提取到-Redux-中" class="headerlink" title="React 和 Redux：将局部状态提取到 Redux 中"></a>React 和 Redux：将局部状态提取到 Redux 中</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux:</span></span><br><span class="line"><span class="keyword">const</span> ADD = <span class="string">&#x27;ADD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD,</span><br><span class="line">    message: message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        action.message</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = Redux.createStore(messageReducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React:</span></span><br><span class="line"><span class="keyword">const</span> Provider = ReactRedux.Provider;</span><br><span class="line"><span class="keyword">const</span> connect = ReactRedux.connect;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在本行以下添加你的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Presentational</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      input: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.submitMessage = <span class="built_in">this</span>.submitMessage.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      input: event.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  submitMessage() &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.submitNewMessage(<span class="built_in">this</span>.state.input)</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      input: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> messages = <span class="built_in">this</span>.props.messages.map( <span class="function">(<span class="params">item, idx</span>) =&gt;</span>(<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;idx&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;Type <span class="keyword">in</span> a <span class="keyword">new</span> Message:&lt;/h2&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.input&#125;</span><br><span class="line">          onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.submitMessage&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;messages&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">messages</span>: state&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    submitNewMessage: <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(addMessage(message))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Container/&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实现一个Redux"><a href="#实现一个Redux" class="headerlink" title="实现一个Redux"></a>实现一个Redux</h1><p>更新中…..</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Git的简单使用</title>
      <link href="/2020/09/08/git/"/>
      <url>/2020/09/08/git/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git 是 [Linus Torvalds](<a href="https://baike.baidu.com/item/Linus">https://baike.baidu.com/item/Linus</a> Torvalds/9336769) 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 GitHub 作为全球最知名的代码管理平台  使用 git 分布式版本控制系统，为代码的托管提供了非常便捷的服务</p></blockquote><p>在使用Git之前，需要了解Git系统的相关机制</p><h2 id="3个容器"><a href="#3个容器" class="headerlink" title="3个容器"></a>3个容器</h2><ul><li>工作区 ：<ul><li>当前项目目录 文件分为两种状态： 已跟踪 、 未跟踪</li><li>已跟踪的文件为以及被纳入Git版本库中的文件，具有快照记录，</li><li>已跟踪的文件在一段时候后有 3种 状态： 已提交 、 已修改 、 已暂存</li></ul></li><li>暂存区：<ul><li>当生成Git对象后，从Git版本库中放入Git对象所对应的文件的占存容器</li></ul></li><li>Git版本库：<ul><li>Git对象的直接存储容器</li></ul></li></ul><h2 id="3个对象"><a href="#3个对象" class="headerlink" title="3个对象"></a>3个对象</h2><ul><li><p>Git对象(blob)</p><p>将目标文件一git对象的方式存储于Git版本库的objects中，使用hash算法生成一个唯一的SHA-1值来标识当前文件的Git对象.        </p></li><li><p>树对象(tree)</p><p>将多个Git对象（一个项目版本的多个文件）对应的SHA-1索引生成一个树对象，记录文件的层次结构</p></li><li><p>提交对象(commit)</p><p>将一个树对象以及上一个commit对象使用注释打包(标明当前提交信息：时间、地点、人物)，</p></li></ul><h2 id="Git-基本操作流程"><a href="#Git-基本操作流程" class="headerlink" title="Git 基本操作流程"></a>Git 基本操作流程</h2><ul><li>初始化git： </li></ul><blockquote><p>git init</p></blockquote><ul><li>选择文件生成Git对象：</li></ul><blockquote><p>git add ./</p></blockquote><ul><li>将对应文件生成Git对象，并保存到Git版本库(只要工作区中的文件被修改过，就会生成新的Git对象)：</li></ul><blockquote><p>git hash-object -w 文件名   </p></blockquote><ul><li>将更新后的Git对象(多个)放入暂存区：</li></ul><blockquote><p>git update-index </p></blockquote><ul><li>生成一个树对象，并生成一个commit对象并提交：</li></ul><blockquote><p>git commit -m “注释内容”</p></blockquote><ul><li><p>上面的命令执行与下面两句命令执行等效：</p><ol><li>生成快照： 根据暂存区(index)中的文件SHA-1索引生成树对象，返回生成树对象的SHA-1值，<pre><code>只要文件有改动就会生成新的树对象</code></pre></li></ol><blockquote><p>git write-tree </p></blockquote></li></ul><ol><li><p>生成commit对象：</p><blockquote><p>git commit-tree &lt;树对象SHA-1&gt; -p &lt;上一个commit对象SHA-1&gt;</p></blockquote></li></ol><h2 id="Git-高层命令-CRUD"><a href="#Git-高层命令-CRUD" class="headerlink" title="Git 高层命令(CRUD)"></a>Git 高层命令(CRUD)</h2><ul><li>初始化</li></ul><blockquote><p>git init </p></blockquote><ul><li>查看git状态</li></ul><blockquote><p>git statue </p></blockquote><ul><li>查看那些更新还没有被暂存</li></ul><blockquote><p>git diff –cached </p></blockquote><ul><li>查看那些修改 以及 被暂存了未被提交的部分</li></ul><blockquote><p>git diff –staged </p></blockquote><ul><li>将对象提交到暂存区</li></ul><blockquote><p>git add ./ </p></blockquote><ul><li>将暂存区提交到版本库</li></ul><blockquote><p>git commit -m “注释”</p></blockquote><ul><li>直接将工作区中的文件提交到版本库，跳过暂存区</li></ul><blockquote><p>git commit -a  </p></blockquote><ul><li>查看暂存区内容</li></ul><blockquote><p>git ls-files -s </p></blockquote><ul><li>打开提交日志</li></ul><blockquote><p>git log </p></blockquote><ul><li>将文件从工作目录中删除并提交删除状态到暂存区</li></ul><blockquote><p>git rm &lt;文件名&gt;  </p></blockquote><ul><li>将文件从工作目录中 移动 或者 重命名 并提交修改状态到暂存区</li></ul><blockquote><p>git mv &lt;文件名&gt;   </p></blockquote><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>改变指向最新提交对象的指针</p><ul><li>不加参数，得到分支列表</li></ul><blockquote><p>git branch </p></blockquote><ul><li>分支名 ： 在当前的提交对象上，创建一个可移动的新指针，创建后不会自动切换到新指针上</li></ul><blockquote><p>git branch </p></blockquote><ul><li>新建一个分支并指向指定的提交对象</li></ul><blockquote><p>git branch &lt;分支名&gt; &lt;commit对象SHA-1&gt; ： </p></blockquote><ul><li>查看每个分支的最后一次提交</li></ul><blockquote><p>git branch -v </p></blockquote><ul><li>将HEAD指针切换到新分支上</li></ul><blockquote><p>git checkout &lt;分支名&gt; ： </p></blockquote><ul><li>新建一个分支，并切换到这个分支</li></ul><blockquote><p>git checkout -b &lt;分支名&gt;</p></blockquote><ul><li>强制删除分支，不能直接删除当前所在的分支，需要切换到其他分支</li></ul><blockquote><p>git branch -D &lt;分支名&gt; ： </p></blockquote><ul><li><p>合并分支:</p><ul><li><p>快进合并：</p><blockquote><p>git merge 分支名 </p></blockquote></li></ul></li></ul><blockquote><p> 如果当前分支和将要合并的分支处于同一分支线上(父子或祖孙关系)，则启用快速合并<br> 将master指向合并的分支上需要切回需要合并的分支，再执行合并.<br> 执行后主分支(master)会和新分支指向同一个commit 且 之前主分支指向的commit会得以保留</p></blockquote><ul><li><p>典型合并：</p><ul><li>如果当前分支和将要合并的分支没有处于同一分支线上，则启用典型合并，Git需要做额外工作</li></ul></li></ul><blockquote><p> 注意:<br> 切换分区所改变的 对象： HEAD 指针 、  暂存区 、 工作目录<br> 切换分支会改变当前工作目录中的内容，所以每次在切换分支之前最好提交当前分支<br> 在切换分支时，如果当前分支有未跟踪的文件，则分支可以切换成功<br> 未跟踪或未提交的文件在切换分支后得以保留，但可能会污染分支<br> 文件被改动后未提交 ，则切换分支不会成功  </p></blockquote><h2 id="Git-存储"><a href="#Git-存储" class="headerlink" title="Git 存储"></a>Git 存储</h2><p>如果不想当前工作仅仅做了一半而提交，然后切换分支的话，Git存储命令会帮助储存当前未提交的文件(被改动的)</p><ul><li><p>将未提交的修改保存到一个栈上</p><blockquote><p>git stash </p></blockquote></li><li><p>查看栈中存储的文件</p><blockquote><p>git stash list </p></blockquote></li><li><p>从栈中指定位置恢复文件，如果不指定位置默认为栈顶，而且不会删除栈中文件</p><blockquote><p> git stash apply &lt;栈号(可选)&gt;</p></blockquote></li><li><p>立即弹出栈顶的文件到工作区，并且将那个文件从栈中删除</p><blockquote><p>git stash pop</p></blockquote></li><li><p>删除栈中指定的位置的文件</p><blockquote><p>git stash drop &lt;栈号&gt; </p></blockquote></li></ul><h2 id="Git-撤回提交"><a href="#Git-撤回提交" class="headerlink" title="Git 撤回提交"></a>Git 撤回提交</h2><ul><li><p>工作区：</p><ul><li><p>撤回工作目录中的刚刚保存的文件</p><blockquote><p>git checkout -&lt;要撤回修改的文件名&gt;</p></blockquote></li></ul></li><li><p>暂存区：</p><ul><li><p>撤回暂存区中刚刚放入的文件</p><blockquote><p>git reset HEAD &lt;暂存区中要撤回的文件名&gt;</p></blockquote></li></ul></li><li><p>版本库：</p><ul><li><p>撤销提交了的commit对象(因为提交内容有误，注释写错等)</p><blockquote><p>git commit –amend  </p></blockquote><ul><li>撤销上一次提交，回到写入注释的地方，重新提交当前暂存区的内容，<br>可使用:q! 退出注释，然后重新进行提交</li></ul></li></ul></li></ul><h2 id="Git-撤回分支"><a href="#Git-撤回分支" class="headerlink" title="Git 撤回分支"></a>Git 撤回分支</h2><ul><li><p>携带撤回到某一个分支</p><blockquote><p>git reset –soft &lt;提交对象SHA-1&gt;  </p></blockquote><ul><li>移动HEAD指向的提交对象 ,会携带分支一起移动，</li><li>本质上是撤销了上一次的commit命令,但是重新提交后，错误的提交对象不会被删除，</li><li>这个命令只更改HEAD以及分支指向的commit对象,不会修改工作区和暂存区的内容  </li></ul></li><li><p>携带暂存区，撤回到某一个分支</p><blockquote><p>git reset –mixed &lt;提交对象SHA-1&gt; :  </p></blockquote><ul><li>和上个命令相似 ，不仅更改HEAD以及分支指向的commit对象，而且会将暂存区修改为当前HEAD指向的commit </li></ul></li><li><p>携带工作目录、暂存区，撤回到某一个分支</p><blockquote><p>git reset –hard  &lt;提交对象SHA-1&gt;</p></blockquote><ul><li>撤销最后的提交，并将 暂存区和工作区 修改为当前HEAD指向的commit对象(不推荐)</li></ul></li></ul><h2 id="使用Github远程仓库"><a href="#使用Github远程仓库" class="headerlink" title="使用Github远程仓库"></a>使用Github远程仓库</h2><blockquote><p> 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，<br> 通常有些仓库对你只读，有些则可以读写。</p></blockquote><h2 id="多人远程协作基本流程"><a href="#多人远程协作基本流程" class="headerlink" title="多人远程协作基本流程"></a>多人远程协作基本流程</h2><ul><li><p>项目经理操作</p><ol><li><p>使用命令创建本地仓库</p></li><li><p>为远程仓库配置别名 和 用户信息</p><ul><li><p>添加一个新的远程Git仓库，将次仓库设置一个别名：</p><blockquote><p>git remote add &lt;仓库别名&gt; url</p></blockquote></li><li><p>查看 远程仓库别名 对应的URL：</p><blockquote><p>git remote –v</p></blockquote></li><li><p>查看某一个远程仓库的更多信息：</p><blockquote><p>git remote show &lt;仓库别名&gt;</p></blockquote></li><li><p>重命名仓库别名：</p><blockquote><p>git remote rename &lt;仓库别名&gt; &lt;新别名&gt;</p></blockquote></li><li><p>应为某种原因，要移除一个远程仓库：</p><blockquote><p>git remote rm &lt;仓库别名&gt;</p></blockquote></li></ul></li><li><p>推送本地项目到远程仓库</p><ul><li><p>推送分支到远程仓库：</p><blockquote><p>git push &lt;仓库别名&gt; &lt;分支名&gt;</p></blockquote><p>在推送分支到远程仓库后，本地仓库默认会生成 红色标注 的远程跟踪分支</p></li></ul></li><li><p>获取成员提交的新内容到本地</p><ul><li>同步新数据到本地：<blockquote><p>git fetch &lt;仓库别名&gt;</p></blockquote></li></ul></li><li><p>获取成员提交的新内容到本地</p><ul><li><p>同步新数据到本地：</p><blockquote><p>git fetch &lt;仓库别名&gt;</p></blockquote></li></ul></li></ol></li><li><p>项目成员操作</p><ol><li><p>成员在工作目录中使用git配置自己的用户信息</p><ul><li><p>配置当前 工作目录 下的 用户名(name)以及邮箱(Email):</p><blockquote><p>git config user.name &lt;用户名&gt;<br>git config user.email &lt;邮箱&gt;</p></blockquote></li><li><p>删除配置的默认用户信息：</p><blockquote><p>git config –global –unset user.name<br>git config –global –unset user.email</p></blockquote></li></ul></li><li><p>成员克隆远程仓库到本地</p><ul><li><p>克隆远程仓库(将远程仓库同步到本地),不需要初始化git<br>克隆到本地的仓库别名默认为Origin</p><blockquote><p>git clone url</p></blockquote></li><li><p>修改默认远程仓库名： </p><blockquote><p>git clone -o &lt;自定义仓库名&gt;      </p></blockquote></li></ul></li><li><p>成员推送提交到远程仓库：</p><ul><li><p>推送分支到远程仓库（需要成员在Github上拥有远程仓库的写入权限，并且当前分支没有被推送过）</p><blockquote><p>git push &lt;仓库别名&gt; &lt;本地分支名&gt;  </p></blockquote></li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制系统 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 打包入门</title>
      <link href="/2020/09/03/webpack/"/>
      <url>/2020/09/03/webpack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm全局安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server -g</p></blockquote><p>进入项目根目录进行局部安装</p><blockquote><p>npm install webpack webpack-cli webpack-dev-server </p></blockquote><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>我们在开发环境下的项目根目录中创建<code>webpack.dev.js</code>，对webpack进行出口配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry : <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用数组包含多个入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个依赖项随即被处理，最后输出到output设置的指定的 的文件中</p><h2 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h2><p>与webpack3 不同，在<code>webpack.dev.js</code>中新增了一个<code>mode</code>的选项，即选择打包的模式，development（开发环境）production（生产环境），两者的区别很简单，生产环境会对代码进行压缩，即去除所有代码缩进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p>出口是指示将零散的模块汇入到哪一个文件中，出口中设置的文件将包含所有需要的依赖，这里我们使用node的path模块来解析目录</p><p><code>filename</code>：指定最终打包生成的js文件名，可以使用[name]获取入口js的文件名</p><p><code>path</code>：指定输出的目录</p><p><code>publicPath</code>：指定静态资源的根路径，意味着有时候静态资源需要从外部加载，那么要将<code>publicPath</code>指定为一个外部域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发环境调试服务器"><a href="#开发环境调试服务器" class="headerlink" title="开发环境调试服务器"></a>开发环境调试服务器</h2><p>在开发环境中使用webpack并进行调试，并期望进行即时打包与错误提示，那么我们可以使用一下选项</p><p><code>contentBase</code>: 指定服务器读取文件的根目录<br><code>overlay</code>: 布尔值，开启错误提示<br><code>port</code>: 自定义端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        overlay: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        port: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包静态资源"><a href="#打包静态资源" class="headerlink" title="打包静态资源"></a>打包静态资源</h2><p>webpack需要使用几个额外的模块来对css，图片，html文件进行打包处理</p><p>需要执行一下命令，执行局部安装</p><blockquote><p>npm install style-loader css-loader file-loader extract-loader html-loader</p></blockquote><p>style-loader：负责将打包后生成的css模块以<code>&lt;style&gt;</code>标签的形式插入到html中</p><p>css-loader：负责打包所有css样式</p><p>file-loader：负责找到所需文件资源，并返回其public中的URL</p><p>extract-loader ：它的主要用例是解决来自各自装载器的 HTML 和 CSS 内的 URL</p><p>html-loader：将 HTML 导出为字符串。当编译器要求时，HTML 被最小化（去除缩进）</p><p>我们需要在<code>./config/webpack.dev.js</code>中继续添加一个module选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span> ，</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name]-bundle.js&#x27;</span>, <span class="comment">// 使用</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), </span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        overlay: <span class="literal">true</span>, <span class="comment">// 为错误显示提示信息</span></span><br><span class="line">        port: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                <span class="comment">// css-loaders,找到所有的css文件</span></span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;style-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">&#x27;[name].html&#x27;</span> <span class="comment">// 指定打包后的html文件名称，这里设置[name]就是打包之前html的名称</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123; <span class="comment">// 将html和js文件分开打包</span></span><br><span class="line">                        loader: <span class="string">&#x27;extract-loader&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 配置图片资源加载器image-loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(jpg|git|png)/</span>,</span><br><span class="line">                </span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                        <span class="comment">// 对上面匹配到的文件使用一下模块进行打包</span></span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">&#x27;images/[name]-[hash:8].[ext]&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES语法兼容"><a href="#ES语法兼容" class="headerlink" title="ES语法兼容"></a>ES语法兼容</h2><p>我们知道ES6相对于ES5新增了一些语法方面的内容，这可能导致使用ES6编写的js文件在某些不支持ES6的浏览器上无法被正常执行，所以Babel就出现了，他是一个将ES6语法转换为ES5的js模块</p><p>Babel的使用方法具体可参考官方文档，在这里我们要在webpack中将打包的js文件转换为ES5的版本</p><p>首先是安装Babel核心模块，安装第七版本的babel-loader与webpack中打包使用</p><blockquote><p>npm install babel-core babel-loader@7</p></blockquote><p>安装 babel 的插件</p><blockquote><p>npm install babel-plugin-transform-es2015-arrow-functions</p></blockquote><p>安装完毕后，需要在项目根目录下新建一个文件 <code>.babelrc</code>，来配置Babel中使用的插件，内容为JSON格式</p><p>这里先配置了一个箭头函数的转换</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>./config/webpack.dev.js</code>的module中的rule内添加一个loader即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./config/webpack.dev.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 选择所有js文件进行</span></span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装async函数语法转换插件，将async转换为<strong>使用promsie的普通函数</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-es2015-arrow-functions&quot;</span>,</span><br><span class="line">    <span class="string">&quot;async-to-promises&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Babel</code>默认只会转译语法，比如箭头函数，但是不会转换一些新增的对象方法，例如<code>Object.assign()</code>和<code>Array.prototype.includes()</code>此时，使用额外的三个Babel衍生模块就能更好的处理ECMAScript新增内容</p><p><code>babel-polyfill</code>：常规的babel打包是将打包后的js出口文件进行语法的转换，而<code>babel-polyfill</code>将语法转换提前到打包之前</p><p><code>babel-preset</code>：一个将常用的babel插件集合，也就是说，使用preset会自动配置一些常用的babel插件</p><p><code>babel-transform</code>：<code>babel-polyfill</code>会将Promise等添加成全局变量，污染全局空间，而<code>babel-transform</code>可以解决这个问题</p><p>安装<code>babel-polyfill</code> ：</p><blockquote><p>npm install babel-polyfill  </p></blockquote><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改./config/webpack.dev.js</span></span><br><span class="line">entry: &#123;</span><br><span class="line">        main: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>安装<code>babel-preset</code>：</p><blockquote><p>npm install babel-preset</p></blockquote><p>使用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;debug&quot;</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 前端兼容性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CSS+JS实现一个简单的立方体(可旋转)</title>
      <link href="/2020/09/02/cube/"/>
      <url>/2020/09/02/cube/</url>
      
        <content type="html"><![CDATA[<p>使用CSS3的景深与三维变换+JavaScript实现一个可旋转的立方体（x,y两轴旋转）</p><p>HTML部分：</p><p>首先先构建立方体的DOM结构：</p><ul><li>将6个面使用cube包裹，目的很简单，为了给子元素开启3d景深，</li><li>使用wrap再次包裹，wrap的目的是为了包装整个立方体，可控制缩放</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube-face&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其对应样式如下：(使用less书写)</p><p>html与body的样式，使用 overflow: hidden; 隐藏垂直滚动条，防止移动端的滑动</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#dfe6e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.wrap:将其设置为100 x 100 px的初始大小，并水平垂直居中，默认将其放大两倍</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>) scale(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.cube : 将其设置为100 x 100 px 的初始大小，并使用另一种水平垂直居中的解决办法，且开启内部元素的3D变换</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cube</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center center; <span class="comment">/*设置旋转中心为立方体的重心*/</span> </span><br><span class="line">    <span class="attribute">transform</span>: rotateX(-<span class="number">30deg</span>) rotateY(<span class="number">30deg</span>); <span class="comment">/*默认将立方体选择一定角度*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写6个面之前，我们需要了解浏览器页面的3D坐标系</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/coordinate_axis.png" alt="css3d"></p><p>从+Z 到 -Z 方向，为用户看向浏览器屏幕的方向，意味着如果不开启3D变换，那么一切元素都是按照Z轴进行选择</p><p>从+Y 到 -Y 方向，为屏幕从下到上的方向，意味着元素会按照Y轴左右旋转</p><p>从+X 到 -X 方向，为屏幕从左到右的方向，意味着元素可以按照X轴上下翻转</p><p>了解了坐标系，那么可以编写css代码了</p><p>首先我们需要将6个面的公共样式提取出，然后分别为每个面定制选择的角度，以及选择的原点，在这里所有的<code>animation: first 1.5s .8s forwards;</code>可以暂时不编写，因为这是附加的入场动画效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.cube-face &#123;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    position: absolute;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-size: <span class="number">40</span>px;</span><br><span class="line">    line-height: <span class="number">100</span>px;</span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">    user-select: none;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">1</span>) &#123;</span><br><span class="line">        top: <span class="number">-100</span>%;</span><br><span class="line">        transform: rotateX(<span class="number">90</span>deg) translateY(<span class="number">50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        transform-origin: bottom;</span><br><span class="line">        animation: first <span class="number">1.5</span>s <span class="number">.8</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">2</span>) &#123;</span><br><span class="line">        bottom: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: top;</span><br><span class="line">        transform: rotateX(<span class="number">-90</span>deg) translateY(<span class="number">-50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: second <span class="number">1.5</span>s <span class="number">1</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">3</span>) &#123;</span><br><span class="line">        left: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: right;</span><br><span class="line">        transform: rotateY(<span class="number">-90</span>deg) translateX(<span class="number">50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: third <span class="number">1.5</span>s <span class="number">.4</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">4</span>) &#123;</span><br><span class="line">        right: <span class="number">-100</span>%;</span><br><span class="line">        transform-origin: left;</span><br><span class="line">        transform: rotateY(<span class="number">90</span>deg) translateX(<span class="number">-50</span>px) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: fourth <span class="number">1.5</span>s <span class="number">.6</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">5</span>) &#123;</span><br><span class="line">        transform: rotateY(<span class="number">180</span>deg) translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: fifth <span class="number">1.5</span>s <span class="number">.2</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:nth-child(<span class="number">6</span>) &#123;</span><br><span class="line">        transform: translateZ(<span class="number">150</span>px);</span><br><span class="line">        animation: sixth <span class="number">1.5</span>s forwards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你按照我上方的代码编写，你就会发现结果是这样的一个页面：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200902163752855.png" alt="image-20200902163752855"></p><p>这是因为我们最终的目的是要使用@keyframe来进行进场动画，动画必须设置forward为播放一次，且在结束时不变，接下来编写6个css动画：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> first &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(<span class="number">90deg</span>) translateY(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> second &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateX(-<span class="number">90deg</span>) translateY(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> third &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(-<span class="number">90deg</span>) translateX(<span class="number">50px</span>) ;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fourth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">90deg</span>) translateX(-<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fifth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: rotateY(<span class="number">180deg</span>) translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> sixth &#123;</span><br><span class="line">    <span class="selector-tag">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: translateZ(<span class="number">50px</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个动画的最终位置就是每个面的正确位置，最后为每个面加上延迟动画即可，这时，你可以看到每一个面交错入场，搭建成一个立方体</p><p>此时需要另外使用一个透明的覆盖层，改变z-index，覆盖整个wrap，用于旋转时的防止立方体元素获得鼠标焦点</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200902155629492.png" alt="image-20200902155629492"></p><p>现在布局以及样式都以及准备完毕了，接下来就进入到JavaScript的编写</p><p>首先获取需要DOM元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrap = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.wrap&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cube = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.cube&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cover = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.cover&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> tip = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.tip &gt; span&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> cubeFace = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.cube-face&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建需要的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keydownPosX;  <span class="comment">//鼠标按下时在在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> keydownPosY;  <span class="comment">//鼠标按下时在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegX = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的X坐标</span></span><br><span class="line"><span class="keyword">let</span> currentDegY = <span class="number">0</span>; <span class="comment">//鼠标当前在浏览器窗口上的Y坐标</span></span><br><span class="line"><span class="keyword">let</span> stopDegX = <span class="number">30</span>;  <span class="comment">//上一次X轴旋转的角度</span></span><br><span class="line"><span class="keyword">let</span> stopDegY = <span class="number">-30</span>; <span class="comment">//上一次Y轴旋转的角度</span></span><br><span class="line"><span class="keyword">let</span> timer;<span class="comment">// 自动旋转定时器</span></span><br></pre></td></tr></table></figure><p>设置一个定时器，延时旋转立方体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        stopDegX += <span class="number">.2</span>;</span><br><span class="line">        cube.style.transform = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX&#125;</span>deg)`</span>;</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><p>监听鼠标在cover覆盖层上的事件：分别是按下时，移动时，抬起时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cover.addEventListener(<span class="string">&quot;mousedown&quot;</span>, mousedown)</span><br><span class="line">cover.addEventListener(<span class="string">&quot;mouseup&quot;</span>, mouseup)</span><br><span class="line">cover.addEventListener(<span class="string">&quot;mouseout&quot;</span>, mouseup)</span><br></pre></td></tr></table></figure><p>编写按下时的回调函数：立即清除定时器，记录坐标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousedown</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    keydownPosX = ev.offsetX;</span><br><span class="line">    keydownPosY = ev.offsetY;</span><br><span class="line">    cover.addEventListener(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写拖拽与鼠标抬起事件的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//计算鼠标坐标的变化量，并减小旋转速度，即将鼠标移动的坐标除以3，可调节</span></span><br><span class="line">    currentDegX = (ev.offsetX - keydownPosX) / <span class="number">3</span>; </span><br><span class="line">    currentDegY = -(ev.offsetY - keydownPosY) / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 将坐标变化量加上之前的旋转角度，设置到transform中</span></span><br><span class="line">    cube.style.transform = <span class="string">`rotateX(<span class="subst">$&#123;stopDegY + currentDegY&#125;</span>deg) rotateY(<span class="subst">$&#123;stopDegX + currentDegX&#125;</span>deg)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mouseup</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    stopDegX += currentDegX <span class="comment">// 更新增加的角度</span></span><br><span class="line">    stopDegY += currentDegY</span><br><span class="line">    currentDegX = <span class="number">0</span>; <span class="comment">// 将当前鼠标位置数据清空</span></span><br><span class="line">    currentDegY = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 松开后移除鼠标移动事件</span></span><br><span class="line">    cover.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, drag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，可旋转立方体基本功能已经完成，代码相对简单，只涉及到事件对象的信息获取以及对元素的样式操作</p><p>最后附上Demo地址： <a href="https://ericreevess.github.io/proxy/web/Cube3Dv2/">cube</a> (使用PC端浏览器打开)</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解MongoDB与mongoose</title>
      <link href="/2020/09/02/mongoDB/"/>
      <url>/2020/09/02/mongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>数据库：存放集合，可以有多个，不需要手动创建</li><li>集合：类似于数组，存放文档，不需要手动创建</li><li>文档：数据的最小单位</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200810170644701.png" alt="image-20200810170644701"></p><p>常用命令</p><ul><li><p>查看数据库占用空间</p><blockquote><p>show dbs</p></blockquote></li><li><p>进入到指定数据库</p><blockquote><p>use 数据库名</p></blockquote></li><li><p>显示当前所在的数据库</p><blockquote><p>db</p></blockquote></li><li><p>显示数据库中所有的集合</p><blockquote><p>show collections</p></blockquote></li><li><p>插入数据到某集合中</p><blockquote><p>db.集合名.insert(js对象类型的键值对)</p></blockquote></li><li><p>查找集合下的所有文档</p><blockquote><p>db.集合名.find() </p></blockquote></li></ul><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>mongoose 是一个对象-文档模型，他对NodeJS原生的MongoDB模块进行了进一步的封装，提供了更多的功能，大多数亲情况下，他被用来把结构化的模式应用到一个集合中</p><ul><li>并且提供数据验证和类型转换的功能</li><li>为文档创建一个约束使得数据结构合法</li><li>使用中间件</li><li>更容易驱动</li></ul><p>核心对象：</p><ul><li>Schema（模式对象），约束了集合中的文档结构</li><li>Model 将集合作为对象来表示，包含在内的所有文档</li><li>Document 表示集合中的一个具体文档对象，每个文档在创建时，都会自动生成一个<code>_id</code>的属性</li></ul><p>代码示例，来源于真实项目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost:27017/test&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>, <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获得数据库对象</span></span><br><span class="line"><span class="keyword">const</span> mongooseConnection = mongoose.connection</span><br><span class="line"><span class="comment">// 监听连接状态</span></span><br><span class="line">mongooseConnection.on(<span class="string">&#x27;connected&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Mongo数据库连接成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义数据约束，与SQL中的表类似</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.Schema(&#123;</span><br><span class="line">  username: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  password: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  userType: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  avatar: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  position: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;, <span class="comment">// 职位信息</span></span><br><span class="line">  personalInfo: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;, <span class="comment">// 个人信息、职位要求</span></span><br><span class="line">  companyInfo: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  salary: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatSchema = mongoose.Schema(&#123;</span><br><span class="line">  from_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的发起者的用户id</span></span><br><span class="line">  to_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的接受者的用户id</span></span><br><span class="line">  chat_id: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;, <span class="comment">// 消息的聊天室id</span></span><br><span class="line">  content: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  hasRead: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  create_time: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userModel = <span class="keyword">new</span> UserModel(&#123;</span><br><span class="line">    username: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    password: md5(<span class="string">&#x27;654321&#x27;</span>),</span><br><span class="line">    type: <span class="string">&#x27;jobSeeker&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  userModel.save(<span class="function">(<span class="params">err, userDoc</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(userDoc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">saveTest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试查询数据，一个或多个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.find(<span class="function">(<span class="params">err, usersDocArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(usersDocArr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  UserModel.findOne(&#123; <span class="attr">_id</span>: <span class="string">&#x27;5f32912c5a24d012779cf1ea&#x27;</span> &#125;,</span><br><span class="line">    (err, userDoc) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(userDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findTest()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.findByIdAndUpdate(</span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">username</span>: <span class="string">&#x27;test-update&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">useFindAndModify</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">    (err,oldUserDoc) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(oldUserDoc)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">updateTest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteTest</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  UserModel.deleteOne( <span class="comment">// 这里官方建议使用deleteOne() 和 deleteMany()</span></span><br><span class="line">    &#123;<span class="attr">_id</span>: <span class="string">&#x27;5f329d9fb913dd12e4d67a0a&#x27;</span>&#125;,</span><br><span class="line">    (err,delInfo) =&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(delInfo)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteTest()</span><br><span class="line"><span class="comment">// 在删除之后返回的对象格式为&#123; n: 1, ok: 1, deletedCount: 0 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
            <tag> mongoose </tag>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据结构与算法</title>
      <link href="/2020/09/02/javascript_algorithms/"/>
      <url>/2020/09/02/javascript_algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据结构与算法是每一个计算机编程学者的必备知识，在日常生活中，算法无处不在，本文将使用JavaScript实现一些常用的数据结构与算法，例如二叉树的创建以及删除等，以及一些算法的实际应用</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><p>使用队列实现约瑟夫环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.maxSize = size</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Queue,</span><br><span class="line">  enter (item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.maxSize) &#123;</span><br><span class="line">      item !== <span class="string">&#x27;&#x27;</span> ? <span class="built_in">this</span>.items[<span class="built_in">this</span>.index++] = item : <span class="built_in">console</span>.log(<span class="string">&#x27;数据不能为空&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  shift () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.index--</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列为空&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  peek () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;栈当前为空&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index === <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  size () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index</span><br><span class="line">  &#125;,</span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">    <span class="built_in">this</span>.items = []</span><br><span class="line">  &#125;,</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`head-&gt;| <span class="subst">$&#123;<span class="built_in">this</span>.items.map(item =&gt; item)&#125;</span> |&lt;-tail`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">josephRing</span> (<span class="params">arr,num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue(arr.length)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    queue.enter(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;arr.length<span class="number">-1</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;num <span class="number">-1</span> ; j++) &#123;</span><br><span class="line">      queue.enter(queue.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    res = queue.shift()</span><br><span class="line">    <span class="comment">//console.log(res)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.peek()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(josephRing([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用插入排序实现优先级队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">priorityQueue</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span> (<span class="params">value, priority</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.priority = priority</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.maxSize = size</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.enter = <span class="function"><span class="keyword">function</span> (<span class="params">value, priority</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.maxSize) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = <span class="keyword">new</span> QueueElement(value, priority)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经典插入排序</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span><span class="comment">// 扫描标志位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.items[i].priority &gt; element.priority) &#123; <span class="comment">//检测到有元素的优先级比新元素优先级大</span></span><br><span class="line">            <span class="built_in">this</span>.items.splice(i, <span class="number">0</span>, element) <span class="comment">// 在当前位置插入</span></span><br><span class="line">            flag = <span class="literal">true</span> <span class="comment">// 标识已经插入</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 如果队列中所有的元素优先级都比新元素小</span></span><br><span class="line">          <span class="built_in">this</span>.items.push(element) <span class="comment">// 放置在队列最后</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.index++ <span class="comment">// 增加index</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;当前队列已满&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">priorityQueue.prototype = Queue.prototype <span class="comment">// 继承普通队列的一些方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pQueue = <span class="keyword">new</span> priorityQueue(<span class="number">10</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;Apple&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;sbb&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">pQueue.enter(<span class="string">&#x27;lenovo&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pQueue)</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合通常是一组无序，不能重复的元素构成，常见的实现方式为哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Set</span>.prototype = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.items[value] = value</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  remove: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.items[value]</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getValues: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items)</span><br><span class="line">  &#125;,</span><br><span class="line">  isSet:<span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set <span class="keyword">instanceof</span> <span class="built_in">Set</span></span><br><span class="line">  &#125;,</span><br><span class="line">  size: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length</span><br><span class="line">  &#125;,</span><br><span class="line">  clear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Set</span>.prototype.constructor = <span class="built_in">Set</span></span><br></pre></td></tr></table></figure><p>集合间操作：</p><ul><li><p>并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">union: <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!set <span class="keyword">instanceof</span> <span class="built_in">Set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  values = set.getValues()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unionSet</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">intersection:<span class="function"><span class="keyword">function</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set.has(values[i]))&#123;</span><br><span class="line">        intersectionSet.add(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>差集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">difference:<span class="function"><span class="keyword">function</span>(<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> values = <span class="built_in">this</span>.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      differenceSet.add(values[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values = set.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (differenceSet.has(values[i]))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(values[i])</span><br><span class="line">        <span class="keyword">delete</span> differenceSet.remove([values[i]])</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        differenceSet.add(values[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>子集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">isChild:<span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSet(set)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> values = set.getValues()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.has(values[i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul><li><p>哈希表通常基于数组实现</p></li><li><p>优点：</p><ul><li>可以提供非常快的插入删除查找 操作</li><li>无论数据规模大小，插入和删除的时间复杂度接近常量O(1)，实际为通过计算得出</li><li>一般情况下性能比树结构快，且编码容易</li></ul></li><li><p>缺点：</p><ul><li>数据无序，且不能通过固定方式顺序遍历</li><li>key不允许重复</li></ul></li><li><p>空间利用率不高</p><ul><li>查找最大最小值不方便</li></ul></li><li><p>哈希化：将对应数据转换为数字</p></li><li><p>哈希函数：将大数字转换为小数字</p></li><li><p>解决冲突：综合来讲，链地址法的效率比较稳定</p><ul><li>链地址法：结合链表存储冲突元素（推荐）</li><li>开放地址法：寻找表中空白位置进行添加<ul><li>线性探测：<ul><li>以线性的方式向后寻找空白位置，</li><li>在查找时候遇到空白位置即停止</li><li>在删除某个冲突元素的时候，将删除后的位置的值作特殊处理</li><li>可能会产生聚集：多个元素在表中连续吗，导致哈希表性能下降</li></ul></li><li>二次探测<ul><li>在产生冲突后，使用<code>x+n^2</code>为跨度进行空白位置的探测，但探测的步长任然是固定的</li></ul></li><li>再哈希法<ul><li>当产生冲突时，将关键字用另外一个哈希函数再次哈希化</li></ul></li></ul></li></ul></li><li><p>哈希函数的选择：</p><ul><li>霍纳法则</li></ul></li><li><p>哈希表的长度：为了实现尽可能最大的均匀分布，在设置哈希表长度的时候尽量使用质数，以及N次幂的底数</p></li></ul><h3 id="实现一个Hash函数"><a href="#实现一个Hash函数" class="headerlink" title="实现一个Hash函数"></a>实现一个Hash函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设计一个哈希函数</span></span><br><span class="line"><span class="comment">* 将字符串转换为比较大的数字HashCode</span></span><br><span class="line"><span class="comment">* 然后将Hashcode压缩到数组的范围之内</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span> (<span class="params">str, size</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化hashCode</span></span><br><span class="line">  <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 霍纳算法，使用一个质数和Unicode编码迭代计算出该字符串的hashCode</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    hashCode = <span class="number">43</span> * hashCode + str.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hashCode % size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是否为质数"><a href="#判断一个数是否为质数" class="headerlink" title="判断一个数是否为质数"></a>判断一个数是否为质数</h3><ul><li><p>普通的判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更高效的判断:<br>如果一个数可以被除了1和本身以外其他数字因式分解，那么他的平方根一定大于等于其因式分解的第一个数，小于等于因式分解的第二个数，如果在平方根到2的范围内不能找到与其整除的数，那么此数就为质数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span> ; i&lt;= <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.sqrt(num)) ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num %i === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><ul><li><p>概念：</p><ul><li>二叉搜索树可以为空</li><li>非空左子树的所有节点键值小于其根节点的键值</li><li>非空右子树的所有节点键值大于其根节点的键值</li></ul></li><li><p>基本结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (key) &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>常见操作：</p><ul><li><p>insert(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">insert (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.root) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归寻找并插入</span></span><br><span class="line">  insertNode (treeNode, newNode) &#123;</span><br><span class="line">    <span class="comment">// 需判断类型，如果不是Node类的实例，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!newNode <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt;= treeNode.key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.left)&#123; <span class="comment">// 若孩子节点为空，则直接插入</span></span><br><span class="line">        treeNode.left = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则 递归 插入，知道找到空位置</span></span><br><span class="line">        <span class="built_in">this</span>.insertNode(treeNode.left, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.key &gt; treeNode.key)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!treeNode.right)&#123;</span><br><span class="line">        treeNode.right = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertNode(treeNode.right, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>search(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用递归搜索二叉树  </span></span><br><span class="line">search(key,node = <span class="built_in">this</span>.root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.search(key,node.left) <span class="comment">// 此处必须return，不然上级函数无法收到下级的返回值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.search(key,node.right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 非递归搜索二叉树</span></span><br><span class="line">searchWithoutRecursive(key)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (currentNode)&#123;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; currentNode.key)&#123;</span><br><span class="line">        currentNode = currentNode.left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key)&#123;</span><br><span class="line">        currentNode = currentNode.right</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preOrderTraverse() 前序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历节点:根左右</span></span><br><span class="line">  preOrderTraverse(node = <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(node.key)</span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverse(node.left)</span><br><span class="line">      <span class="built_in">this</span>.preOrderTraverse(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>inOrderTraverse() 中序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树:左根右</span></span><br><span class="line">inOrderTraverse(node = <span class="built_in">this</span>.root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverse(node.left)</span><br><span class="line">      <span class="built_in">console</span>.log(node.key)</span><br><span class="line">      <span class="built_in">this</span>.inOrderTraverse(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>postOrderTraverse() 后序遍历二叉树</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树:左右根</span></span><br><span class="line"> postOrderTraverse(node = <span class="built_in">this</span>.root)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.postOrderTraverse(node.left)</span><br><span class="line">       <span class="built_in">this</span>.postOrderTraverse(node.right)</span><br><span class="line">       <span class="built_in">console</span>.log(node.key)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>min()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">min()&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.root)&#123; <span class="comment">// 空根，退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root <span class="comment">// 一直向左子树寻找，直到左子树为null</span></span><br><span class="line">      <span class="keyword">while</span>(currentNode.left)&#123;</span><br><span class="line">          currentNode = currentNode.left</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currentNode.key</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>max()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.root)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">while</span>(currentNode.right)&#123;</span><br><span class="line">      currentNode = currentNode.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>remove(key)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">removeNode(key)&#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.search(key))&#123;</span><br><span class="line">      <span class="keyword">while</span> (currentNode.key !== key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; currentNode.key)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">true</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key)&#123;</span><br><span class="line">          isLeftChild = <span class="literal">false</span></span><br><span class="line">          prevNode = currentNode</span><br><span class="line">          currentNode = currentNode.right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(prevNode)</span><br><span class="line">          <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况1： 删除的节点是叶子节点，或者是没有孩子的根节点</span></span><br><span class="line">      <span class="keyword">if</span> (! (currentNode.left &amp;&amp; currentNode.right) )&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( isLeftChild )&#123;</span><br><span class="line">          prevNode.left = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 情况2： 删除的节点只有一个子节点</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有右子节点</span></span><br><span class="line">      <span class="keyword">if</span>(!currentNode.left)&#123;</span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有右子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = currentNode.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = currentNode.right</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 如果删除的节点只有左子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!currentNode.right)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是根节点，且只有左子节点</span></span><br><span class="line">        <span class="keyword">if</span>( currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          <span class="built_in">this</span>.root = <span class="built_in">this</span>.root.left</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除的节点是上一个节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = currentNode.left</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点，将上一个节点的右节点连接到当前节点的左节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = currentNode.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 情况3：如果删除的节点有2个子节点，情况就复杂起来了</span></span><br><span class="line">      <span class="comment">// 经过多个情况的综合探查，如果要删除有2个子节点的节点，需要找到一个节点将其替换</span></span><br><span class="line">      <span class="comment">// 这个节点必须是删除节点左子树的最大值，称为删除节前驱 或者 右子树的最小值，称为后继</span></span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此处的后继要么没有子节点，要么只有右节点，没有左节点</span></span><br><span class="line">        <span class="keyword">let</span> successor = <span class="built_in">this</span>.getNodeSuccessor(currentNode)</span><br><span class="line">        <span class="comment">// 如果当前删除的节点是根</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode === <span class="built_in">this</span>.root)&#123;</span><br><span class="line">          successor.left = currentNode.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被删除的节点是双亲节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">          prevNode.left = successor</span><br><span class="line">          <span class="comment">// 如果删除的节点是上一个节点的右节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          prevNode.right = successor</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将删除的节点的左节点接上后继节点</span></span><br><span class="line">        successor.left = currentNode.left</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  没有找到这个节点，返回false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 获取后继节点</span></span><br><span class="line">  getNodeSuccessor(node)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> successorParent = node.right</span><br><span class="line">    <span class="keyword">let</span> successor = node.right</span><br><span class="line">    <span class="comment">// 找到后继节点</span></span><br><span class="line">    <span class="keyword">while</span>(successor.left)&#123;</span><br><span class="line">      successorParent = successor</span><br><span class="line">      successor = successor.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点不是删除的节点的右子树的根</span></span><br><span class="line">    <span class="keyword">if</span> (successor !== node.right)&#123;</span><br><span class="line">      <span class="comment">// 让后继节点的右节点成为 后继节点的双亲节点的左节点（因为后继节点上所有节点都比后继节点的双亲节点小）</span></span><br><span class="line">      successorParent.left = successor.right</span><br><span class="line">      <span class="comment">// 让后继节点的双亲节点成为 后继节点的右节点（比后继大的节点）</span></span><br><span class="line">      successor.right = node.right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> successor</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际操作中，删除二叉树节点操作编码比较复杂，而且开销相对较大，所以一般情况下，尽量避免删除操作，而是给Node节点类添加一个<code>isDelete</code>的Boolean值，来标识当前节点是否删除，这样只需要寻找到删除的节点即可，而标识了被删除的节点在寻找时不会被返回，而是向下寻找或者跳出，但是这种处理方法会浪费大量的空间。</p><h3 id="寻找二叉树的最小深度"><a href="#寻找二叉树的最小深度" class="headerlink" title="寻找二叉树的最小深度"></a>寻找二叉树的最小深度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"> root </span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!root)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(!root.left &amp;&amp; !root.right)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> queue = []</span><br><span class="line">      queue.push(root);</span><br><span class="line">      <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">          <span class="keyword">let</span> len = queue.length <span class="comment">// 必须记录上次放入的节点数，否则depth不会增加</span></span><br><span class="line">          depth++;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">              <span class="keyword">let</span> cur = queue.shift()        </span><br><span class="line">              <span class="keyword">if</span>(!cur.left &amp;&amp; !cur.right)</span><br><span class="line">                  <span class="keyword">return</span> depth;</span><br><span class="line">              <span class="keyword">if</span>(cur.left)</span><br><span class="line">                  queue.push(cur.left);</span><br><span class="line">              <span class="keyword">if</span>(cur.right)</span><br><span class="line">                  queue.push(cur.right);</span><br><span class="line">          &#125;              </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>### 二叉搜索树的缺陷当按照有序，或者大部分有序的的方式插入数据，二叉搜索树的根节点会出现左子树过小，右子树过大，和与之相反的情况，二叉搜索树将失去平衡解决方法：* 使用AVL树，自平衡二叉查找树，每个节点多存储了一个额外的数据* 红黑树：目前广泛使用的平衡树，使用一些特性来保持平衡，在插入、删除操作时，性能优于AVL树  * 节点只有红色和黑色两种  * 根节点是黑色  * 每个叶子节点都是黑色的空节点(NIL)  * 每个红色节点的两个子节点都是黑色  * 从任意节点到其每个叶子姐弟啊你的所有路径都包含相同数目的黑色节点</code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>普通完全二叉树的问题：n个节点一共有2n个指针，除了根节点之外，n-1个节点都被2n个指针中的n-1个指针引用着，所以剩下2n-(n-1) = n + 1个指针域为null</p><p>如果我们将这n + 1 个指针域在某种遍历次序下存放下一个遍历的前驱或者后继，那么这样的二叉树成为线索二叉树</p><p>按照遍历次序不同可分为三种线索二叉树：前序、中序、后序</p><p>空节点指向规则：</p><ul><li>如果节点的左指针没有被使用，那么左指针指向遍历次序的前驱节点</li><li>如果节点的右指针没有被使用，那么右指针指向遍历次序的后继节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索化二叉树方法,在搜索二叉树的基础上实现</span></span><br><span class="line">inOrderThreadedNodes = <span class="function">(<span class="params">node = <span class="built_in">this</span>.root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">this</span>.inOrderThreadedNodes(node.left)</span><br><span class="line">    <span class="comment">// 处理前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left)&#123;</span><br><span class="line">        node.left = <span class="built_in">this</span>.pre</span><br><span class="line">        node.leftIstree = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理后继节点，使用一个全局变量指向中序遍历的上一个节点，为上一个节点线索后继指针</span></span><br><span class="line">    <span class="comment">// 当pre不为空，且pre的后继指针没有被使用的时候，pre的后继就是当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pre &amp;&amp; !<span class="built_in">this</span>.pre.right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.pre.right = node</span><br><span class="line">        <span class="built_in">this</span>.pre.rightIstree = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理节点后，改变pre成为下一个前驱节点</span></span><br><span class="line">    <span class="built_in">this</span>.pre = node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">this</span>.inOrderThreadedNodes(node.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inOrderTraverseThreadedNodes = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">this</span>.root</span><br><span class="line">    <span class="comment">// 当p不为空的时候循环</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="comment">// 当p的节点的左指针指向的是子树而不是前驱，则一直循环直到找到最左的元素</span></span><br><span class="line">        <span class="keyword">while</span> (p.leftIstree)&#123;</span><br><span class="line">            p = p.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出这个值</span></span><br><span class="line">        <span class="built_in">console</span>.log(p.key)</span><br><span class="line">        <span class="comment">// 如果p的右节点指向的不是子树，而是后继节点，则直接向后继节点访问</span></span><br><span class="line">        <span class="keyword">while</span> (!p.rightIstree)&#123;</span><br><span class="line">            p = p.right</span><br><span class="line">            <span class="built_in">console</span>.log(p.key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到了右指针指向子树的节点，则跳转到这个节点，继续循环以上步骤，直到p为null</span></span><br><span class="line">        p = p.right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树（概念）"><a href="#红黑树（概念）" class="headerlink" title="红黑树（概念）"></a>红黑树（概念）</h2><p>红黑树规则</p><ol><li>节点只能是红色和黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色且空节点（NIL节点）</li><li>黑节点可以连续，红节点不能连续出现</li><li>红节点的子节点都必须是黑色节点</li><li>从任意节点到其子树的叶子节点的路径上包含相同的黑色节点</li></ol><p>红黑树特性：</p><ul><li>从根到叶子的最长路径，不会超过最短路径的两倍</li></ul><p>红黑树变换</p><ul><li>插入：新节点一般默认为红色节点，如果新节点为黑色会难以调整</li><li>左旋转：逆时针旋转</li><li>右旋转：顺时针旋转</li></ul><p>红黑树插入</p><p>相关节点角色：红色新节点:N  新节点的兄弟节点:B    新节点的双亲节点:P    新节点的祖节点:G    新节点的双亲节点的兄弟节点:U</p><p>在搜索二叉树规则下进行插入新节点替换为某个黑色NIL节点之后，在红色新节点上添加2个叶子节点NIL，此时有5种可能的情况</p><ol><li><p>N是根节点，直接将N的红色变为黑色（规则2）</p></li><li><p>N的P是黑色，不做任何变换</p></li><li><p>P是红色，U也是红色，G一定为黑色，此时需将P和U变为黑色，G变为红色</p><ol><li>如果变化后G为根节点，则将G以及整个子树都插入到内容为空的红黑树中，即G变为黑色</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822114725471.png" alt="image-20200822114725471"></p></li><li><p>N是P的左子节点，P为红色，且P的右子节点不为空，U为黑色，G为黑色，此时需要将P变为黑色，G变为红色，再进行右旋转</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822115425240.png" alt="image-20200822115425240"><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822115551815.png" alt="image-20200822115551815"></p></li><li><p>N是P的右子节点，P为红色，且P的左子节点B不为空，U为黑色，G为黑色，此时</p><ol><li>以P为根进行左旋转</li><li>将G变为红色，N变为黑色，以G为根进行右旋转   </li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200822123122453.png" alt="image-20200822123122453"></p></li></ol><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><ul><li><p>插入排序</p><p>基本思路：以第一个元素作为参照，将之后的元素插入到前方有序数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arrCpy = arr.slice(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrCpy.length; i++) &#123; <span class="comment">// 一共循环n-1次，因为一第一个元素为参照进行插入</span></span><br><span class="line">        temp = arrCpy[i]<span class="comment">// 保存要插入值</span></span><br><span class="line">        <span class="comment">// 从前面的有序序列的最后一个位置开始向前与插入值比较，如果遇到比插入值大的元素，则将该元素往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arrCpy[j] &gt; temp; j--) &#123; </span><br><span class="line">            <span class="comment">// 如果遇到元素的值比插入值小，则直接跳出循环，此时j指向的是比插入值小的元素，j+1此时要么指向i 要么指向已经向后移位的元素</span></span><br><span class="line">            arrCpy[j+<span class="number">1</span>] = arrCpy[j]</span><br><span class="line">        &#125;</span><br><span class="line">        arrCpy[j+<span class="number">1</span>] = temp <span class="comment">// 将值插入进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insertSort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">6</span>]) )</span><br></pre></td></tr></table></figure></li><li><p>选择排序</p><p>基本思路：每一次循环从数组中选择一个最小/大的数，并记录下标，在循环结束后交换位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> i,j,minIndex</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt;arrCpy.length - <span class="number">1</span> ;i++)&#123;</span><br><span class="line">    minIndex = i <span class="comment">// 保存初始下标</span></span><br><span class="line">        <span class="keyword">for</span>( j = i + <span class="number">1</span> ; j &lt; arrCpy.length ; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果找到比minIndex位置小的元素，则更新minIndex</span></span><br><span class="line">            <span class="keyword">if</span>(arrCpy[j] &lt; arrCpy[minIndex])&#123; </span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex !== i)&#123;</span><br><span class="line">            [arrCpy[i],arrCpy[minIndex]]=[arrCpy[minIndex],arrCpy[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrCpy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>交换排序</p><p>基本思路：每一次循环都对比两个数的大小，满足条件就进行交换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arrCpy.length <span class="number">-1</span> ; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span> ; j &lt; arrCpy.length ; j ++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[i] &gt; arrCpy[j])&#123;</span><br><span class="line">        [arrCpy[i], arrCpy[j]] = [arrCpy[j], arrCpy[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arrCpy.length  ; i++)&#123;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span> ; j&lt; arrCpy.length -i ; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arrCpy[j] &gt; arrCpy[j+<span class="number">1</span>])&#123;</span><br><span class="line">        [arrCpy[j],arrCpy[j+<span class="number">1</span>]] = [arrCpy[j+<span class="number">1</span>],arrCpy[j]]</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 如果没有进行过冒泡过程，说明数组已经有序</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希尔排序</p><p>属于插入排序的改进版本，需要选择合适增量，通过从数组中间元素开始向前的位置进行插入排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = array.slice()</span><br><span class="line">  <span class="keyword">const</span> length = arrCpy.length</span><br><span class="line">  <span class="comment">// 初始化间隔</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="comment">// 当间隔大于1时循环</span></span><br><span class="line">  <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 插入排序的起始位置从数组中间开始，每次都向后方移动一位，与前面对应间隔位置处进行插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 保存插入值</span></span><br><span class="line">      <span class="keyword">const</span> temp = arrCpy[i]</span><br><span class="line">      <span class="comment">// 从插入值i元素的前一个间隔位置开始与 插入值i 比较，如果大于则使用j以间隔向后覆盖</span></span><br><span class="line">      <span class="comment">// 如果遇到小值或者已经到达边界，退出，插入值到j的上一个位置</span></span><br><span class="line">      <span class="keyword">for</span> (j = i - gap; temp &lt; arrCpy[j] &amp;&amp; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">        arrCpy[j + gap] = arrCpy[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arrCpy[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gap减半继续循环</span></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(shellSort([<span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">123</span>, <span class="number">2352</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li><li><p>js快速排序</p><ul><li>目前最优的排序算法，O(n*log2 n)</li><li>改进版的冒泡排序，每经过一个循环，就确定一个元素在数组中所在的最终位置，不会再被位移</li><li>选择枢纽，使得枢纽左右相对平衡或者随机平衡</li><li>快速排序可以在一次大循环中（包含递归），找出某个元素的正确的位置，并且不需要再次移动</li><li>核心思想：分而治之，选择一个基数，将数组分为2部分，将小于基数的放在左边，大于基数的放在右边，由此可以得到基数最终的位置</li><li>选择一个枢纽，取头 中 尾元素中的一个中位数，例如头部第一个值为3 中部的值为8 尾部值为 1，则选择中部的8作为枢纽</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPivot</span> (<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取数组中部index</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">  <span class="comment">// 将前 中 后 三个元素进行排序并交换位置</span></span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">    [array[left], array[right]] = [array[right], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[left] &gt; array[center]) &#123;</span><br><span class="line">    [array[left], array[center]] = [array[center], array[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (array[center] &gt; array[right]) &#123;</span><br><span class="line">    [array[right], array[center]] = [array[center], array[right]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时得到有序的前 中 后 三个元素，中间的元素被选择为第一次递归的排序枢纽</span></span><br><span class="line">  <span class="comment">// 将中部元素与末尾元素的前一个元素进行交换，因为末尾元素在上面三元素排序的时候已经确定比枢纽元素的值大</span></span><br><span class="line">  [array[center], array[right - <span class="number">1</span>]] = [array[right - <span class="number">1</span>], array[center]]</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回处于倒数第二个位置的枢纽元素</span></span><br><span class="line">  <span class="keyword">return</span> array[right - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrCpy = array.slice(<span class="number">0</span>)</span><br><span class="line">  quick(arrCpy, <span class="number">0</span>, arrCpy.length - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> arrCpy</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick1</span> (<span class="params">array, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = getPivot(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">2</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot ) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[j] &gt; pivot ) &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick</span> (<span class="params">array, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 结束条件</span></span><br><span class="line">  <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 得到当前分组的枢纽</span></span><br><span class="line">  <span class="keyword">let</span> pivot = getPivot(array, low, high) <span class="comment">//得到枢纽，以及处于倒数第二个元素的子数组</span></span><br><span class="line">  <span class="comment">// 在寻找完枢纽后，三个以下的元素不用再继续排序，否则两两排序会出现问题</span></span><br><span class="line">  <span class="keyword">if</span>(high - low &lt;= <span class="number">2</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i = low</span><br><span class="line">  <span class="keyword">let</span> j = high - <span class="number">1</span>  <span class="comment">// 从当前子数组倒数第二个元素开始</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="comment">// 从低位到高位扫描，从最低位的后一位开始，当扫描元素值小于等于枢纽值则继续扫描，当扫描值大于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[++i] &lt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 跳出从低位到高位扫描后，从枢纽位的前一位开始，从高向低扫描，当扫描元素值大于等于枢纽值则继续扫描，当扫描值小于枢纽值，跳出</span></span><br><span class="line">    <span class="keyword">while</span> (array[--j] &gt; pivot ) &#123;&#125;</span><br><span class="line">    <span class="comment">// 当以上循环均跳出，且i和j没有穿过彼此(i是要小于j才说明扫描并未结束)，交换双方位置的值，否则，这一轮扫描与交换结束</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; j ) &#123;</span><br><span class="line">      [array[i], array[j]] = [array[j], array[i]]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果i与high -1 指向的不是同一个位置，则交换</span></span><br><span class="line">  <span class="keyword">if</span>(i !== high <span class="number">-1</span>)</span><br><span class="line">  [array[i], array[high - <span class="number">1</span>]] = [array[high - <span class="number">1</span>], array[i]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, low, i - <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">arguments</span>.callee(array, i + <span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="计算逆波兰式（后缀表达式）的值"><a href="#计算逆波兰式（后缀表达式）的值" class="headerlink" title="计算逆波兰式（后缀表达式）的值"></a>计算逆波兰式（后缀表达式）的值</h3><ul><li><p>使用递归方法 加 字符串拼接和eval(）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalRPN</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tokens.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^[+\-*\/]$/</span>.test(tokens[i])) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">`(<span class="subst">$&#123;tokens[i - <span class="number">2</span>]&#125;</span>)<span class="subst">$&#123;tokens[i]&#125;</span>(<span class="subst">$&#123;tokens[i - <span class="number">1</span>]&#125;</span>)`</span></span><br><span class="line">        tokens.splice(i - <span class="number">2</span>, <span class="number">3</span>, <span class="built_in">parseInt</span>(<span class="built_in">eval</span>(res)))</span><br><span class="line">        evalRPN(tokens)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tokens[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(evalRPN([<span class="string">&quot;4&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>]))</span><br></pre></td></tr></table></figure></li><li><p>栈方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalRPN2</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrCpy = tokens.slice(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> temp = []</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^[+\-*\/]$/</span></span><br><span class="line">  <span class="keyword">const</span> _operators = &#123;</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) + (+b),</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) - (+b),</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) * (+b),</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> (+a) / (+b),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (arrCpy.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reg.test(arrCpy[<span class="number">0</span>])) &#123;</span><br><span class="line">      temp.push(arrCpy.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> num2 = temp.pop()</span><br><span class="line">      <span class="keyword">const</span> num1 = temp.pop()</span><br><span class="line">      <span class="keyword">const</span> operator = arrCpy.shift()</span><br><span class="line">      temp.push(_operators[operator](num1, num2))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="转换数字为分隔格式"><a href="#转换数字为分隔格式" class="headerlink" title="转换数字为分隔格式"></a>转换数字为分隔格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paddingNum</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = number.toString()</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>) <span class="comment">//得到整数部分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = left.length - <span class="number">3</span>; i &gt; <span class="number">0</span> ; i -= <span class="number">3</span>) &#123; <span class="comment">//从倒数第三位开始，向前扫描，并插入逗号</span></span><br><span class="line">    left.splice(i, <span class="number">0</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回处理后的整数部分+小数部分</span></span><br><span class="line">  <span class="keyword">return</span> left.join(<span class="string">&#x27;&#x27;</span>).concat(arr[<span class="number">1</span>] ? <span class="string">&#x27;.&#x27;</span>+arr[<span class="number">1</span>]:<span class="string">&#x27;&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现数组扁平化"><a href="#递归实现数组扁平化" class="headerlink" title="递归实现数组扁平化"></a>递归实现数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">steamrollArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 扁平化，扁平化……</span></span><br><span class="line">  <span class="keyword">let</span> res= []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">      res.push(...steamrollArray(item)) <span class="comment">// 调用自身为了深入类型还是Array的元素，使用...为了将返回的数组类型的res进行解开作为上一个push的多个参数，依次递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(steamrollArray([<span class="number">1</span>, &#123;&#125;, [<span class="number">3</span>, [[<span class="number">4</span>]]]])) ;</span><br></pre></td></tr></table></figure><h3 id="实现斐波拉契数列"><a href="#实现斐波拉契数列" class="headerlink" title="实现斐波拉契数列"></a>实现斐波拉契数列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，n不能超过75025</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FibonacciArray</span>(<span class="params">n,a1=<span class="number">1</span>,a2=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span> a2;</span><br><span class="line">    <span class="keyword">return</span> FibonacciArray(n<span class="number">-1</span>,a2,a1+a2 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span> (<span class="params">n,f1=<span class="number">1</span>,f2=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">    f = f1 + f2</span><br><span class="line">    f1 = f2</span><br><span class="line">    f2 = f</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript正则表达式学习笔记</title>
      <link href="/2020/09/02/regexp/"/>
      <url>/2020/09/02/regexp/</url>
      
        <content type="html"><![CDATA[<h2 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h2><p>字符集放置在<code>[]</code>内部，要创建<code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置<code>插入字符</code>（即<code>^</code>）。</p><p>例如，<code>/[^aeiou]/gi</code>匹配所有非元音字符。注意，字符<code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code>和空白字符等也会被匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;3 blind mice.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myRegex = <span class="regexp">/[^0-9|aeiou]/gi</span>; <span class="comment">// 匹配数字以及元音以外的所有字符</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(myRegex); </span><br></pre></td></tr></table></figure><h2 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h2><p>匹配出现一次或者连续多次的的字符（或字符组）。它可能出现一次或者多次</p><p>使用<code>+</code>符号来检查情况是否如此。记住，字符或匹配模式必须一个接一个地连续出现。</p><p>例如，<code>/a+/g</code>会在<code>&quot;abc&quot;</code>中匹配到一个匹配项，并且返回<code>[&quot;a&quot;]</code>。因为<code>+</code>的存在，它也会在<code>&quot;aabc&quot;</code>中匹配到一个匹配项，然后返回<code>[&quot;aa&quot;]</code>。</p><p>如果它是检查字符串<code>&quot;abab&quot;</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。最后，因为在字符串<code>&quot;bcd&quot;</code>中没有<code>&quot;a&quot;</code>，因此找不到匹配项。</p><h2 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h2><p>创建一个变量为<code>chewieRegex</code>的正则表达式，使用<code>*</code>符号在<code>chewieQuote</code>中匹配<code>&quot;A&quot;</code>及其之后出现的零个或多个<code>&quot;a&quot;</code>。你的正则表达式不需要使用修饰符，也不需要匹配引号。</p><ul><li><p>你的正则表达式<code>chewieRegex</code>应该使用<code>*</code>符号匹配<code>&quot;A&quot;</code>之后出现的零个或多个<code>&quot;a&quot;</code>字符。</p></li><li><p>你的正则表达式<code>chewieRegex</code>应该匹配 16 个字符。</p></li><li><p>你的正则表达式应该匹配<code>&quot;Aaaaaaaaaaaaaaaa&quot;</code>。</p></li><li><p>你的正则表达式在<code>&quot;He made a fair move. Screaming about it can&#39;t help you.&quot;</code>中不应该匹配任何字符。</p></li><li><p>你的正则表达式在<code>&quot;Let him have it. It&#39;s not wise to upset a Wookiee.&quot;</code>中不应该匹配任何字符</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chewieQuote = <span class="string">&quot;Aaaaaaaaaaaaaaaarrrgh!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> chewieRegex = <span class="regexp">/Aa*/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = chewieQuote.match(chewieRegex);</span><br></pre></td></tr></table></figure><h2 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h2><p>在正则表达式中，<code>贪婪</code>匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为<code>懒惰</code>匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p><p>你可以将正则表达式<code>/t[a-z]*i/</code>应用于字符串<code>&quot;titanic&quot;</code>。这个正则表达式是一个以<code>t</code>开始，以<code>i</code>结束，并且中间有一些字母的匹配模式。</p><p>正则表达式默认是<code>贪婪</code>匹配，因此匹配返回为<code>[&quot;titani&quot;]</code>。它会匹配到适合该匹配模式的最大子字符串。</p><p>但是，你可以使用<code>?</code>字符来将其变成<code>懒惰</code>匹配。调整后的正则表达式<code>/t[a-z]*?i/</code>匹配字符串<code>&quot;titanic&quot;</code>返回<code>[&quot;ti&quot;]</code>。</p><h2 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h2><p>使用字符类，你可以使用<code>[a-z]</code>搜寻字母表中的所有字母。这种字符类是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p><p>JavaScript 中与字母表匹配的最接近的字符类是<code>\w</code>，这个缩写等同于<code>[A-Za-z0-9_]</code>。它不仅可以匹配大小写字母和数字，注意，它还会匹配下划线字符（<code>_</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串内英文句子的单词数</span></span><br><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly .&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> alphabetRegexV2 = <span class="regexp">/\w+/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(alphabetRegexV2).length;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h2 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h2><p>你已经了解到可以使用缩写<code>\w</code>来匹配字母和数字<code>[A-Za-z0-9_]</code>。不过，有可能你想要搜寻的匹配模式与字母数字相反。</p><p>你可以使用<code>\W</code>搜寻和<code>\w</code>相反的匹配模式。注意，相反匹配模式使用大写字母。此缩写与<code>[^A-Za-z0-9_]</code>是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quoteSample = <span class="string">&quot;The five boxing wizards jump quickly.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nonAlphabetRegex = <span class="regexp">/\W/g</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = quoteSample.match(nonAlphabetRegex).length; <span class="comment">// result = 6</span></span><br></pre></td></tr></table></figure><h2 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h2><p>查找非数字字符的缩写是<code>\D</code>。这等同于字符串<code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p><h2 id="案例：限制可能的用户名"><a href="#案例：限制可能的用户名" class="headerlink" title="案例：限制可能的用户名"></a>案例：限制可能的用户名</h2><p>你需要检查数据库中的所有用户名。以下是用户在创建用户名时必须遵守的一些简单规则。</p><ol><li><p>用户名中的数字必须在最后，且数字可以有零个或多个。</p></li><li><p>用户名字母可以是小写字母和大写字母。</p></li><li><p>用户名长度必须至少为两个字符。两位用户名只能使用字母。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;JackOfAllTrades&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> userCheck = <span class="regexp">/[a-z][a-z]\d*/i</span>;</span><br><span class="line"><span class="keyword">let</span> result = userCheck.test(username);</span><br></pre></td></tr></table></figure><h2 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h2><p>迄今为止的挑战包括匹配的字母和数字。你还可以匹配字母之间的空格。</p><p>你可以使用<code>\s</code>搜寻空格，其中<code>s</code>是小写。此匹配模式不仅匹配空格，还匹配回车符、制表符、换页符和换行符，你可以将其视为与<code>[\r\t\f\n\v]</code>类似。</p><h2 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h2><p>回想一下，你使用加号<code>+</code>查找一个或多个字符，使用星号<code>*</code>查找零个或多个字符。这些都很方便，但有时你需要匹配一定范围的匹配模式。</p><p>你可以使用<code>数量说明符</code>指定匹配模式的上下限。数量说明符与花括号（<code>&#123;</code>和<code>&#125;</code>）一起使用。你可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p><p>例如，要在字符串<code>&quot;ah&quot;</code>中匹配仅出现<code>3</code>到<code>5</code>次的字母<code>a</code>，你的正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p><ul><li>匹配在<code>&quot;Oh no&quot;</code>中仅出现<code>3</code>到<code>6</code>次的字母<code>h</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ohStr = <span class="string">&quot;Ohhh no&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> ohRegex = <span class="regexp">/Oh&#123;3,6&#125; no/</span>;</span><br><span class="line"><span class="keyword">let</span> result = ohRegex.test(ohStr);</span><br></pre></td></tr></table></figure><h2 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h2><p>你可以使用带有花括号的<code>数量说明符</code>来指定匹配模式的上下限。但有时你只需要特定数量的匹配。</p><p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p><p>例如，要只匹配字母<code>a</code>出现<code>3</code>次的单词<code>&quot;hah&quot;</code>，你的正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p><h2 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h2><p>有时，你想要搜寻的匹配模式可能有不确定是否存在的部分。尽管如此，你还是想检查它们。</p><p>为此，你可以使用问号<code>?</code>指定可能存在的元素。这将检查前面的零个或一个元素。你可以将此符号视为前面的元素是可选的</p><ul><li>匹配美式英语（favorite）和英式英语（favourite）的单词版本。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favWord = <span class="string">&quot;favorite&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> favRegex = <span class="regexp">/favou?rite/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = favRegex.test(favWord);</span><br></pre></td></tr></table></figure><h2 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h2><p><strong>先行断言</strong>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这非常有用。</p><p>有两种先行断言方式：<code>正向先行断言</code>和<code>负向先行断言</code></p><p><strong>正向先行断言</strong>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分，每个<code>(?=...)</code>都是一个对整个测试对象的测试规则，</p><p>另一方面，<strong>负向先行断言</strong>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p><ul><li><p><strong>先行断言</strong>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> checkPass = <span class="regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span>;</span><br><span class="line">checkPass.test(password); <span class="comment">// Returns true</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>先行断言</strong>以匹配至少5个字符且有两个连续数字的密码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">&quot;astronaut&quot;</span>;</span><br><span class="line"><span class="comment">// \D* 匹配前面多个非数字字符，这2个(?=) 为串行匹配，意思为，先通过第一个(?=)，然后再通过第二个(?=)，每个</span></span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;5,&#125;)(?=\D*\d&#123;2,&#125;)/</span>; </span><br><span class="line"><span class="keyword">let</span> result = pwRegex.test(sampleWord);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组重用模式（重要）"><a href="#使用捕获组重用模式（重要）" class="headerlink" title="使用捕获组重用模式（重要）"></a>使用捕获组重用模式（重要）</h2><p>如果要搜寻的匹配模式会在字符串中出现多次，那么手动重复该正则表达式不是一个高效的方法。此时就需要用到<strong>捕获组</strong></p><p>你可以使用<strong>捕获组</strong>搜寻重复的子字符串。括号<code>(</code>和<code>)</code>可以用来匹配重复的子字符串。你只需要把重复匹配模式的正则表达式放在括号中即可。</p><p>要指定重复字符串将出现的位置，可以使用反斜杠（<code>\</code>）后接一个数字。这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。这里有一个示例，<code>\1</code>可以匹配第一个组。</p><p>下面的示例匹配任意两个被空格分割的单词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatStr = <span class="string">&quot;regex regex&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> repeatRegex = <span class="regexp">/(\w+)\s\1/</span>; <span class="comment">// </span></span><br><span class="line">repeatRegex.test(repeatStr); <span class="comment">// Returns true</span></span><br><span class="line">repeatStr.match(repeatRegex); <span class="comment">// Returns [&quot;regex regex&quot;, &quot;regex&quot;]</span></span><br></pre></td></tr></table></figure><ul><li>此处的\1 为占位符，复用一号位<code>(\w+)</code>匹配到的值作为规则在当前位置进行检测</li><li><code>(\w+)</code> 捕获到第一个单词<code>regex</code> ，那么后面的\1就以这个<code>regex</code>作为当前\1所在位置的规则进行匹配</li></ul><p>在字符串上使用<code>.match()</code>方法将返回一个数组，其中包含它匹配的字符串及其捕获组。</p><ul><li><p>在正则表达式<code>reRegex</code>中使用<code>捕获组</code>，以匹配在字符串中仅重复三次的数字，每一个都由空格分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">&quot;42 42 42&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex =  <span class="regexp">/^(\d+)\s\1\s\1$/</span>; <span class="comment">//使用开头^和结尾$来包裹表达式模板进行严格匹配,\1处复用第一个匹配到的值作为规则</span></span><br><span class="line"><span class="keyword">let</span> result = reRegex.test(repeatNum);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h2><p>搜索功能是很有用的。但是，当你的搜索也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p><p>可以使用字符串上<code>.replace()</code>方法来搜索并替换字符串中的文本。<code>.replace()</code>的输入首先是你想要搜索的正则表达式匹配模式，第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrongText = <span class="string">&quot;The sky is silver.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> silverRegex = <span class="regexp">/silver/</span>;</span><br><span class="line">wrongText.replace(silverRegex, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;The sky is blue.&quot;</span></span><br></pre></td></tr></table></figure><p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Code Camp&quot;</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>);</span><br><span class="line"><span class="comment">// Returns &quot;Camp Code&quot;</span></span><br></pre></td></tr></table></figure><h2 id="案例：删除开头和结尾的空白"><a href="#案例：删除开头和结尾的空白" class="headerlink" title="案例：删除开头和结尾的空白"></a>案例：删除开头和结尾的空白</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;   Hello, World!  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> wsRegex = <span class="regexp">/^\s+|\s+$/g</span>; <span class="comment">// 匹配多个空格开头和结尾的多个空格</span></span><br><span class="line"><span class="keyword">let</span> result = hello.replace(wsRegex,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="案例：验证或者匹配文本中的邮箱"><a href="#案例：验证或者匹配文本中的邮箱" class="headerlink" title="案例：验证或者匹配文本中的邮箱"></a>案例：验证或者匹配文本中的邮箱</h2><ul><li><p>匹配出邮箱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;my email is  ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = email.match(emailRegex)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  index: <span class="number">13</span>,</span><br><span class="line">  input: <span class="string">&#x27;my email is  ljp123456@sina.com&#x27;</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>验证邮箱格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">&quot;ljp123456@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> emailRegex = <span class="regexp">/^\w&#123;5,16&#125;@\D&#123;2,&#125;.[com|net|org|cn]$/</span>; <span class="comment">// 修改这一行</span></span><br><span class="line"><span class="keyword">let</span> result = emailRegex.test(email)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li></ul><h2 id="案例：短线连接格式转换"><a href="#案例：短线连接格式转换" class="headerlink" title="案例：短线连接格式转换"></a>案例：短线连接格式转换</h2><p>在这道题目中，我们需要写一个函数，把一个字符串转换为“短线连接格式”。短线连接格式的意思是，所有字母都是小写，且用<code>-</code>连接。比如，对于<code>Hello World</code>，应该转换为<code>hello-world</code>；对于<code>I love_Javascript-VeryMuch</code>，应该转换为<code>i-love-javascript-very-much</code>。</p><ul><li><p><code>spinalCase(&quot;This Is Spinal Tap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;thisIsSpinalTap&quot;)</code>应该返回<code>&quot;this-is-spinal-tap&quot;</code>。</p></li><li><p><code>spinalCase(&quot;The_Andy_Griffith_Show&quot;)</code>应该返回<code>&quot;the-andy-griffith-show&quot;</code>。</p></li><li><p><code>spinalCase(&quot;Teletubbies say Eh-oh&quot;)</code>应该返回<code>&quot;teletubbies-say-eh-oh&quot;</code>。</p></li><li><p><code>spinalCase(&quot;AllThe-small Things&quot;)</code>应该返回<code>&quot;all-the-small-things&quot;</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spinalCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = str.replace(<span class="regexp">/^\s+|\s+$/</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  temp = (temp.charAt(<span class="number">0</span>).toUpperCase() + temp.substring(<span class="number">1</span>)) <span class="comment">//将字符串头部</span></span><br><span class="line">    .replace(<span class="regexp">/[\-]/g</span>,<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">    .match(<span class="regexp">/\w+/g</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item.charAt(<span class="number">0</span>).toUpperCase() + item.substring(<span class="number">1</span>))</span><br><span class="line">    .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    .match(<span class="regexp">/[A-Z][a-z]+/g</span>)</span><br><span class="line">    .join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    .toLowerCase()</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spinalCase(<span class="string">&#x27;This Is Spinal Tap&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="儿童黑话"><a href="#儿童黑话" class="headerlink" title="儿童黑话"></a>儿童黑话</h2><p>我们需要写一个函数，把传入的字符串翻译成“儿童黑话”。</p><p><a href="http://en.wikipedia.org/wiki/Pig_Latin">儿童黑话</a>的基本转换规则很简单，只需要把一个英文单词的第一个辅音字母或第一组辅音从移到单词的结尾，并在后面加上<code>ay</code>即可。在英语中，字母 a、e、i、o、u 为元音，其余的字母均为辅音。辅音从的意思是连续的多个辅音字母。</p><p>额外地，如果单词本身是以元音开头的，那只需要在结尾加上<code>way</code>。</p><p>在本题中，传入的单词一定会是英文单词，且所有字母均为小写。</p><ul><li><p><code>translatePigLatin(&quot;california&quot;)</code>应该返回 “aliforniacay”。</p></li><li><p><code>translatePigLatin(&quot;paragraphs&quot;)</code>应该返回 “aragraphspay”。</p></li><li><p><code>translatePigLatin(&quot;glove&quot;)</code>应该返回 “oveglay”。</p></li><li><p><code>translatePigLatin(&quot;algorithm&quot;)</code>应该返回 “algorithmway”。</p></li><li><p><code>translatePigLatin(&quot;eight&quot;)</code>应该返回 “eightway”。</p></li><li><p>你的代码应当能够处理第一个元音字母在单词结尾的情况。比如<code>translatePigLatin(&quot;she&quot;)</code>应该返回 “eshay”。</p></li><li><p>你的代码应当能够处理单词中不含元音字母的情况。比如<code>translatePigLatin(&quot;rhythm&quot;)</code>应该返回 “rhythmay”。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translatePigLatin</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = str.match(<span class="regexp">/[aeiou]\w*/</span>) <span class="comment">// 匹配元音开头且后续字母出现0次或多次的片段</span></span><br><span class="line">  <span class="keyword">let</span> b = str.match(<span class="regexp">/^[^aeiou]+/</span>) <span class="comment">// 匹配以元音字母开头且后续至少一次的片段</span></span><br><span class="line">  <span class="comment">// 如果是以字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^[aeiou]+/</span>.test(str) ? str + <span class="string">&#x27;way&#x27;</span> : (a ? a : <span class="string">&#x27;&#x27;</span>) + (b ? (b + <span class="string">&#x27;ay&#x27;</span>) : <span class="string">&#x27;way&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">translatePigLatin(<span class="string">&quot;consonant&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p>我们需要写一个字符串的搜索与替换函数，它的返回值为完成替换后的新字符串。</p><p>这个函数接收的第一个参数为待替换的句子。第二个参数为句中需要被替换的单词。第三个参数为替换后的单词。</p><p><strong>注意：</strong><br>需要保留被替换单词首字母的大小写格式。即如果传入的第二个参数为 “Book”，第三个参数为 “dog”，那么替换后的结果应为 “Dog”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReplace</span> (<span class="params">str, before, after</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;before&#125;</span>`</span>, <span class="string">&#x27;gi&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z]/</span>.test(str.match(regExp)[<span class="number">0</span>].charAt(<span class="number">0</span>)) ?</span><br><span class="line">    str.replace(regExp, after.charAt(<span class="number">0</span>).toUpperCase() + after.slice(<span class="number">1</span>))</span><br><span class="line">    :</span><br><span class="line">    str.replace(regExp, after)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myReplace(<span class="string">&#x27;He is Sleeping on the couch&#x27;</span>, <span class="string">&#x27;Sleeping&#x27;</span>, <span class="string">&#x27;sitting&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器的基本使用</title>
      <link href="/2020/09/02/docker/"/>
      <url>/2020/09/02/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器的基本使用"><a href="#Docker容器的基本使用" class="headerlink" title="Docker容器的基本使用"></a>Docker容器的基本使用</h1><h2 id="Docker的基本架构"><a href="#Docker的基本架构" class="headerlink" title="Docker的基本架构"></a>Docker的基本架构</h2><p>关键字：</p><ul><li><p>Dockerfiles：Docker本身的配置文件，配置如何构建容器以及镜像，和端口</p></li><li><p>Image：虚拟系统的镜像</p></li><li><p>DockerContainer(容器)：镜像运行的虚拟环境，类似虚拟机</p></li><li><p>镜像仓库：虚拟系统的基本镜像，或者已保存的镜像</p></li></ul><h2 id="Docker的基本指令"><a href="#Docker的基本指令" class="headerlink" title="Docker的基本指令"></a>Docker的基本指令</h2><ul><li><p>查看当前<code>运行的/所有的</code>镜像</p><blockquote><p>docker ps </p><p>docker ps -a</p></blockquote></li><li><p>从仓库拉取原始镜像，以Nginx为例</p><blockquote><p>docker pull nginx</p></blockquote></li><li><p>查看所有镜像：</p><blockquote><p>docker images</p></blockquote></li><li><p>在使用一个镜像，在后台创建并运行一个容器，并添加镜像别名以及进行端口映射：</p><blockquote><p>docker run –name testNginx -p 80:80 -d nginx</p></blockquote></li><li><p>在后台创建并运行一个容器，并将<code>宿主主机指定目录</code>映射到<code>容器的指定目录</code></p><ul><li>将宿主主机下的<code>/home/index</code> 文件夹映射到 容器的<code>/usr/share/nginx/html</code>文件夹中</li><li>当前文件夹使用<code>pwd</code></li></ul><blockquote><p>docker run –name mappedNginx -p 8080:80 -d  -v /home/index:/usr/share/nginx/html nginx(镜像名)</p></blockquote></li><li><p>进入一个正在运行的容器：</p><blockquote><p>docker exec -it 镜像id bash</p></blockquote></li><li><p>运行/停止/重启一个容器</p><blockquote><p>docker start/stop/restart 容器ID</p></blockquote></li><li><p>提交某个镜像为新镜像</p><blockquote><p>docker commit 镜像id 新镜像名</p></blockquote></li><li><p>从容器里面拷贝文件到宿主主机</p><blockquote><p>docker cp 容器名：要拷贝的文件在容器里面的路径  要拷贝到宿主机的相应路径</p></blockquote><ul><li><p>例：容器名为1d1d,从容器里/cert路径下，将nginx.zip从容器里面拷到宿主机的/var/backup路径下面<br>在宿主机上执行命令： </p><p><code>docker cp 1d1d:/cert/nginx.zip /var/backup</code></p></li></ul></li></ul><ul><li><p>从宿主主机拷贝文件到容器中</p><blockquote><p>docker cp 要拷贝的文件路径  容器名：要拷贝到容器里面对应的路径</p></blockquote><ul><li>例：假设容器名为68b99,现在要将宿主机<code>/var/backup/nginx.zip</code>文件拷贝到容器里面的/cert路径下面   在宿主机上执行命令：<code>docker cp /var/backup/nginx.zip 68b99:/cert</code></li></ul></li><li><p>将一个镜像保存到本地文件中</p><blockquote><p>docker save 镜像名称 &gt;自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>从文件恢复镜像</p><blockquote><p>docker load  &lt; 自定义镜像文件名.tar或者zip</p></blockquote></li><li><p>删除docker镜像</p><blockquote><p>docker rmi 镜像名称</p></blockquote></li></ul><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>进入镜像后，默认网页文件在<code>/usr/share/nginx/html</code>下</p><ul><li><p>使用Dockerfile以指定文件创建一个Nginx镜像，并运行</p><ul><li><p>使用vim新建一个dockerfile文件，指定使用的镜像，将当前路径下的所有文件拷贝到目标nginx环境的html目录下</p><blockquote><p>vim dockerfile</p><p>进入编辑</p><p>FROM nginx</p><p>ADD ./  /usr/share/nginx/html  </p></blockquote></li><li><p>使用命令构建一个镜像</p><blockquote><p>docker build -t 自定义镜像名 </p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 模块化规范对比</title>
      <link href="/2020/09/02/javascript_modul/"/>
      <url>/2020/09/02/javascript_modul/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h1><ul><li>避免变量命名冲突</li><li>更好的分离</li><li>更高的维护性</li><li>高可维护性<h1 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h1>全局模式：直接在js模块文件中声明变量    外界能够随意修改其值，不安全<br>命名空间模式：在js模块文件中均为封装的对象  外界能够随意修改其值，不安全<br>IIFE匿名函数自调用模式(闭包)：js模块文件中使用一个立即执行函数进行包装，在内部暴露相应函数，立即执行的函数参数可以为window <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.model1 = &#123;foo&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>IIFE增强模式：在IIFE基础上 在立即函数的参数中加入代码依赖，例如使用jQuery<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,$</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeBg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;body&#x27;</span>).css(&#123;</span><br><span class="line">            background : <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.model1 = &#123;changeBg&#125;; <span class="comment">// 将函数以对象形式传入到window对象的属性中，等价于&#123;foo：foo&#125;</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>,jQuery)</span><br></pre></td></tr></table></figure><h2 id="原生JS进行模块化"><a href="#原生JS进行模块化" class="headerlink" title="原生JS进行模块化"></a>原生JS进行模块化</h2>使用原生的JS，以匿名函数自调用模式(闭包)的形式进行模块化，实参括号内的参数均为window对象内部属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js ，没有任何依赖的模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用window将getMessage进行暴露</span></span><br><span class="line">    <span class="built_in">window</span>.message = &#123;getMessage&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">//module2.js，依赖于获取数据的module1.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,message</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message!&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">logMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message.getMessage())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.showMessage = &#123; logMessage &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, message)</span><br><span class="line"><span class="comment">//主模块msg.js，将使用module2.js和module1.js,不需要使用window来暴露模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">showMessage</span>)</span>&#123;</span><br><span class="line">    showMessage.logMessage();</span><br><span class="line">&#125;)(showMessage)</span><br></pre></td></tr></table></figure>原生JS的模块引用必须严格遵守模块的引用顺序<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/module2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>NodeJS使用此语法规范，不存在顶级对象window</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>每一个文件都可以当做一个模块<br>服务器(NodeJS)端的模块都是运行时同步加载的<br>浏览器端的模块需要提交打包处理  </p><h4 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>暴露模块本质是吧所有对象的引用保存在exports对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = value</span><br><span class="line"><span class="built_in">exports</span>.fun1 = fun1</span><br></pre></td></tr></table></figure><h4 id="引入并模块"><a href="#引入并模块" class="headerlink" title="引入并模块"></a>引入并模块</h4><p>第三方模块直接传入模块名，自定义则传入相对路径，注意，CommandJs中，需要等待require加载完模块后，才能往后执行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="built_in">require</span>(相对路径/模块名);</span><br><span class="line"><span class="built_in">module</span>.fun1();</span><br></pre></td></tr></table></figure><h2 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h2><p>全名为 异步模块定义 </p><h3 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a>规范</h3><p>专用于浏览器端，模块的加载是异步的</p><h4 id="定义暴露模块"><a href="#定义暴露模块" class="headerlink" title="定义暴露模块"></a>定义暴露模块</h4><p>定义不存在依赖关系的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义有依赖的模块,传入依赖模块名数组、回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入依赖模块名，将依赖的模块注入到回调函数参数中</span></span><br><span class="line">defind([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//通过参数使用模块 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="AMD规范引入模块实例-需要在lib文件夹下引入Require-js"><a href="#AMD规范引入模块实例-需要在lib文件夹下引入Require-js" class="headerlink" title="AMD规范引入模块实例(需要在lib文件夹下引入Require.js)"></a>AMD规范引入模块实例(需要在lib文件夹下引入Require.js)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义无依赖的模块 module1.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;this is a message&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暴露一个对象，内容为一个函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getMessage&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义依赖于module1.js 的 module2.js</span></span><br><span class="line">define(<span class="string">&#x27;module1&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(module1.getMessage())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;showMessage&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  定义主模块，引用2个子模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    requirejs([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module1, module2 </span>)</span>&#123;</span><br><span class="line">        module2.showMessage();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="ES6规范"><a href="#ES6规范" class="headerlink" title="ES6规范"></a>ES6规范</h2><h3 id="规范-2"><a href="#规范-2" class="headerlink" title="规范"></a>规范</h3><p>ES6的依赖模块需要编译打包处理，常使用webpack进行打包</p><h4 id="暴露模块-1"><a href="#暴露模块-1" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>均为暴露一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">export</span> &#123;fun1,fun2, ...&#125;</span><br><span class="line"><span class="comment">//默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//默认暴露一个箭头函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="comment">//默认暴露普通函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="引入模块-1"><a href="#引入模块-1" class="headerlink" title="引入模块"></a>引入模块</h4><p>引入一般暴露的模块均使用对象形式解构赋值<br>引入默认暴露的模块可自定义引用名 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;fun1&#125; <span class="keyword">from</span> <span class="string">&#x27;模块js相对路径&#x27;</span></span><br><span class="line"><span class="keyword">import</span> arrowFunc <span class="keyword">from</span> <span class="string">&#x27;默认暴露模块js相对路径&#x27;</span></span><br><span class="line">fun1()</span><br><span class="line">arrowFunc()</span><br></pre></td></tr></table></figure><p>注意在HTML中引入的时候，需要将脚本标签类型设定为module</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./src/js/msg.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><p>写入@ 注释以给编译器加上参数提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绿茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>一杯绿茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> prepareGreenTea = <span class="function">() =&gt;</span> <span class="string">&#x27;greenTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备红茶准备过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>一杯红茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> prepareBlackTea = <span class="function">() =&gt;</span> <span class="string">&#x27;blackTea&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一定数量的茶</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function():string&#125;</span> </span>prepareTea 茶的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>numOfCups 需要茶的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&lt;string&gt;&#125;</span> </span>给定的茶</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> getTea = <span class="function">(<span class="params">prepareTea, numOfCups</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> teaCups = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> cups = <span class="number">1</span>; cups &lt;= numOfCups; cups += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> teaCup = prepareTea();</span><br><span class="line">    teaCups.push(teaCup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> teaCups;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript模块 </tag>
            
            <tag> 模块化规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6-8 常见新特性</title>
      <link href="/2020/09/02/ES6-8/"/>
      <url>/2020/09/02/ES6-8/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6-8-特性"><a href="#ES6-8-特性" class="headerlink" title="ES6-8 特性"></a>ES6-8 特性</h1><p>本文将总结一ECMAScript 6-8 的常用新特性</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>在ES6之前使用<code>var</code>关键字来声明变量，会出现重复声明导致变量被覆盖却不会报错的问题，且使用<code>var</code>声明的变量会被提升到最前进行解析，使用function声明的函数次之</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(camper);</span><br><span class="line"><span class="comment">// 打印出 &#x27;David&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br><span class="line"><span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><p>与<code>var</code>不同的是，当使用ES6新增的<code>let</code>来声明变量时，没有变量提升，且同一名字的变量只能被声明一次，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;James&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> camper = <span class="string">&#x27;David&#x27;</span>;</span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;camper&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="comment">//输出错误 Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>let 声明的变量在{} （花括号）中参数局部作用域，作业是不会污染其他作用域，不会影响作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> i  = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"><span class="comment">// 输出错误 Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p><code>const</code> 为 英文 <code>constant</code>的简写，其意为常量</p><p>使用<code>const</code>声明的常量拥有以下规则：</p><ul><li>常量一定要赋初值</li><li>与let一样产生块级作用域</li><li>常量名称一般为全大写字母</li><li>常量值不能修改，对象或者数组类型可修改内部数据，这意味着使用<code>const</code>声明的引用常量在堆内存中的地址不能发生变化</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li><p>数组解构</p><p>在 ES6 里面，解构数组可以如同解构对象一样简单。与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。所以，你不能选择哪个元素来给变量赋值，而对数组进行解构却可以让我们做到这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1, 2</span></span><br><span class="line"><span class="comment">//变量a以及b分别被数组的第一、第二个元素赋值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b,,, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1, 2, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不通过第三个变量交换二者的值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">8</span>, b = <span class="number">6</span>;</span><br><span class="line">[a,b] = [b,a]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 应该等于 6</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 应该等于 8</span></span><br></pre></td></tr></table></figure></li><li><p>对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name,age,getName&#125; = obj</span><br></pre></td></tr></table></figure></li><li><p>用于函数传参，这里也使用了ES6的新特性，参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connent</span>(<span class="params">&#123;host=<span class="string">&quot;&quot;</span>,username=<span class="string">&quot;初始值&quot;</span>,password,port&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(host,username,password,port)</span><br><span class="line">&#125;</span><br><span class="line">connect(&#123;</span><br><span class="line">    host:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    username:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    port:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在某些情况下，你可以在函数的参数里直接解构对象，这样的操作去除了多余的代码，使代码更加整洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">profileData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的操作解构了传给函数的对象。这样的操作也可以直接在参数里完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> profileUpdate = <span class="function">(<span class="params">&#123; name, age, nationality, location &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 对这些参数执行某些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样做还有个额外的好处：函数不需要再去操作整个对象，而仅仅是操作复制到函数作用域内部的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">     start: &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">y</span>: <span class="number">6</span>&#125;,</span><br><span class="line">     end: &#123; <span class="attr">x</span>: <span class="number">6</span>, <span class="attr">y</span>: <span class="number">-9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">start</span> : &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125;&#125; = a;</span><br><span class="line"><span class="built_in">console</span>.log(startX, startY); <span class="comment">// 5, 6</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的例子里，<code>a.start</code>将值赋给了变量<code>start</code>，<code>start</code>同样也是个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用解构赋值来得到forecast.tomorrow的max，并将其赋值给maxOfTomorrow。</span></span><br><span class="line"><span class="keyword">const</span> LOCAL_FORECAST = &#123;</span><br><span class="line">  today: &#123; <span class="attr">min</span>: <span class="number">72</span>, <span class="attr">max</span>: <span class="number">83</span> &#125;,</span><br><span class="line">  tomorrow: &#123; <span class="attr">min</span>: <span class="number">73.3</span>, <span class="attr">max</span>: <span class="number">84.6</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxOfTmrw</span>(<span class="params">forecast</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 在这行以下修改代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">tomorrow</span>:&#123;<span class="attr">max</span>:maxOfTomorrow&#125;&#125; = forecast; <span class="comment">// 改变这一行</span></span><br><span class="line">  <span class="comment">// 在这行以上修改代码</span></span><br><span class="line">  <span class="keyword">return</span> maxOfTomorrow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getMaxOfTmrw(LOCAL_FORECAST)); <span class="comment">// 应该为 84.6</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h2><p>如果在对象内赋值中发现属性名和属性值变量名称相同，则直接使用属性名即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    apple,</span><br><span class="line">    banana,</span><br><span class="line">    getFruit()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrowFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arrowFunc2 = <span class="function">() =&gt;</span> (<span class="comment">/*返回的内容*/</span>)</span><br></pre></td></tr></table></figure><ul><li>箭头函数内部的this始终指向在声明时的作用域中的this，且<code>this</code>不可被<code>call()`` bind()`` apply()</code> 更改，通常应用于计时器(因为计时器中的this指向的是windows) 以及 定义类中的函数</li><li>内部没有arguments伪数组，意味着不能使用<code>arguments.callee()</code>方法进行自调用</li><li>当内部代码只有return语句时候，return可省略，使用()包裹返回的内容，但执行的代码使用{} 包裹</li></ul><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 在函数中引入 rest参数， 用于获取函数实参，代替arguments </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    args.forEach() <span class="comment">//arg作为一个数组，将传入的参数收入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>ES6 提供了一个新的创建对象的语法，使用关键字<code>class</code>。</p><p>值得注意的是，<code>class</code>只是一个语法糖，它并不像 Java、Python 这一类的语言一样，严格履行了面向对象的开发规范。</p><p>ES6 之前由原型链来进行对象的继承于重用，在构造函数的显式原型上添加公共方法，使用new 来实例化对象，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SpaceShuttle = <span class="function"><span class="keyword">function</span>(<span class="params">targetPlanet</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.targetPlanet = targetPlanet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>class</code>的语法只是简单地替换了构造函数的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShuttle</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(targetPlanet)&#123;</span><br><span class="line">  <span class="built_in">this</span>.targetPlanet = targetPlanet;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zeus = <span class="keyword">new</span> SpaceShuttle(<span class="string">&#x27;Jupiter&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意<code>class</code>关键字声明了一个新的函数，并在其中添加了一个会在使用<code>new</code>关键字创建新对象时调用的构造函数。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在ES5 中，我们常常用到<strong>组合继承</strong>来实现父子间的继承，即使用原型链继承的方式继承父类的方法，使用借用构造函数的方式继承父级的属性，最后再将子类原型的构造器指向自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand,price</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmartPhone</span>(<span class="params">brand,price,os,color</span>)</span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>,brand,price);</span><br><span class="line">    <span class="built_in">this</span>.os = os;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置子类的构造函数原型</span></span><br><span class="line">SmartPhone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>)</span><br></pre></td></tr></table></figure><p>ES6中的使用类继承，<code>super()</code>方法<strong>只能</strong>在constructor函数中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand,price)&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price</span><br><span class="line">    &#125;</span><br><span class="line">    call()&#123;</span><br><span class="line">       <span class="comment">//打电话函数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand,price,os,color)&#123;</span><br><span class="line">        <span class="built_in">super</span>(brand,price)</span><br><span class="line">        <span class="built_in">this</span>.os = os;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    Photo()&#123;</span><br><span class="line">        <span class="comment">//子类拍照函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iPhone = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">1000</span>,<span class="string">&#x27;iOS&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>ES6 子类对父类方法重写：直接在子类中添加与父类的同名函数即可</p></li><li><p>ES6 类实例的get和set</p><ul><li><p>get和set方法时默认缺省的，如果声明了<code>get/set 变量名()&#123;&#125;</code>函数，则在读取或修改某个变量时时，都会调用一次该变量的<code>get</code>或<code>set</code>,在<code>get</code>中可以操控返回值，在<code>set</code>中可以操控修改的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(brand)&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">brand</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;读取品牌信息&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">brand</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;设置品牌信息&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> Phone()</span><br><span class="line">iPhone.brand = <span class="string">&#x27;Apple&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES6 对象方法扩展</p><ul><li>判断两个数值是否相等：<code>Object.is(a,b)</code></li><li>合并对象：<code>Object.assign(dstObj,srcObj)</code>，源对象会将属性合并到目标对象中，且覆盖目标对象相同的属性值</li><li>设置对象的隐式原型：<code>Object.setPrototypeOf(dstObj,srcObj)</code>,将源对象设置为目标对象的隐式原型<code>__proto__</code></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在class声明的类中，使用<code>static</code>声明的方法将不能被class所创建的实例所调用，只能通过class本身进行调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> staticMethod()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Father.staticMethod()</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><ul><li><p>ES6之前，在构造函数上添加属性，其属性属于函数对象，并不属于构造函数本身，由此构造函数构造的对象不能得到构造函数对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Phone.name = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">Phone.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)=&gt;</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> iPhone = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(iPhone.name) <span class="comment">//无法输出</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在ES6的类中，添加静态方法只需要将前缀改为<code>ststic</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"><span class="keyword">static</span> call()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Phone.name) <span class="comment">//只能通过此形式访问静态属性</span></span><br></pre></td></tr></table></figure><p>继承：</p></li></ul><h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><p>将伪数组转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> divsArray = [...divs];</span><br></pre></td></tr></table></figure><h2 id="ES6的模块引入方式"><a href="#ES6的模块引入方式" class="headerlink" title="ES6的模块引入方式"></a>ES6的模块引入方式</h2><p>在过去，我们会使用<code>require()</code>函数来从外部文件或模块中引入函数或者代码。这时候会遇到一个问题：有些文件或者模块会特别大，但你却往往只需要引入其中的一些核心代码。</p><p>ES6 给我们提供了<code>import</code>这个便利的工具。通过它，我们能够从外部的文件或者模块中选择我们需要的部分进行引入，从而节约载入的时间和内存空间。</p><p>ES6 同样提供的 <code>export</code> / <code>export default</code>  关键字 来暴露一个模块的方法或者变量，具体使用方式请查阅MDN文档</p><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><ul><li><p>在js文件中使用<code>export</code> / <code>export default</code>暴露函数</p></li><li><p>在html文件中使用： 使用模块的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> * <span class="keyword">as</span> module1 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//可使用as 进行重命名</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123;xxx&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//解构赋值</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> module3&#125; <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//将默认暴露的模块在使用时重命名</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> module4 <span class="keyword">from</span> <span class="string">&quot;./xxx.js&quot;</span> <span class="comment">//直接使用，只能针对默认暴露的模块</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>暴露模块的三种方式：</p><ol><li><code>export xxx</code></li><li><code>export &#123;a,b,c,...&#125;</code></li><li><code>export default &#123;&#125;</code> ，访问时多一层default</li></ol></li><li><p>使用入口js文件</p><ul><li>创建一个<code>app.js</code> 文件，并在html中引入这个作为模块的js文件</li><li>在<code>app.js</code> 文件中引入其他的模块，并使用</li></ul></li><li><p>兼容性：使用<code>babel</code>将 ES6 转换为 ES5 语法</p><ul><li>需要使用npm安装<code>babel-cli</code> <code>babel-present-env</code> <code>browserify(webpack)</code> </li><li>运行<code>npx babel 源js文件/文件夹 目的js文件/文件夹</code></li><li>使用入口文件将一些列模块文件进行打包：<code>npx browserify 源入口js文件 -o 目标入口js文件 </code></li></ul></li></ul><h2 id="Symbol-基本数据类型"><a href="#Symbol-基本数据类型" class="headerlink" title="Symbol 基本数据类型"></a>Symbol 基本数据类型</h2><ul><li>ES6引入的第七个基本数据类型，标识独一无二的值，类似于字符串</li><li>symbol 的值是唯一的，用来解决命名冲突问题</li><li>symbol不能与其他数据进行任何运算，只能进行相等判断</li><li>symbol定义的对象属性不能使用<code>for ... in ...</code> 来遍历，但是可以使用<code>reflect.ownKeys()</code> 来获取key</li><li>使用场景：<ul><li>为对象添加独一无二的值/函数,避免冲突</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>Iterator</strong>是一种接口，为不同 数据结构提供同一的访问机制，任何数据结构只要部署<code>Iterator</code>接口皆可以完成遍历操作 </p><p>每个可迭代的数据类型的实例的隐式原型中都包含一个<code>Symbol(Symbol.iterator)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FRUIT = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = FRUIT[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value:&#x27;apple&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:&#x27;banana&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:&#x27;orange&#x27;,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())<span class="comment">// &#123;value:undefined&#x27;,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>自定义遍历对象：</p><p>自定义一个对象中的迭代器，迭代指定部分的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    type:<span class="string">&#x27;fruit&#x27;</span>,</span><br><span class="line">    name:[<span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;banana&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">         ],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="built_in">this</span>.name.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="built_in">this</span>.name[i++],<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> obj2 )&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>生成器函数是ES6提供的异步编程解决方案之一，语法行为与普通函数完全不同，生成器函数默认返回一个迭代对象，可使用使用迭代器的<code>next()</code>方法 来手动执行函数内部每一行代码 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> genIterator = gen();</span><br><span class="line">genIterator.next(); <span class="comment">//apple</span></span><br><span class="line">genIterator.next(); <span class="comment">//banana</span></span><br><span class="line">genIterator.next(gen()); <span class="comment">//orange</span></span><br></pre></td></tr></table></figure><p>迭代器对象的<code>netx()</code>方法的传参可缺省，默认值为调用的函数</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个<em>基于生成器的版本</em>的<strong>return</strong>关键字。</li><li>yield实际返回一个迭代器对象 例如 <code>&#123;value:&quot; &quot;,done: false &#125;</code>  </li><li>yield 只能配合生成器函数使用</li><li>yield并不能直接生产值，而是产生一个等待输出的函数</li><li>某个函数包含了yield，意味着这个函数已经是一个Generator</li><li>除IE外，其他所有浏览器均可兼容（包括win10 的Edge）</li><li>如果yield在其他表达式中，需要用()单独括起来</li><li>next()可无限调用，但既定循环完成之后总是返回<code>undeinded</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  * <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;  <span class="comment">//到此处直接返回一个迭代对象</span></span><br><span class="line">        <span class="keyword">if</span> (reset) &#123; i = <span class="number">-1</span>;&#125; <span class="comment">//这一行语句不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = count();</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br><span class="line"><span class="built_in">console</span>.log(arr.next())</span><br></pre></td></tr></table></figure><h3 id="yield参数"><a href="#yield参数" class="headerlink" title="yield参数"></a>yield参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  * <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x,y,z)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = test(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.next());   <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next(<span class="number">12</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(a.next(<span class="number">13</span>)); <span class="comment">// 42 = 24 + 5 + 13</span></span><br></pre></td></tr></table></figure><p>当<code>next()</code>传入参数时，只有上一个yield整体等于传入参数，当前迭代的yield仍然返回之后的表达式的值</p><p>异步编程示例1：解决回调地狱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数的做法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    one ();</span><br><span class="line">    two ();</span><br><span class="line">    three ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line">iterator.next(); <span class="comment">//从one开始自动遍历</span></span><br></pre></td></tr></table></figure><p>异步编程示例2：模拟业务处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟购物传递信息流程：获取用户数据 → 获取订单数据 → 获取商品数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.next(userInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrderInfo</span>(<span class="params">userInfo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="string">&quot;通过传入的id获取到用户信息&quot;</span></span><br><span class="line">        iterator.next(orderInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoodsInfo</span>(<span class="params">orderInfo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="string">&quot;通过传入的orderInfo获取到商品信息&quot;</span></span><br><span class="line">        iterator.next(goodsInfo);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="keyword">yield</span> getUserInfo(userId);</span><br><span class="line">    <span class="keyword">let</span> orderInfo = <span class="keyword">yield</span> getOrderInfo(userInfo);</span><br><span class="line">    <span class="keyword">let</span> goodsInfo = <span class="keyword">yield</span> getGoodsInfo(orderInfo);</span><br><span class="line">    <span class="built_in">console</span>.log(goodsInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = gen(<span class="number">11</span>);</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>ES6 引入的异步编程结局方案，<code>Promise</code>是一个构造函数，用来封装异步操作，且可获取成功与失败的结果，</p><p><code>Promise</code>接收一个函数作为参数，其中函数的参数分为<code>resolve</code>和<code>reject</code> 两个函数来分别处理成功与失败两种状态，函数内部进行一系列异步操作，在最后调用<code>resolve(data)</code> 和 <code>reject(data)</code>分别赋予Promise实例成功与失败两种状态:</p><ul><li>调用<code>resolve(data)</code>，返回一个状态为成功(fulfilled)的<code>Promise</code>对象，可以使用<code>then()</code>进行进一步处理</li><li>调用<code>reject(data)</code>，返回一个失败(rejected)的<code>Promise</code>对象，如果没有使用<code>then()</code>进行进一步失败处理，浏览器就会抛出异常，值为data，</li></ul><p>在执行以上操作后可以调用:</p><ul><li><p>then()方法</p><ul><li><p>then()方法接收两个函数：<code>function(value)&#123;...&#125;</code> <code>function(reason)&#123;...&#125;</code> </p><ul><li>当p在初始化时的异步操作调用了<code>reslove()</code>之后，执行<code>then()</code>方法中的第一个回调函数<code>function(value)&#123;...&#125;</code> 代码，<code>value</code>为<code>reslove()</code>的参数</li><li>当p在初始化时的异步操作调用了<code>reject()</code>之后，执行<code>then()</code>方法中的第二个回调函数<code>function(reason)&#123;...&#125;</code>代码，<code>reason</code>为 <code>reject()</code>的参数</li></ul></li><li><p><code>promise.then()</code>方法在调用后，返回一个Promise对象。</p></li><li><p>当在<code>promise.then()</code>的成功/失败的回调中使用<code>return</code><strong>返回一个<code>非Promise对象的值</code>时，<code>promise.then()</code>仍然返回一个状态为成功(fulfilled)的Promise对象</strong>，其中带有promise状态以及返回的值，其中Object类型会被转换成 <code>Object</code>字符串</p></li><li><p>当在<code>promise.then()</code>中使用<code>return</code>返回了一个<code>Promise对象</code>时，此时<code>promise.then()</code>返回的<code>promise</code>对象的成功与否 由 返回的<code>promise</code>对象状态 决定</p></li><li><p>当在<code>promise.then()</code>中<strong>使用<code> throw new Error()</code> 或者<code>thow &quot;error&quot;</code>抛出错误，则<code>promise.then()</code>返回的<code>Promise</code>对象为失败状态</strong>，且promise失败值为 <code>thow</code>抛出值</p></li></ul></li><li><p>案例1：使用Promise处理文件异步读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用Promise 发送AJAX请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">                resolove(xhr.response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line">                reject(xhr.status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>state往往就是一个实体固有的状态。<br>status则偏向于运行时状态。</p></blockquote><p><code>Promise.then()</code>方法的链式调用：</p><ul><li><p>在链式调用的then()方法中，在回调函数中的返回值会作为下一个then()方法中回调的<code>value</code>或<code>reason</code>值，只要在<code>then()</code>的所有回调中使用 <code>return</code>返回了非<code>Promise</code>对象 则状态均为成功<code>reslove</code></p></li><li><p>在<code>then()</code>所有回调函数内使用<code>throw</code>抛出字符串、错误对象 new Error()，则返回的Promise对象状态均为 失败 <code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">   .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>Promise.then()</code>模拟场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> userId = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (userId) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了userId&quot;</span>);</span><br><span class="line">              reslove(userId)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;没有请求到userId&quot;</span>);</span><br><span class="line">              reject();</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> a = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了用户信息&quot;</span>);</span><br><span class="line">              reslove(value + <span class="string">&quot;用户信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到用户的用户信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">reslove, reject</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&quot;请求到了订单信息&quot;</span>);</span><br><span class="line">              reslove(<span class="string">&quot;订单信息&quot;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;没有请求到的订单信息&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></li></ul><ul><li>catch()方法：catch()的功能与then()第二个回调函数类似，在Promise对象的状态为失败时调用，一般用于获取</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>集合内部的值不会重复，</p></li><li><p>添加和删除的方法分别为<code>add()</code> <code>delete()</code></p></li><li><p>使用<code>has()</code>方法检测目标是否存在于集合中，返回t/f </p></li><li><p>使用<code>clear()</code>方法清除集合所有元素</p></li><li><p>集合元素个数量使用size()方法得到</p></li><li><p>应用案例：</p><ul><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure></li><li><p>求两数组交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arrSet.has(item))</span><br></pre></td></tr></table></figure></li><li><p>求两数组的并集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arrSet = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">[...new <span class="built_in">Set</span>(arr2)].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arrSet.has(item)) &#123;</span><br><span class="line">        arrSet.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arrSet);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> union = [...new <span class="built_in">Set</span>([...arr, ...arr2])];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>ES6 引入的 新数据结构，类似于对象，结构为键值对集合，但是key的类型不一定是字符串，可以是任何类型的值，map同样实现了迭代器接口，可以使用<code>[...]</code>，和<code>for of</code> </p><ul><li>Map元素个数量使用<code>size()</code>方法得到</li><li>new Map()可以接收一个键值对形式的数组：一般以一个<code>key</code>和一个<code>value</code>组成的基本数组，返回一个Map对象</li><li>使用<code>set(key,value)</code> 增加一个元素，并返回更新后的map实例</li><li>使用<code>delete(key)</code> 删除一个键值对，并返回布尔值，找到key并删除value返回true，没有找到key返回false</li><li>使用<code>get(key)</code>返回key的value值</li><li>使用<code>has()</code>检测map是否包含某个元素 ，返回布尔值</li><li>使用<code>clear()</code> 清空map ,返回undefined</li></ul><h2 id="ES6-数值方法扩展"><a href="#ES6-数值方法扩展" class="headerlink" title="ES6 数值方法扩展"></a>ES6 数值方法扩展</h2><ul><li><p>使用<code>Number.EPSILON</code> 来解决js计算精度问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON ? <span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测数值是否为NaN：<code>Number.isNaN()</code>， 返回t/f</p></li><li><p>将小数部分抹去：<code>Number.trunc(floatNumber)</code>， 返回值</p></li><li><ul><li></li></ul></li></ul><h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><ul><li><code>Array.prototype.includes(value)</code>方法，判断value是否存在于数组中，返回布尔值</li><li>使用<code>**</code> 进行幂运算：<code>2 ** 2</code> 等同于 <code>Math.pow(2,2)</code></li></ul><h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><ul><li><p>async 函数</p><ul><li>async 函数为将await 之后的<strong>表达式</strong>以及<strong>await以下的所有语句</strong>都放入异步任务的同步函数</li><li>使用<code>async</code> 为前缀声明的函数的返回值为<code>Promise</code>对象</li><li>返回的<code>Primise</code>对象的状态由<code>async</code> 函数执行的返回值决定，与<code>promise.then()</code>回调函数的<code>return</code>原理相同：如果成功，返回成功promise，并将值放入value中；返回失败promise，则将失败值放入value中</li></ul></li><li><p>await 表达式</p><ul><li><code>await </code>必须写在async函数内部</li><li><code>await</code> <strong>等待右侧promise产生之后，返回值的过程</strong>属于异步微任务，<code>await</code>必须等待到右侧的promise的成功与失败的状态后，线程才会继续执行下面的代码</li><li><code>await</code> 右侧表达式一般为<code>Promise</code> 对象</li><li><code>await</code> 右侧的<code>Promise</code>对象如果状态为成功，则返回其成功的值<code>PromiseValue</code></li></ul></li><li><p><code>await</code> 右侧的<code>Promise</code>对象如果状态为失败，浏览器就会抛出异常，无返回值，需要使用<code>try catch捕获</code> ，<code>catch</code>的参数<code>e</code>为<code>Promise</code>对象失败的值<code>PromiseValue</code></p></li></ul><p>将 async 函数与 await函数相结合使用，将**<code>await </code>等待 <code>promise</code> 之后并返回值** 这过程，放入异步微任务，而在await 之后的代码语句，需要等待<code>await</code> 产生结果后，才能继续执行，且是在在微任务中执行，换句话说，遇到<code>await</code>时就把<code>await</code>之后的代码放入异步微任务，然后再继续向下执行，</p><ul><li><p>案例1：读取文件，使用async函数接收文件信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileReader</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">&#x27;文件路径&#x27;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) =&gt; reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dataReceiver</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileData = <span class="keyword">await</span> fileReader();</span><br><span class="line">    <span class="keyword">return</span> fileData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例2：使用async 与 await 发送AJAX请求并处理消息，这也是<code>axios</code>的实现原理之一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AjaxRequest</span>(<span class="params">requestUrl</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XmlHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;get&#x27;</span>,requestUrl);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                reslove(xhr.response)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params">requestUrl</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> requestData;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    requestData = <span class="keyword">await</span> AjaxRequest(requestUrl); </span><br><span class="line">        <span class="built_in">console</span>.log(requestData) <span class="comment">//此时await为同步代码，会产生阻塞，当await获得到promise值后才能执行到这一步</span></span><br><span class="line">        <span class="keyword">return</span> requestData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例3：在React组件生命周期中使用async函数 和await 处理请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> axios.get(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ES8-对象扩展"><a href="#ES8-对象扩展" class="headerlink" title="ES8 对象扩展"></a>ES8 对象扩展</h2><ul><li><p><code>Object.keys(object)</code> 获取对象所有的键，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象所有的键值，返回一个数组</p></li><li><p><code>Object.values(object)</code> 获取对象的所有键值，以对象的形式生成一个数组，可以通过数组创建<code>map</code>对象</p></li><li><p>获得对象属性的描述对象 <code>Object.getOwnPropertyDescriptions(object)</code>，返回一个对象，描述object内部所有属性的选项设置(可读、可写、可枚举等)</p></li><li><p>ES5 补充：<code>Object.defineProperty()</code>，对对象属性进行监听，注意不能在get/set中直接调用被修改的属性值，否则造成死循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj,propertyName,&#123;</span><br><span class="line">    <span class="comment">//为此当前对象属性设置函数，例如set、get</span></span><br><span class="line">    <span class="comment">//钩子分别在获取、设置属性值时调用</span></span><br><span class="line">    get()&#123;&#125;</span><br><span class="line">    set()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现ES6的新特性——Promise</title>
      <link href="/2020/08/23/Promise/"/>
      <url>/2020/08/23/Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ECMAscript 6 原生提供了 Promise 对象。Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p></blockquote><h2 id="了解JavaScript事件循环"><a href="#了解JavaScript事件循环" class="headerlink" title="了解JavaScript事件循环"></a>了解JavaScript事件循环</h2><p>在解析promise的机制之前，我们需要掌握浏览器的事件循环，此处引用一张事件循环流程图</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/event_loop.png" alt="image"></p><p>在上图中的最后2两行队列均为异步队列，可以观察到，每个宏任务队列后都跟随一个微任务队列，</p><blockquote><p>但请注意，需要把第一个同步任务，即栈内第一个函数执行时的场景视为一个宏任务</p></blockquote><p>在执行栈中的函数遇到异步任务时，会将异步任务交给 右侧相应模块进行处理</p><p>第一个队列为宏任务队列，也是主要的异步任务队列，其中的任务由计数器处理模块，ajax请求线程与文件处理模块(NodeJs)进行推入，</p><p>第二个队列为微任务队列，在promise对象的.then()方法，与process.nextTick()都会在执行时，将传入的回调函数推入<strong>当前宏任务后</strong>的微任务队列，</p><p>当宏任务与微任务相互嵌套时，此时就可能会产生一些异步任务队列与执行栈会相互添加内容，即在栈中异步队列的函数 与 栈中函数产生异步任务，因此形成循环，</p><p>而JS的异步任务常常使用事件驱动的方式被触发，也就是为什么这种循环叫做事件循环</p><h2 id="Promise-是什么？"><a href="#Promise-是什么？" class="headerlink" title="Promise 是什么？"></a>Promise 是什么？</h2><p>抽象的说，Promise是JavaScript中进行异步编程的一个新的解决方案</p><p>具体的说，Promise就是一个构造函数，通过函数构造出的实例可以封装一系列异步操作，并可以从中得到异步操作产生的结果数据</p><h2 id="为什么要使用Promise？"><a href="#为什么要使用Promise？" class="headerlink" title="为什么要使用Promise？"></a>为什么要使用Promise？</h2><blockquote><p>使用链式调用的编写方式，解决异步回调地狱（代码缩进）的问题 </p></blockquote><p>所谓回调地狱，就是当我们要进行多个异步操作的时候，此时一个回调函数包含另一个异步操作，当异步操作数量达到一定程度时，代码会向右持续缩进，这样会使得程序可读性和可维护性下降</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//更多嵌套..</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在上面的计时器回调代码中，我们可以看到代码缩进一直在增加，在实际的开发环境中，如果有几十个回调，那么代码就变得非常的不美观，且不易维护</p><p>但在promise的链式调用中，只需要将上一个处理的对象使用方法继续进行处理，且捕获异常和错误也比较方便</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200826225041424.png" alt="image-20200826225041424"></p><p>解决异步任务的最佳办法，是将promise对象配合 ES8 中新增的 async函数与await来操作结果，其中await会等待promise的值，并将之后的语句放入异步任务中执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/image-20200826225805992.png" alt="image-20200826225805992"></p><h2 id="Promise-a-规范"><a href="#Promise-a-规范" class="headerlink" title="Promise/a+ 规范"></a>Promise/a+ 规范</h2><p>规范出现的原因：</p><p>1、 我们不知道异步请求什么时候返回数据，所以我们就需要些回调函数。但是在某些情况下我们需要知道数据是在什么时候返回的，然后进行一些处理。</p><p>2、 当我们在异步回调里面继续执行异步操作的时候，这样就形成了异步回调函数的嵌套</p><p>规范的内容是什么？</p><p>1、 不管进行什么操作都返回一个promise对象，这个对象里面会有一些属性和方法</p><p>2、 这个promise有三种状态</p><blockquote><p>一个promise对象只能改变一次状态，而且都会返回一个数据</p></blockquote><ul><li>pending<ul><li>默认状态</li></ul></li><li>fulfilled<ul><li>调用<code>resolve()</code>返回的状态</li><li>英文含义为 已完成 ，实际上表示成功的状态</li><li>返回value</li></ul></li><li>rejected<ul><li>调用<code>reject()</code>返回的状态</li><li>英文含义为 拒绝了  ， 实际上表示为失败的状态</li><li>返回reason</li></ul></li></ul><h2 id="Promise执行机制"><a href="#Promise执行机制" class="headerlink" title="Promise执行机制"></a>Promise执行机制</h2><h3 id="Promise的任务执行流程"><a href="#Promise的任务执行流程" class="headerlink" title="Promise的任务执行流程"></a>Promise的任务执行流程</h3><ol><li>创建一个Promise对象，处于<code>pending</code>状态</li><li>执行异步操作，成功，调用<code>resolve()</code>；失败，调用<code>reject()</code> ，都会返回一个新的promise对象</li><li>执行实例promise.then()方法，按照当前状态，执行内部的回调，可重复步骤2</li></ol><blockquote><p>Promise内部利用闭包的机制，通过调用函数来改变不同的状态，由此来执行对应的回调函数</p></blockquote><p>下列代码中，创建了一个promise对象同时立即改变状态，而跟随其后又连续调用2个<code>then()</code>，每个<code>then()</code>调用结束都会<strong>默认</strong>返回一个新的promise对象，而<code>then()</code>中成功/失败的回调内部返回的值则为新promise的<code>value</code>，在这一系列调用中如果没有<strong>抛出任何异常</strong>或者<strong>返回任何失败的promise</strong>，则都会视为<strong>成功</strong>的promise</p><p>注意：<strong>throw xxx 均为失败状态 ,xxx 为reason的值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">11</span>)</span><br><span class="line">  &#125;)).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  ).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>如果想在结果的回调中再执行一个异步任务（也可以说是触发一系列的异步任务），在结果回调函数内需要返回一个新的<code>_promise</code>对象，并成为.then()的返回结果可以在下一次.then()做出更多的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">11</span>)</span><br><span class="line">  &#125;)).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt;&#123;</span><br><span class="line">          <span class="comment">// 异步任务，请求之类的</span></span><br><span class="line">          setTimoeout(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          resolve(<span class="string">&#x27;22&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(reason)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;reason&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="Promise异常传递"><a href="#Promise异常传递" class="headerlink" title="Promise异常传递"></a>Promise异常传递</h3><p>当<code>_promise</code>对象进行一系列任务操作时，在Promise链式调用的回调中，不编写处理失败的回调函数，只在链式调用的末尾使用<code>catch()</code>处理异常情况，只要遇到了失败状态的<code>_promise</code>，就会将失败的promise逐级传递到最后的<code>catch()</code>失败处理回调中，如果不抛出异常或者返回失败的<code>_promise</code>对象，<code>.catch()</code>和<code>.then()</code> 一样，返回成功的<code>_promise</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">0</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-中断传递"><a href="#Promise-中断传递" class="headerlink" title="Promise 中断传递"></a>Promise 中断传递</h3><p>如果因为某个错误，想要在链式调用的过程中中断整个过程，则需要返回一个<code>pending</code>状态的promise，即返回<code>new _Promise(()=&gt; &#123;&#125;)</code></p><p>原理：因为<code>then()</code>内部的回调函数最终是由调用执行器中的<code>resolve()</code>或者<code>reject()</code>从而触发执行的，返回一个pending的<code>_promise</code>显然并没有改变任何状态，因为初始化<code>_promise</code>的状态就是<code>pending</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">0</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">    &#125;).then(</span><br><span class="line">       value =&gt; &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;value &#x27;</span>,value)</span><br><span class="line">       &#125;,</span><br><span class="line">       reason =&gt; &#123;</span><br><span class="line">           <span class="keyword">return</span> =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span> &#123;&#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fatalError&#x27;</span>, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现-Promise"><a href="#实现-Promise" class="headerlink" title="实现 Promise"></a>实现 Promise</h2><h3 id="方法以及规则"><a href="#方法以及规则" class="headerlink" title="方法以及规则"></a>方法以及规则</h3><p>在了解了官方Promise的使用方法后，为了实现_Promise，我们需要更详细的内部原理与运行机制</p><blockquote><p>自定义Promise一律用<code> _Promise</code>代替，其实例对象标记为<code> _promise</code>  ，</p></blockquote><hr><ul><li>构造函数<code>_Promise</code>的方法<ul><li><code>_Promise(executor)</code></li><li><code>_Promise.resolve(value)</code></li><li><code>_Promise.reject(reason)</code></li><li><code>_Promise.all(promiseArray)</code></li><li><code>_Promise.race(promiseArray)</code></li></ul></li><li>实例对象<code>_promise</code>的方法<ul><li><code>_promise.then(onResolved , onRejected)</code></li><li><code>_promise.catch(onRejected)</code></li></ul></li><li>规则：<ol><li>调用<code>_Promise(executor)</code>进行初始化<code>_promise</code>时：<ol><li>改变状态与值的内部函数<code>resolve(value)</code>或者<code>reject(reason)</code>的调用类型为<strong>异步调用</strong>，意味着可能等待<code>then()</code>执行后才进行调用</li><li>如果存在多次调用<code>resolve(value)</code>或者<code>reject(reason)</code>，则以第一个调用为准，舍弃后续调用</li><li><code>resolve(value)</code>和<code>reject(reason)</code>都不执行，而是使用throw xx来抛出错误，需要将<code>_promise</code>状态设置成<code>rejected</code></li><li>返回一个<code>_Promise</code>实例</li></ol></li><li>调用<code>_promise.then()</code>时<ol><li><code>_promise.then()</code>应该返回一个新的<code>_promise</code>对象</li><li>如果<code>_promise</code>的状态为pending，那么将其推入实例的回调函数数组中</li><li>如果<code>_promise</code>的状态为fulfilled或者rejected，那么将传入的回调立即作为异步函数执行</li><li>如果在规则2.3满足的情况下，回调函数返回了一个<code>_promise</code>对象，那么，<code> _promise.then()</code>返回的新<code> _promise</code> 对象为回调函数返回的对象</li><li><code>promise.then()</code>能够实现传透的功能，即在不传入失败的回调函数<code>onRejected</code>或者成功的回调函数<code>onResloved</code>时，使用<code>then()</code>的链式调用能够将失败的<code>_promise</code>往后传递</li></ol></li><li>调用<code>_Promise.resolve(value)</code>时，<code>value</code>可以为<code>_promise</code>类型，也可以为非<code>_promise</code>类型，调用后返回一个成功/失败的<code>_promise</code></li><li>调用<code>_Promise.reject(reason)</code>时，<code>reason</code> 只能是非<code>_promise</code>类型的值</li><li>调用<code>_Promise.all(promiseArray)</code> 应该在所有promise均为成功的情况下，返回一个值为所有<code>_promise</code>的值的数组的新的成功的<code>_promise</code>，否则，返回第一个失败的<code>_promise</code></li><li>调用<code>_Promise.race(promiseArray)</code> 应该返回数组中第一个改变状态的<code>_promise</code></li></ol></li></ul><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="_Promise构造函数"></a>_Promise构造函数</h3><p>_Promise<code>主构造函数，接收一个函数作为执行器，只收**立即**产生一个</code>_promise`对象</p><ul><li>构造函数内部拥有三个属性<ul><li>state：保存状态</li><li>data：保存数据</li><li>callbacks：保存一个<code>then()</code>方法添加的回调函数的对象</li></ul></li><li>在<code>resolve()</code>和<code>reject()</code>对<code>this.state</code>和<code>this.data</code>的改变后，需要符合规则1.1和1.2：即将对应回调函数推入异步任务队列中</li><li>在<code>resolve()</code>和<code>reject()</code>都没有被调用的情况下，需要符合规则1.3 ： 即使用捕获来处理异常情况</li><li>在executor中调用<code>resolve()</code>或者<code>reject()</code> ，其本质是同步/异步地改变状态和值（多数情况下为同步），然后将<code>_promise</code>对象内部的callbacks 中对应的成功或者回调放置在异步队列中进行调用，可能此时callbacks没有回调函数，但是<code>_promise.then()</code>是同步的将回调放入自身callbacks中，即<strong>放入回调函数</strong>这一操作永远比在<strong>异步队列中执行回调函数</strong>先执行，这就是为什么Promise的链式调用能够处理异步请求的原因</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实例的自身状态属性</span></span><br><span class="line">    <span class="built_in">this</span>.state = PENDING <span class="comment">// 对象状态默认为pending</span></span><br><span class="line">    <span class="built_in">this</span>.data = <span class="literal">undefined</span> <span class="comment">// 对象的值默认为undefined</span></span><br><span class="line">    <span class="comment">// 存储自身的回调函数，这个回调函数数组由.then()方法进行传入</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks = [] <span class="comment">// 元素结构为对象，存储2个函数：&#123;onResolved()&#123;&#125;, onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 此时有的执行器内部调用.resolve()的前后2种状态，</span></span><br><span class="line"><span class="comment">    * 1. 调用resolve()之前自身的状态回调函数才被添加，也就意味着执行器内部立即执行.resolve()</span></span><br><span class="line"><span class="comment">    * 2. 调用resolve()之后自身的状态回调函数才被添加，也就意味着执行器内部延迟执行.resolve()</span></span><br><span class="line"><span class="comment">    * 所以无论何时调用resolve()，它必须在被添加回调callbacks之后才能被调用*/</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 去除后续的resolve调用，保证状态的唯一性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将状态改成fulfilled，并保存value到实例data中</span></span><br><span class="line">        <span class="built_in">this</span>.state = FULFILLED</span><br><span class="line">        <span class="built_in">this</span>.data = value</span><br><span class="line">        <span class="comment">// 如果回调数组中有函数，那么将其推入宏任务队列中，异步调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.onResolved(value)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败状态 同理</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.state = REJECTED</span><br><span class="line">        <span class="built_in">this</span>.data = reason</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">                    callbacksObj.onRejected(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即执行外来的executor，并且将2个函数作为参数交给executor,如果有调用resolve或者reject，那也将一并执行,并使用try catch 捕获throw抛出的值或者错误</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果使用<code>function</code>声明的<code>resolve()</code>和<code>reject()</code>函数，那么内部的<code>this</code>就是指向的<code>window</code>，因为这两个函数被外部传入的箭头函数<code>executor</code>调用，而外部的executor的<code>this</code>指向的是<code>window</code>，那么内部的两个函数就是被<code>windows</code>调用，将<code>resolve()</code>和<code>reject()</code>改为箭头函数声明，即在声明时就执行父级作用域的<code>this</code>，即<code>new</code>语句产生的<code>_promise</code>对象</p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="_Promise.prototype.then ()"></a>_Promise.prototype.then ()</h3><p>给<code>_Promise</code>主构造函数原型上添加then方法 ，主要用于实例<code>_promise</code></p><ul><li><p><code>then()</code> 方法主要是用于同步的将传入的回调函数放入<code>_promise</code>的callbacks属性中、或者根据promise的状态调用响应的回调函数，最后返回一个新的<code>_promise</code>对象</p></li><li><p><code>_proimise</code>的状态为pending ，那么直接将回调推入callbacks属性中，那么此时构造<code>_proimise</code>的执行器中的<code>resolve()</code> 或者 <code>reject()</code> 还没有被执行，也就是说，在状态还没出现之前，就调用了<code>then()</code>，那么如何在后面异步任务中产生了状态之后就可以马上执行前面<code>then()</code>中的回调以及返回新的<code>_promise</code>对象呢？</p><ul><li><p>在<code>resolve()</code> 或者 <code>reject()</code>被调用的时候也会将回调函数数组中的函数加入异步队列中等待调用，而等待到这些函数被调用的时候，即是返回的<code>_promise</code>对象获得状态的时候，而传入的回调<code>onResolved</code>和<code>onRejected</code>也有三种情况：返回<code>_promise</code>，返回非<code>_promise</code>，抛出异常，使用<code>try catch </code>以及递归进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="comment">// 当在resolve调用的时候，这里的onResolved会被加入异步队列并被调用，同时也使得返回的promise拥有了状态和值</span></span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onResolved(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onRejected(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>_proimise</code>的状态为resolve或者reject，此时异步队列中已经没有执行的回调，需要在接收到回调的时候将其放入异步队列中，即使用计时器，在计时器异步任务中执行对应状态的回调函数</p><ul><li><p>如果状态回调函数返回的是非_Promise类的值，也就是说手动调用<code>onResolved</code> / <code>onRejected</code> 后返回的值不是 <code>_Promise</code> 类型，那么返回的新对象就在执行器中直接调用<code>resolve(result)</code>来将返回的promise对象设置为 成功的状态（只要不抛出错误且不返回<code>_promise</code>的回调均为成功）</p></li><li><p>状态回调函数内部使用<code>throw</code>抛出了异常或者普通值，那么在<code>catch(error)&#123;&#125;</code>中直接将要返回的promise的状态设置为rejected，且值为error</p></li><li><p>状态回调函数内部返回了一个<code>_promise</code>对象，此时需要将这个对象特殊处理</p><ol><li><p>首先整个<code>then()</code>方法的参数接收2个函数参数，返回一个新<code>_promise</code>对象，其中构造函数执行器为同步执行，所以将判断代码放入执行器中</p></li><li><p>判断调用<code>then()</code>方法的本体<code>_promise</code>的状态，其中最简单的如果是pending状态则就仅仅将回调函数放入返回的新<code>_promise</code>对象的回调数组中，然后将在异步任务中被调用，这次情况就符合第一次创建<code>_promise</code>对象时，执行器中的<code>resolve()</code>或者<code>rejected()</code>在<strong>异步任务</strong>中的情况</p></li><li><p>如果调用<code>then()</code>方法的本体<code>_promise</code>的状态为fulfilled或者rejected ， 此时需要对应状态使用计时器创建一个新的异步任务，并在这个异步任务中调用.then()传入的回调函数，并拿到回调函数返回的结果，通过结果来进一步生成新的<code>_promise</code>作为<code>then()</code>的返回结果</p></li></ol></li></ul><blockquote><p>那么此时就会遇到一个问题：如何去继承回调中返回的 promise的状态和值呢？如何判断这个promise的状态是成功还是失败呢？</p></blockquote><p><code>then()</code> 方法就是用来判断调用的promise的成功与失败的方法，那么我们可以<code>then()</code>内的回调中，即返回的<code>_promise</code>内也对作为<code>_promise</code>对象的结果，调用一次<code>then()</code>，并在其中传入，要返回的新<code>_promise</code>的状态设置函数<code>resolve(value)</code>和<code>reject(reason)</code>，这样就可以将后续<code>_promise</code>的状态与最终值继承到第一次调用<code>then</code>返回的<code>_promise</code>对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> handleCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> result = callback(_this.data) <span class="comment">// 将结果计算出来</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                    result.then(resolve, reject) <span class="comment">// 将上方new Promise的resolve、reject作为结果的promise.then()的回调</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在此可以举一个例子：  </p><ul><li><p>假如说现在创建了一个<code>_Promise</code>的实例对象<code>p</code>,其状态为fulfilled ，值为<code>11</code></p></li><li><p>然后调用了<code>p.then()</code>，其中成功的回调返回了一个新的<code>_Promise</code>实例对象，且状态为成功，值为<code>22</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;resolve(<span class="number">22</span>)&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>接着<code>p.then()</code> 调用后，会返回一个新的 <code>_Promise</code>实例对象，我们来看这个新的 <code>_Promise</code>实例对象是如何产生的</p><ol><li>按照<code>then()</code>的代码进入 <code>return</code>右侧 <code>new _Promise()</code>的执行器中，在这里，我们将这个 <code>new _Promise()</code>最后所构造出来的对象称为 <code>p1</code></li><li>此时的<code>this</code>为最前面的实例对象<code>p</code>，对<code>p</code>的状态进行判断，执行转到 <code>else if (this.state === RESOLVED) &#123;...&#125;</code>中，其内部为一整个异步任务，被主线程放到异步队列中等待执行，此时<code>p.then()</code>的同步任务就执行完毕了</li><li>假设同步任务已经执行完毕，现在跳转到异步任务中执行，也就是开始执行<code>setTimeout</code>中回调的内容，异步任务开始</li><li>在 <code>try catch</code> 中,<code>p.then()</code> 内部的函数将<code>p.data</code>作为参数放入传入的 <code>value=&gt; ...</code> 箭头函数中执行，此时的<code>onResolved(this.data)</code>就等于带着参数执行了<code>value =&gt; new _Promise((resolve,reject) =&gt; &#123;resolve(22)&#125;</code></li><li>此时判断result，发现返回了一个<code>_Promise</code>的实例对象，这里简称<code>result</code>，其状态为<code>fulfilled</code>，值为22，那么调用这个实例对象<code>result.then()</code>，且成功、失败的的回调函数分别为<code>p1</code>的<code>resolve(value)</code>和<code>reject(reason)</code></li><li>进入到<code>result.then()</code>中，同样又进入一个新promise的创建流程，进入执行器，判断<code>result</code>的状态，上方我们设置的为成功的状态，那么在同步队列执行完的异步队列中同样执行了<code>let result = onResolved(this.data)</code>这一句，且此时的<code>onResolved(this.data)</code>就是p1构造器中的<code>resolve(value)</code>，调用之后，此时p1的对返回的<code>_promise</code>对象的<code>this.data</code>继承已经完成了</li><li>这个时候构造p1的异步任务已经完成了，此时通过return返回，成为<code>p.then()</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved , onRejected</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onResolved(value)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> result = onRejected(reason)</span><br><span class="line">              <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">                result.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = onResolved(<span class="built_in">this</span>.data)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            <span class="comment">// result.then(</span></span><br><span class="line">              <span class="comment">// 如果手动返回的_promise的执行器中调用的是resolve()，那么则会执行</span></span><br><span class="line">              <span class="comment">// 当成功/失败时，将原来的.then()对象也为成功/失败，并且继承回调内部返回的_promise的值</span></span><br><span class="line">              <span class="comment">//value =&gt; resolve(value),</span></span><br><span class="line">              <span class="comment">//reason =&gt; reject(reason)</span></span><br><span class="line">            <span class="comment">//)</span></span><br><span class="line">            result.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> result = onRejected(<span class="built_in">this</span>.data)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            result.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时会发现，上面的代码<code>try catch</code>部分重复了4次，所以将重复代码提取为一个新函数，并增加异常传透的功能</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实现传透</span></span><br><span class="line">  <span class="comment">// 如果没有传入成功的回调函数，当promise成功时，会默认将onResolved赋值为一个函数，通过返回值来传递成功的promise</span></span><br><span class="line">  <span class="comment">// 如果没有传入失败的回调函数，当遇到失败的promise时，将onRejected默认赋值为一个函数，通过抛出值来传递失败的的promise</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">  <span class="comment">// 始终返回一个新的_promise，需要判断返回的状态，以及回调返回的值，</span></span><br><span class="line">  <span class="comment">// 将判断任务放入执行器中执行，以便产生不同状态的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleCall = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = callback(<span class="built_in">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">          result.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是无状态的，那么直接将回调放入属性中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onResolved (value) &#123;</span><br><span class="line">            handleCall(onResolved)</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected (reason) &#123;</span><br><span class="line">            handleCall(onRejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      <span class="comment">// 如果这个_promise对象有状态，则将其回调放入异步队列中执行，并判断其执行后的返回值是否为_Promise类型</span></span><br><span class="line">      <span class="comment">// 如果是，则需要使用自身的.then来判断在其手动创建的_promise的执行器到底是调用了那个状态函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有一个问题：为什么调用.then()的有状态的promise时候，内部的<code>handleCall(onResolved)</code>要使用异步调用呢？</p><p>这是因为，状态主要是依靠构造promise时执行器中的<code>resolve()</code>和<code>reject()</code>两个函数进行的，而先有回调函数再有状态的原因是在构造器内部使用了计时器调用了<code>resolve()</code>和<code>reject()</code>，导致同步的<code>then()</code>先执行，将内部传入的回调放进了<code>_promise</code>对象的callbacks中</p><p>但先有状态，后有回调的情况就是：先执行了构造器的所有内容，立即改变了状态以及值，将执行自身的回调函数这一任务放进了计时器，从而变为了在同步任务结束之后的异步任务；接着在结束<code>_promise</code>的构造后，立即调用了<code>then()</code></p><p>但进入了.then()后，有状态的promise则不会像无状态的一样，直接放入promise的callbacks，来等待<code>resolve()</code>和<code>reject()</code>，因为已经在执行器里面同步执行过了，这个时候.then()要根据调用回调函数的结果，返回一个新的<code>_promise</code>，而这一过程往往是应用于发送异步请求，如果在此处直接调用<code>handleCall(onResolved)</code>，那么主线程就会等待这个<code>then()</code>中回调函数产生的结果从而去创建新promise（包括改变它的状态与值）这一过程，这就违背了Promise思想的初衷</p><p>还有一点是，异步的<code>handleCall(onResolved)</code>与同步创建<code>_promise</code>的执行器形成了闭包，这样，<code>handleCall(onResolved)</code>在异步任务中执行时，还可以去改变同步任务时创建的状态为pending的<code>_promise</code>对象，然后通过微任务队列，先调用<code>then()</code>的先执行，先改变<code>then()</code>返回的promise的状态，这样就形成了一种前后关系</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="_Promise.prototype.catch()"></a>_Promise.prototype.catch()</h3><p><code>catch()</code>其实就是<code>then()</code>处理失败的情况，传入回调到<code>onRejected</code> 调用并返回<code>then()</code>的结果即可，其中<code>onResolved</code>的位置设置为<code>undefined</code>或者<code>null</code>都可以 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Promise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="_Promise.resolve(value)"></a>_Promise.resolve(value)</h3><p><code>_Promise.resolve(value)</code> 返回一个成功的<code>promise</code>，值为<code>value</code>，<code>value</code>的值可以普通值，也可以是<code>_promise</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reslove()返回一个新的promise对象，并且需要判断value的类型</span></span><br><span class="line">_Promise.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">            <span class="comment">// 此处使用传入的promise.then方法来解决新返回的promise的状态</span></span><br><span class="line">            value.then(resolve, reject)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="_Promise.reject(reason)"></a>_Promise.reject(reason)</h3><p><code>_Promise.reject(reason)</code>返回一个失败的<code>_promise</code>，值为<code>reason</code>，<code>reason</code>的值只能为非<code>_promise</code>类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .reject()方法也是返回一个promise对象，并且只接受一个reason</span></span><br><span class="line">_Promise.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all-promiseArray"><a href="#Promise-all-promiseArray" class="headerlink" title="_Promise.all(promiseArray)"></a>_Promise.all(promiseArray)</h3><p><code>_Promise.all(promiseArray)</code> 返回一个<code>_promise</code>，接收一个参数<code>promiseArray</code>(_promise数组)，但其中的元素可以是<code>_promise</code>对象，也可以是非<code>_promise</code>对象</p><ul><li><p>当内部所有promise的状态都为成功的时候，返回成功的promise，且promise的value为一个数组，其值promiseArray所有promise的value</p></li><li><p>否则返回失败的<code>_promise</code> 且其value为状态为失败的<code>_promise</code>的<code>value</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_Promise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> valueArray = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseArray.length)</span><br><span class="line">            <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 遍历promise数组使用then判断状态，并在回调中执行值的积累和以及改变状态</span></span><br><span class="line">            promiseArray.forEach(<span class="function">(<span class="params">_promise, idx</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 无论数组中的值是否为promise类型，使用.resolve()将其强制转换为promise对象，再进行.then()的判断</span></span><br><span class="line">                _Promise.resolve(_promise).then(</span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        counter++</span><br><span class="line">                        valueArray[idx] = value</span><br><span class="line">                        <span class="keyword">if</span> (counter === promiseArray.length) &#123;</span><br><span class="line">                            resolve(valueArray)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    reason =&gt; &#123;</span><br><span class="line">                        reject(reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>valueArray[idx] = value 这行为什么不能被 valueArray.push(value )代替呢？</p><p>此处不使用push进行增加元素的原因是因为传入的promise在构造时，可能resolve()或者reject()延迟调用的情况，如果使用了索引，那么在同步遍历时，就以闭包的形式锁定了value在数组中的位置</p></blockquote></li></ul><h3 id="Promise-race-promiseArray"><a href="#Promise-race-promiseArray" class="headerlink" title="_Promise.race(promiseArray)"></a>_Promise.race(promiseArray)</h3><p><code>_Promise.race(promiseArray)</code> 返回一个<code>_promise</code>，接收一个参数<code>promiseArray</code>(promise数组)</p><ul><li>返回数组中，最快产生成功或者失败状态的<code>_promise</code></li><li>例如：[p1,p2,3]  ,p1延迟2秒更新状态, p2 为同步获得状态，3为非promise，那么将数组看做为一个队列，p2和3为最先获得状态，但p2排在3的前面，所以最终结果输出p2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_Promise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function"><span class="params">__promise</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (_promise <span class="keyword">instanceof</span> _Promise)&#123;</span><br><span class="line">                    _promise.then(resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _Promise.resolve(__promise).then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用微任务"><a href="#使用微任务" class="headerlink" title="使用微任务"></a>使用微任务</h3><p>到此你会发现，当promise调用回调函数的时候，总是使用的<code>setTimeout()</code>来将其模拟为异步任务来调用，这个时候就出现了一个问题:</p><p>如果在所有创建<code>_promise</code>对象之前就启动一个0秒的定时器来调用输出，那么这个定时器内的内容一定是最先输出的（宏任务队列）这明显不符合<code>官方Promise</code>的一个特点：始终在异步微任务中调用回调函数；</p><p>通过文档了解到所有定时器函数、ajax请求、DOM事件回调均为宏任务，而因为使用了定时器，以上实现的promise并没有启动任何微任务，那么如何将一个回调函数变成在微任务中执行呢？</p><p>这个问题可以在使用<code>CommandJs</code>模块规范的NodeJs中使用<code>process.nextTick(callback)</code>解决，<code>process.nextTick(callback)</code>在NodeJs中用于将回调函数加入微任务队列，由此就可以真正模拟<code>官方Promise</code>的功能</p><p>以下是<code>_Promise</code>构造函数 以及<code>then()</code>方法的的最终代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.state = PENDING </span><br><span class="line">  <span class="built_in">this</span>.data = <span class="literal">undefined</span> </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = FULFILLED</span><br><span class="line">    <span class="built_in">this</span>.data = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onResolved(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state !== PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = REJECTED</span><br><span class="line">    <span class="built_in">this</span>.data = reason</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span> =&gt;</span> &#123;</span><br><span class="line">          callbacksObj.onRejected(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_Promise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleCall = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = callback(<span class="built_in">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> _Promise) &#123;</span><br><span class="line">          result.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        onResolved (value) &#123;</span><br><span class="line">          handleCall(onResolved)</span><br><span class="line">        &#125;, onRejected (reason) &#123;</span><br><span class="line">          handleCall(onRejected)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === FULFILLED) &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onResolved)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleCall(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise面试题"><a href="#Promise面试题" class="headerlink" title="Promise面试题"></a>Promise面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;)).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让我们从头开始解析：</p><ol><li>首先第一句执行<code>console.log(0)</code>的计时器进入宏队列</li><li>主线程同步任务到达第一个new，创建第一个promise ，执行内部的<code>console.log(1)</code>，然后执行<code>then()</code>，将 <code>console.log(2)</code> 以下直到 <code>console.log(6)</code>以上的放入微任务队列</li><li>主线程同步任务到达<code>console.log(6)</code>下方的new，创建第二个promise，执行<code>console.log(7)</code>，然后执行<code>then()</code> 将<code>console.log(8)</code>放入微任务队列</li><li>主线程同步任务执行完毕，开始执行异步任务</li><li>首先执行异步微任务队列</li><li>微任务队列中的<strong>第一个</strong>微任务，包含<code>console.log(2)</code> 的<code>.then()</code>代码块被执行，接着进入<code>console.log(2)</code> 下方的new中执行<code>console.log(3)</code>，以及<code>resolve()</code>，再执行<code>.then()</code>，此时将调用<code>console.log(4)</code>的回调放入微任务队列末尾</li><li>此时第一个<code>promise.then()</code>中的代码已经执行完毕了，即产生了结果，所以他的下一个<code>then()</code>被执行，<code>console.log(6)</code>被加入微任务队列</li><li>接下来执行<strong>微任务队列</strong>中的<strong>第二个</strong>异步微任务，即第二个<code>promise.then()</code>中的<code>console.log(8)</code></li><li>接着处理微任务队列中的<strong>第三个</strong>异步微任务，即第<strong>6</strong>步放入的任务，执行完毕后，执行下一个<code>then()</code>，<code>console.log(5)</code>的回调被放入微任务队列</li><li>接着处理微任务队列中的<strong>第四个</strong>异步微任务，即第<strong>7</strong>步被放入的调用<code>console.log(6)</code>的回调</li><li>最后执行微任务队列中最后一个任务，即第<strong>9</strong>步中放入的调用<code>console.log(5)</code>的回调</li><li>此时<strong>微任务队列</strong>中的任务已经全部执行完毕，开始转到<strong>宏任务队列</strong>中，执行下一个宏任务</li><li>第<strong>1</strong>步中的计时器 <code>console.log(0)</code>被执行，整个过程执行完毕</li><li>整体输出 1 7 2 3 8 4 6 5 0</li></ol><h2 id="Promise总结"><a href="#Promise总结" class="headerlink" title="Promise总结"></a>Promise总结</h2><p>最后，简单的总结一下Promise主要的的工作过程</p><ul><li>每个promise对象都拥有一个回调容器，包含成功与失败的回调函数，他们在promise本身被创建的时候并不存在</li><li>promise处理异步任务实质是在于在创建promise实例时，内部的状态改变函数一般为同步执行，改变立即其状态以及值，但同时将执行自身的回调函数放入异步微队列中</li><li>then方法的过程分为两种情况<ul><li>第一种情况是当promise无状态时，将收到的函数<strong>立即</strong>推入promise的回调容器中()，等待主线程处理微任务队列</li><li>第二种情况是当promise有状态时，直接将回调函数调用推入异步微队列，并立即返回一个新的promise对象（此时状态暂时为pending），利用JS的闭包，将改变这个返回的promise对象<strong>状态</strong>的函数放入微任务中的回调内，这样做就可以在异步微任务中更新立即返回的promise对象的状态</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 教程 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 实现div的拖拽与变形</title>
      <link href="/2020/08/20/drag-resize/"/>
      <url>/2020/08/20/drag-resize/</url>
      
        <content type="html"><![CDATA[<h1 id="封装一个简单的拖拽-变形的div的模块"><a href="#封装一个简单的拖拽-变形的div的模块" class="headerlink" title="封装一个简单的拖拽+变形的div的模块"></a>封装一个简单的拖拽+变形的div的模块</h1><p>在编写拖拽与变形之前，我们需要知道DOM与元素大小相关的属性</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/EricReevess/proxy/master/img/EED5E2105E90D3063C11A0116A427264.png" alt="elem-size"></p><p>需要的参数：被拖动的元素css选择器elemSelector，容器元素选择器wrapSelector</p><h2 id="拖拽-边界指针提示部分"><a href="#拖拽-边界指针提示部分" class="headerlink" title="拖拽+边界指针提示部分"></a>拖拽+边界指针提示部分</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragElement</span> (<span class="params">elemSelector, wrapSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="built_in">document</span>.querySelector(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> wrapDom = <span class="built_in">document</span>.querySelector(wrapSelector)</span><br><span class="line">  <span class="comment">/* 分别需要 </span></span><br><span class="line"><span class="comment">   鼠标左键按下时相对于被拖动元素内部的坐标mouseDownOffsetX, mouseDownOffsetY</span></span><br><span class="line"><span class="comment">   鼠标指针相对于body可视区域的坐标mouseMoveClientX, mouseMoveClientY</span></span><br><span class="line"><span class="comment">   被拖动元素当前的left 与 top 偏移量 elemLeft, elemTop</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> &#123; offsetHeight, offsetWidth &#125; = elemDom</span><br><span class="line">  <span class="keyword">let</span> mouseDownOffsetX, mouseDownOffsetY, mouseMoveClientX, mouseMoveClientY, elemLeft, elemTop</span><br><span class="line">  <span class="comment">// 将被拖动元素设置为绝对定位，并且将容器元素设置为相对定位，</span></span><br><span class="line">  wrapDom.style.position = <span class="string">&#x27;relative&#x27;</span></span><br><span class="line">  elemDom.style.position = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">  <span class="comment">// 监听鼠标在元素内部的移动事件，为不同区域变换不同的指针类型</span></span><br><span class="line">  elemDom.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, elemMouseMove)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标按下时的事件，记录按下的坐标，并同时添加在容器内部移动鼠标，松开鼠标，离开区域的监听事件，其中后两个的目的是移除鼠标松开和离开容器时的鼠标移动监听</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onElemMousedown</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    mouseMoveClientX = e.clientX</span><br><span class="line">    mouseMoveClientY = e.clientY</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, removeListener)</span><br><span class="line">    wrapDom.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, removeListener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 鼠标在容器上移动的监听事件，实时获取鼠标相对于窗口的坐标，实时改变拖动元素的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mouseMoveOnWrap</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    clientX = e.clientX</span><br><span class="line">    clientY = e.clientY</span><br><span class="line">    elemLeft = mouseMoveClientX - mouseDownOffsetX</span><br><span class="line">    elemTop = mouseMoveClientY - mouseDownOffsetY</span><br><span class="line">    elemDom.style.left = elemLeft + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    elemDom.style.top = elemTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">elemMouseMove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处内部的offsetX, offsetY记录在移动过程中在被拖动元素内部的位置</span></span><br><span class="line">    <span class="keyword">const</span> &#123; offsetX, offsetY &#125; = e</span><br><span class="line">    <span class="comment">// 在元素被变形的时候更新检测宽度和高度，放置在拖动过程中鼠标形状发生错误</span></span><br><span class="line">    offsetHeight = e.target.offsetHeight</span><br><span class="line">    offsetWidth = e.target.offsetWidth</span><br><span class="line">    <span class="comment">//如果 鼠标偏移量在一个内部范围内，即内圈范围，则出现move指针形状，并添加鼠标按下监听事件</span></span><br><span class="line">    <span class="keyword">if</span> (offsetX &gt; <span class="number">6</span> &amp;&amp; offsetX &lt; offsetWidth - <span class="number">6</span> &amp;&amp; offsetY &gt; <span class="number">6</span> &amp;&amp; offsetY &lt; offsetHeight - <span class="number">6</span>) &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;move&#x27;</span></span><br><span class="line">      elemDom.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 此时返回，不做执行移除按下事件</span></span><br><span class="line">    <span class="comment">// 一下是对不同区域变换不同的鼠标指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; <span class="number">-5</span> &amp;&amp; offsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;nw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;ne-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetY &gt; offsetHeight - <span class="number">5</span> &amp;&amp; offsetY &lt; offsetHeight + <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;sw-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;se-resize&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.target.style.cursor = <span class="string">&#x27;n-resize&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetX &gt; <span class="number">-5</span> &amp;&amp; offsetX &lt; <span class="number">5</span> || offsetX &gt; offsetWidth - <span class="number">5</span> &amp;&amp; offsetX &lt; offsetWidth + <span class="number">5</span>) &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;e-resize&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      e.target.style.cursor = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于这些区域都不是拖动的有效区域，在此最好移除鼠标按下事件</span></span><br><span class="line">    elemDom.removeEventListener(<span class="string">&#x27;mousedown&#x27;</span>, onElemMousedown)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除的事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeListener</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.target.style.cursor = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, mouseMoveOnWrap)</span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="built_in">arguments</span>.callee) </span><br><span class="line">    wrapDom.removeEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="built_in">arguments</span>.callee)</span><br><span class="line">    <span class="comment">// 此处调用arguments.callee可将mouseup，mouseleave的监听移除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="边缘拖拽变形部分"><a href="#边缘拖拽变形部分" class="headerlink" title="边缘拖拽变形部分"></a>边缘拖拽变形部分</h2><p>所需参数，被拖动的元素选择器elemSelector，拖动元素的最小宽度和高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeRect</span> (<span class="params">elemSelector, minWidth, minHeight</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要的变量鼠标在按下时的浏览器窗口坐标clientClickDownX, clientClickDownY</span></span><br><span class="line"><span class="comment">  鼠标在拖动过程中的浏览器窗口坐标currentClientX, currentClientY</span></span><br><span class="line"><span class="comment">  鼠标在拖动元素内部的相对坐标rectMouseOffsetX, rectMouseOffsetY</span></span><br><span class="line"><span class="comment">  首先初始化记录拖动元素在点击之前的宽度elemWidth和高度elemHeight以及top值和left值</span></span><br><span class="line"><span class="comment">  并设置元素的最小宽度和高度 minWidth，minHeight</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> clientClickDownX, clientClickDownY, currentClientX, currentClientY, rectMouseOffsetX, rectMouseOffsetY</span><br><span class="line">  <span class="keyword">let</span> elemDom = <span class="built_in">document</span>.querySelector(elemSelector)</span><br><span class="line">  <span class="keyword">let</span> elemHeight = elemDom.offsetHeight</span><br><span class="line">  <span class="keyword">let</span> elemWidth = elemDom.offsetWidth</span><br><span class="line">  <span class="keyword">let</span> elemTop = elemDom.offsetTop</span><br><span class="line">  <span class="keyword">let</span> elemLeft = elemDom.offsetLeft</span><br><span class="line">  elemDom.style.minHeight = minHeight + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  elemDom.style.minWidth = minWidth + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  <span class="comment">// 在按下鼠标的时候，向全局变量记录下按下的浏览器窗口坐标clientClickDown以及元素内部坐标rectMouseOffset</span></span><br><span class="line">  elemDom.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    clientClickDownX = e.clientX</span><br><span class="line">    clientClickDownY = e.clientY</span><br><span class="line">    rectMouseOffsetX = e.offsetX</span><br><span class="line">    rectMouseOffsetY = e.offsetY</span><br><span class="line">  <span class="comment">// 对按下的位置进行判断，分别为上下左右4条边，同时也将4个交也进行了处理，</span></span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &gt; <span class="number">0</span> &amp;&amp; rectMouseOffsetY &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetY &lt; elemHeight + <span class="number">5</span> &amp;&amp; rectMouseOffsetY &gt; elemHeight - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &gt; <span class="number">-5</span> &amp;&amp; rectMouseOffsetX &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rectMouseOffsetX &lt; elemWidth + <span class="number">5</span> &amp;&amp; rectMouseOffsetX &gt; elemWidth - <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 在鼠标抬起时，存储当前元素的宽高以及定位，为下一次判断与变形做准备，同时移除4个可能的事件监听</span></span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    elemTop = elemDom.offsetTop</span><br><span class="line">    elemLeft = elemDom.offsetLeft</span><br><span class="line">    elemHeight = elemDom.offsetHeight</span><br><span class="line">    elemWidth = elemDom.offsetWidth</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectTopResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectBottomResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectLeftResize)</span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, rectRightResize)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 顶部变形，顶部的型变量等于 鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY，最终的高度等于 上一次的高度elemHeight + 变化量 ，同时如果要将元素保持在原位（对边或者对角线不动）,则需要改变对应的定位值，top定位值则等于 当前的定位值elemTop - （鼠标按下的Y轴坐标clientClickDownY- 鼠标当前的Y轴坐标currentClientY），左侧变化同理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectTopResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientY = e.clientY</span><br><span class="line">    elemDom.style.height = elemHeight + (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.offsetHeight === minHeight) &#123;</span><br><span class="line">      elemDom.style.top = elemDom.offsetTop + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.style.top = elemTop - (clientClickDownY - currentClientY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 底部变形则不需要改变top值，因为div的高度增长默认是向下生长，右侧同理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectBottomResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientY = e.clientY</span><br><span class="line">    elemDom.style.height = elemHeight + (currentClientY - clientClickDownY) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectLeftResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientX = e.clientX</span><br><span class="line">    elemDom.style.width = elemWidth + (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (elemDom.offsetWidth === minWidth) &#123;</span><br><span class="line">      elemDom.style.left = elemDom.offsetLeft + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elemDom.style.left = elemLeft - (clientClickDownX - currentClientX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rectRightResize</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    currentClientX = e.clientX</span><br><span class="line">    elemDom.style.width = elemWidth + (currentClientX - clientClickDownX) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h2><p>使用匿名函数自调用(IIFE)，将函数挂载到windows中，成为全局方法,参数minWidth和minHeight默认为5px</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.dragResize = <span class="function"><span class="keyword">function</span> (<span class="params">elemSelector, wrapSelector, minWidth = <span class="number">5</span>, minHeight = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">    dragElement(elemSelector, wrapSelector)</span><br><span class="line">    resizeRect(elemSelector, minWidth, minHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>最终的效果，请访问<a href="https://ericreevess.github.io/webpage-demos/drag-resize/">drag-resize</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 拖拽 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
